[
  {
    "op": "add",
    "path": "/info/x-rust",
    "value": {
      "client": "// Authenticate via an API token.\nlet client = rippling-base-api::Client::new(\"$TOKEN\");\n\n// - OR -\n\n// Authenticate with your token and host parsed from the environment variables:\n// `RIPPLING_BASE_API_TOKEN`.\nlet client = rippling_base_api::Client::new_from_env();",
      "install": "[dependencies]\nrippling-base-api = \"0.1.0\""
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1app_detail~1app_matching_users/get/x-rust",
    "value": {
      "example": "/// GET Matching App Users\n/// \n/// Returns matching users and their app IDs based on the app handles.\n/// \n/// Note:There could be multiple instances of the same app. In this case, the API will return all instances in the format app_handle_app_owner_id.\n/// \n/// \n/// **Parameters:**\n/// \n/// - `app_handles: Option<String>`: CSV of app handles. See GET /app_detail/app_handles\n/// \nasync fn example_application_management_get_app_app_matching_users() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: rippling_base_api::types::GetAppAppMatchingUsersResponse = client\n        .application_management()\n        .get_app_app_matching_users(Some(\"some-string\".to_string()))\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/application_management/struct.ApplicationManagement.html#method.get_app_app_matching_users"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1ats_candidates~1push_candidate/post/x-rust",
    "value": {
      "example": "/// POST New Candidate\n/// \n/// Pushes a candidate from an applicant tracking system directly into the Rippling onboarding flow. Please note, this endpoint is only available to applications integrating with OAuth2.0.\n/// \n/// NOTE: This endpoint is NOT available for use with Rippling customer API Keys.\nasync fn example_ats_post_candidates_push_candidate() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: rippling_base_api::types::Candidate = client\n        .ats()\n        .post_candidates_push_candidate(&rippling_base_api::types::Candidate {\n            name: Some(\"some-string\".to_string()),\n            email: Some(\"some-string\".to_string()),\n            job_title: Some(\"some-string\".to_string()),\n            phone_number: Some(\"some-string\".to_string()),\n            candidate_id: Some(\"some-string\".to_string()),\n            start_date: Some(chrono::Utc::now().date_naive()),\n            salary_unit: Some(rippling_base_api::types::SalaryUnit::PayPeriod),\n            salary_per_unit: Some(3.14 as f64),\n            signing_bonus: Some(3.14 as f64),\n            currency: Some(\"some-string\".to_string()),\n            equity_shares: Some(4 as i64),\n            department: Some(\"some-string\".to_string()),\n            employment_type: Some(rippling_base_api::types::CandidateEmploymentType::Temp),\n            work_location: Some(\"some-string\".to_string()),\n            attachments: Some(vec![rippling_base_api::types::Attachments {\n                file_name: Some(\"some-string\".to_string()),\n                file_url: Some(\"some-string\".to_string()),\n            }]),\n        })\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/ats/struct.Ats.html#method.post_candidates_push_candidate"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1companies~1current/get/x-rust",
    "value": {
      "example": "/// GET Current Company\n/// \n/// Returns the currently accessible company for the given token. Please note, the returned fields depend on the scopes that are enabled for your access token or API key.\nasync fn example_companies_get() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: rippling_base_api::types::Company = client.companies().get().await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/companies/struct.Companies.html#method.get"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1company_activity/get/x-rust",
    "value": {
      "example": "/// GET Company Activity\n/// \n/// Retrieves the activity for a given company.\n/// \n/// The most reliable method to ingest all activity from Rippling is to use a pagination cursor via the 'next' parameter. This will ensure that events are not skipped or duplicated due to the lack of timestamp precision.\n/// \n/// The general sequence of steps to leverage the next parameter:\n/// \n/// 1. Issue an initial request using startDate with a value set to some date in the last 90 days\n/// 2. Retrieve the next page of events through the next value from the response data.\n/// 3. Issue the paginated request\n/// 4. Retrieve the next page of events through the next value from the response data\n/// 5. Pause and repeat the previous step\n/// \n/// \n/// **Parameters:**\n/// \n/// - `end_date: Option<chrono::NaiveDate>`: Timestamp to list activity before (inclusive).\n/// - `limit: Option<String>`: Specifies the number of results to page (maximum: 1000) (default: 1000)\n/// - `next: Option<String>`: Specifies the pagination cursor to the next page\n/// - `start_date: Option<chrono::NaiveDate>`: Timestamp to list activity after (inclusive). This should be less than 90 days from now. Defaults to 90 days.\nasync fn example_companies_get_company_activity() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: rippling_base_api::types::GetCompanyActivityResponse = client\n        .companies()\n        .get_company_activity(\n            Some(chrono::Utc::now().date_naive()),\n            Some(\"some-string\".to_string()),\n            Some(\"some-string\".to_string()),\n            Some(chrono::Utc::now().date_naive()),\n        )\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/companies/struct.Companies.html#method.get_company_activity"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1company_leave_types/get/x-rust",
    "value": {
      "example": "/// GET Company Leave Types\n/// \n/// Retrieves the current company leave types. The query can be filtered by managedBy field.\n/// \n/// **Parameters:**\n/// \n/// - `managed_by: Option<String>`\nasync fn example_companies_get_company_leave_types() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: Vec<rippling_base_api::types::CompanyLeaveType> = client\n        .companies()\n        .get_company_leave_types(Some(\"some-string\".to_string()))\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/companies/struct.Companies.html#method.get_company_leave_types"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1custom_fields/get/x-rust",
    "value": {
      "example": "/// GET Custom Fields\n/// \n/// Returns the custom fields for the given company.\n/// \n/// **Parameters:**\n/// \n/// - `limit: Option<i64>`: Sets a limit on the returned values\n/// - `offset: Option<i64>`: Offsets the returned values\nasync fn example_companies_get_custom_fields() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: Vec<rippling_base_api::types::CustomFields> = client\n        .companies()\n        .get_custom_fields(Some(4 as i64), Some(4 as i64))\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/companies/struct.Companies.html#method.get_custom_fields"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1departments/get/x-rust",
    "value": {
      "example": "/// GET Departments\n/// \n/// Returns a list of departments for the given company.\n/// \n/// **Parameters:**\n/// \n/// - `limit: Option<i64>`: Sets a limit on the returned values\n/// - `offset: Option<i64>`: Offsets the returned values\nasync fn example_companies_get_departments() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: Vec<Option<rippling_base_api::types::Department>> = client\n        .companies()\n        .get_departments(Some(4 as i64), Some(4 as i64))\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/companies/struct.Companies.html#method.get_departments"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1employees/get/x-rust",
    "value": {
      "example": "/// GET Employees\n/// \n/// Retrieves the list of active employees currently provisioned within the application. The fields retrieved depend on the employee scopes that you have access to for your access token or API key. The only guarenteed fields include id, personalEmail, and roleState.\n/// \n/// For optimal performance, ensure pagination is used via our limit and offset parameters. Pagination should be set to a maximum of 100.\n/// \n/// **Parameters:**\n/// \n/// - `limit: Option<i64>`: Sets a limit on the returned values\n/// - `offset: Option<i64>`: Offsets the returned values\nasync fn example_employees_get() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: Vec<rippling_base_api::types::Employee> = client\n        .employees()\n        .get(Some(4 as i64), Some(4 as i64))\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/employees/struct.Employees.html#method.get"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1employees~1include_terminated/get/x-rust",
    "value": {
      "example": "/// GET Employees (Including Terminated)\n/// \n/// This endpoint is similar to the active employees endpoint, but instead, it includes both active and terminated employees.\n/// \n/// For optimal performance, ensure pagination is used via our limit and offset parameters. Pagination should be set to a maximum of 100.\n/// \n/// **Parameters:**\n/// \n/// - `ein: Option<i64>`: Employer identification number, also known as the Federal Emplower Identification Number or the Federal Tax Identification Number.\n/// - `limit: Option<i64>`: Sets a limit on the returned values\n/// - `offset: Option<i64>`: Offsets the returned values\n/// - `send_all_roles: Option<bool>`: For integrations that rely on provisioning, this parameter can be used to identify non provisioned roles for compliance purposes. TRUE will return every employee from the company (bypassing any access rules).\nasync fn example_employees_get_include_terminated() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: Vec<rippling_base_api::types::Employee> = client\n        .employees()\n        .get_include_terminated(Some(4 as i64), Some(4 as i64), Some(4 as i64), Some(false))\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/employees/struct.Employees.html#method.get_include_terminated"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1employees~1{employeeId}/get/x-rust",
    "value": {
      "example": "/// GET Employee\n/// \n/// Retrieves the information for a single employee based on the scopes that your API key or access token have access to.\n/// \n/// **Parameters:**\n/// \n/// - `employee_id: &'astr`: Unique identifier for the employee within Rippling. (required)\nasync fn example_employees_get_id() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: rippling_base_api::types::Employee = client.employees().get_id(\"some-string\").await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/employees/struct.Employees.html#method.get_id"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1groups/get/x-rust",
    "value": {
      "example": "/// GET Groups\n/// \n/// Please note, the Groups endpoint requires an OAuth application (i.e. approved 3rd party partners), as the end point is intended for mapping third-party application “Groups” within Rippling organizations.\n/// \n/// Lists the current third-party groups for an organization.\nasync fn example_groups_get() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: Vec<rippling_base_api::types::Group> = client.groups().get().await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/groups/struct.Groups.html#method.get"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1groups/post/x-rust",
    "value": {
      "example": "/// POST Groups\n/// \n/// Creates a generic group, that can be associated within the third-party application.\nasync fn example_groups_post() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: rippling_base_api::types::Group = client\n        .groups()\n        .post(&rippling_base_api::types::PostGroupsRequestBody {\n            name: Some(\"some-string\".to_string()),\n            spoke_id: Some(\"some-string\".to_string()),\n            users: Some(vec![\"some-string\".to_string()]),\n        })\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/groups/struct.Groups.html#method.post"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1groups~1{groupId}/delete/x-rust",
    "value": {
      "example": "/// DELETE Group\n/// \n/// Please note, the Groups endpoint requires an OAuth application (i.e. approved 3rd party partners), as the end point is intended for mapping third-party application “Groups” within Rippling organizations.\n/// \n/// Deletes the specified group.\n/// \n/// **Parameters:**\n/// \n/// - `group_id: i64`: Unique identifier for the group within Rippling. (required)\nasync fn example_groups_delete_id() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    client.groups().delete_id(4 as i64).await?;\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/groups/struct.Groups.html#method.delete_id"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1groups~1{groupId}/get/x-rust",
    "value": {
      "example": "/// GET Group\n/// \n/// Please note, the Groups endpoint requires an OAuth application (i.e. approved 3rd party partners), as the end point is intended for mapping third-party application “Groups” within Rippling organizations.\n/// \n/// **Parameters:**\n/// \n/// - `group_id: i64`: Unique identifier for the group within Rippling. (required)\nasync fn example_groups_get_id() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: rippling_base_api::types::Group = client\n        .groups()\n        .get_id(\n            4 as i64,\n            &rippling_base_api::types::GroupUpdatePayload {\n                name: Some(\"some-string\".to_string()),\n                spoke_id: Some(\"some-string\".to_string()),\n                users: Some(vec![serde_json::Value::String(\"some-string\".to_string())]),\n                version: Some(\"some-string\".to_string()),\n            },\n        )\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/groups/struct.Groups.html#method.get_id"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1groups~1{groupId}/patch/x-rust",
    "value": {
      "example": "/// PATCH Group\n/// \n/// Please note, the Groups endpoint requires an OAuth application (i.e. approved 3rd party partners), as the end point is intended for mapping third-party application “Groups” within Rippling organizations.\n/// \n/// Using the PUT method, all of the group fields will be updated, even if the corresponding parameter is missing. If the PATCH method is used, and a param is missing, its value won’t be changed.\n/// \n/// **Parameters:**\n/// \n/// - `group_id: i64`: Unique identifier for the group within Rippling. (required)\nasync fn example_groups_patch_id() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: rippling_base_api::types::Group = client\n        .groups()\n        .patch_id(\n            4 as i64,\n            &rippling_base_api::types::GroupUpdatePayload {\n                name: Some(\"some-string\".to_string()),\n                spoke_id: Some(\"some-string\".to_string()),\n                users: Some(vec![serde_json::Value::String(\"some-string\".to_string())]),\n                version: Some(\"some-string\".to_string()),\n            },\n        )\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/groups/struct.Groups.html#method.patch_id"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1groups~1{groupId}/put/x-rust",
    "value": {
      "example": "/// PUT Group\n/// \n/// Please note, the Groups endpoint requires an OAuth application (i.e. approved 3rd party partners), as the end point is intended for mapping third-party application “Groups” within Rippling organizations.\n/// \n/// Using the PUT method, all of the group fields will be updated, even if the corresponding parameter is missing. If the PATCH method is used, and a param is missing, its value won’t be changed.\n/// \n/// **Parameters:**\n/// \n/// - `group_id: i64`: Unique identifier for the group within Rippling. (required)\nasync fn example_groups_put_id() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: rippling_base_api::types::Group = client\n        .groups()\n        .put_id(\n            4 as i64,\n            &rippling_base_api::types::GroupUpdatePayload {\n                name: Some(\"some-string\".to_string()),\n                spoke_id: Some(\"some-string\".to_string()),\n                users: Some(vec![serde_json::Value::String(\"some-string\".to_string())]),\n                version: Some(\"some-string\".to_string()),\n            },\n        )\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/groups/struct.Groups.html#method.put_id"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1leave_balances/get/x-rust",
    "value": {
      "example": "/// GET Leave Balances\n/// \n/// Retrieves the leave balances for employees\n/// \n/// **Parameters:**\n/// \n/// - `limit: Option<i64>`: Sets a limit on the returned values\n/// - `offset: Option<i64>`: Offset the returned values\nasync fn example_leaves_get_balances() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: rippling_base_api::types::GetLeaveBalancesResponse = client\n        .leaves()\n        .get_balances(Some(4 as i64), Some(4 as i64))\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/leaves/struct.Leaves.html#method.get_balances"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1leave_balances~1{role}/get/x-rust",
    "value": {
      "example": "/// GET Leave Balance\n/// \n/// Retrieves the leave balances for a given role. A role represents 1 employee. An employee can work at 1 and only 1 company.\n/// \n/// **Parameters:**\n/// \n/// - `role: &'astr`: This is the unique role ID of the employee. It corresponds to the IDs returned in the Get/employees endpoint (required)\nasync fn example_leaves_get_balance() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: rippling_base_api::types::GetLeaveBalanceResponse =\n        client.leaves().get_balance(\"some-string\").await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/leaves/struct.Leaves.html#method.get_balance"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1leave_requests/get/x-rust",
    "value": {
      "example": "/// GET Leave Requests\n/// \n/// Retrieves the current leave requests.The query can be filtered by a number of specific query parameters.\n/// \n/// **Parameters:**\n/// \n/// - `end_date: Option<String>`: End date of leave.\n/// - `from: Option<String>`: Filter to capture whether the leave request overlaps with a date range.\n/// - `id: Option<String>`\n/// - `leave_policy: Option<String>`\n/// - `limit: Option<String>`: Sets a limit on the returned values\n/// - `offset: Option<String>`: Offsets the returned values\n/// - `processed_by: Option<String>`\n/// - `requested_by: Option<String>`\n/// - `role: Option<String>`\n/// - `start_date: Option<String>`: Start date of leave.\n/// - `status: Option<String>`\n/// - `to: Option<String>`: Filter to capture whether the leave request overlaps with a date range.\nasync fn example_leaves_get_requests() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: Vec<rippling_base_api::types::LeaveRequest> = client\n        .leaves()\n        .get_requests(\n            Some(\"some-string\".to_string()),\n            Some(\"some-string\".to_string()),\n            Some(\"some-string\".to_string()),\n            Some(\"some-string\".to_string()),\n            Some(\"some-string\".to_string()),\n            Some(\"some-string\".to_string()),\n            Some(\"some-string\".to_string()),\n            Some(\"some-string\".to_string()),\n            Some(\"some-string\".to_string()),\n            Some(\"some-string\".to_string()),\n            Some(\"some-string\".to_string()),\n            Some(\"some-string\".to_string()),\n        )\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/leaves/struct.Leaves.html#method.get_requests"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1leave_requests/post/x-rust",
    "value": {
      "example": "/// POST Leave Request\n/// \n/// Create a leave request. This endpoint is currently in alpha and should not be used by default. Only TILT managed requests can have a status other than PENDING.\nasync fn example_leaves_post_requests() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: rippling_base_api::types::LeaveRequest = client\n        .leaves()\n        .post_requests(&rippling_base_api::types::PostLeaveRequestsRequestBody {\n            role: \"some-string\".to_string(),\n            requested_by: Some(\"some-string\".to_string()),\n            status: Some(\"some-string\".to_string()),\n            start_date: \"some-string\".to_string(),\n            end_date: \"some-string\".to_string(),\n            start_date_start_time: Some(\"some-string\".to_string()),\n            end_date_end_time: Some(\"some-string\".to_string()),\n            start_date_custom_hours: Some(\"some-string\".to_string()),\n            end_date_custom_hours: Some(\"some-string\".to_string()),\n            company_leave_type: \"some-string\".to_string(),\n            leave_policy: \"some-string\".to_string(),\n            reason_for_leave: Some(\"some-string\".to_string()),\n            managed_by: Some(\"some-string\".to_string()),\n            external_id: Some(\"some-string\".to_string()),\n        })\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/leaves/struct.Leaves.html#method.post_requests"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1leave_requests~1{id}/patch/x-rust",
    "value": {
      "example": "/// PATCH Leave Request\n/// \n/// Update an existing leave request. With the exception of TILT-managed leave requests, updates are restricted based on status; APPROVED requests can not be updated with different dates, and the status itself can not be updated. Use the process endpoint to update the status of a PENDING request. For other updates, use the cancel endpoint to cancel the request, and create a new request with the updated information.\n/// \n/// **Parameters:**\n/// \n/// - `id: &'astr`: Unique identifier of the leave request being modified (required)\nasync fn example_leaves_patch_requests_request_id() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: Vec<rippling_base_api::types::LeaveRequest> = client\n        .leaves()\n        .patch_requests_request_id(\n            \"some-string\",\n            &rippling_base_api::types::PatchLeaveRequestsLeaveRequestIdRequestBody {\n                requested_by: Some(\"some-string\".to_string()),\n                status: Some(\"some-string\".to_string()),\n                start_date: Some(\"some-string\".to_string()),\n                end_date: Some(\"some-string\".to_string()),\n                start_date_start_time: Some(\"some-string\".to_string()),\n                end_date_end_time: Some(\"some-string\".to_string()),\n                start_date_custom_hours: Some(\"some-string\".to_string()),\n                end_date_custom_hours: Some(\"some-string\".to_string()),\n                reason_for_leave: Some(\"some-string\".to_string()),\n            },\n        )\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/leaves/struct.Leaves.html#method.patch_requests_request_id"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1leave_requests~1{id}~1cancel/post/x-rust",
    "value": {
      "example": "/// POST Cancel Leave Request\n/// \n/// Cancel a leave request.\n/// \n/// **Parameters:**\n/// \n/// - `id: &'astr`: Unique identifier of the leave request being canceled. (required)\nasync fn example_leaves_cancel_requests() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: rippling_base_api::types::LeaveRequest = client.leaves().cancel_requests(\"some-string\").await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/leaves/struct.Leaves.html#method.cancel_requests"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1leave_requests~1{id}~1process/post/x-rust",
    "value": {
      "example": "/// POST Process Leave Request\n/// \n/// Approve or decline a leave request. Only pending requests can be processed (approved / declined). Only an admin or manager is capable of taking action on a request.\n/// \n/// **Parameters:**\n/// \n/// - `action: crate::types::Action`: The action to be taken on the leave request. Can be either approved or declined. (required)\n/// - `id: &'astr`: Unique identifier of the leave request being processed. (required)\nasync fn example_leaves_process_requests() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: rippling_base_api::types::LeaveRequest = client\n        .leaves()\n        .process_requests(rippling_base_api::types::Action::Decline, \"some-string\")\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/leaves/struct.Leaves.html#method.process_requests"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1levels/get/x-rust",
    "value": {
      "example": "/// GET Levels\n/// \n/// Retrieves the levels for the company. Levels are set positions for an organization, such as Manager, or Executive.\n/// \n/// **Parameters:**\n/// \n/// - `limit: Option<i64>`: Sets a limit on the returned values\n/// - `offset: Option<i64>`: Offsets the returned values\nasync fn example_companies_get_levels() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: Vec<rippling_base_api::types::Level> = client\n        .companies()\n        .get_levels(Some(4 as i64), Some(4 as i64))\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/companies/struct.Companies.html#method.get_levels"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1mark_app_installed/post/x-rust",
    "value": {
      "example": "/// Mark App Installed\n/// \n/// This endpoint can be hit to mark your app as installed in Rippling, if you aren't hitting Rippling's other endpoints on installation. The endpoint does not require any scopes.\n/// \n/// Please note, hitting any other endpoint should mark your app as installed as well.\nasync fn example_application_management_post_mark_app_installed() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: rippling_base_api::types::PostMarkAppInstalledResponse = client\n        .application_management()\n        .post_mark_app_installed()\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/application_management/struct.ApplicationManagement.html#method.post_mark_app_installed"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1me/get/x-rust",
    "value": {
      "example": "/// GCurrent User\n/// \n/// Retrieves basic information about the Rippling user whose access token you're using. This is generally used for the SSO flow.\nasync fn example_current_user_get_me() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: rippling_base_api::types::AuthenticatedUserMe = client.current_user().get_me().await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/current_user/struct.CurrentUser.html#method.get_me"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1saml~1idp_metadata/get/x-rust",
    "value": {
      "example": "/// GET SAML Metadata\n/// \n/// Returns a SAML IDP metadata file for the current app integration. Note that this endpoint is only accessible using a token associated with an app integration that has SAML enabled; otherwise it returns a 404 error.\n/// \n/// Rippling's SAML Metadata is per customer app installation. It is not the same across all customers. It is not the same if the customer uninstalls and reinstalls your app. Any time a new app is installed, unique SAML Metadata will be generated specific to that app.\nasync fn example_saml_get_idp_metadata() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: String = client.saml().get_idp_metadata().await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/saml/struct.Saml.html#method.get_idp_metadata"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1teams/get/x-rust",
    "value": {
      "example": "/// GET Teams\n/// \n/// Retrieves the list of teams for the company.\n/// \n/// **Parameters:**\n/// \n/// - `limit: Option<i64>`: Sets a limit on the returned values\n/// - `offset: Option<i64>`: Offsets the returned values\nasync fn example_companies_get_teams() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: Vec<rippling_base_api::types::Team> = client\n        .companies()\n        .get_teams(Some(4 as i64), Some(4 as i64))\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/companies/struct.Companies.html#method.get_teams"
    }
  },
  {
    "op": "add",
    "path": "/paths/~1platform~1api~1work_locations/get/x-rust",
    "value": {
      "example": "/// GET Work Locations\n/// \n/// Returns the list of work locations for a given company.\n/// \n/// **Parameters:**\n/// \n/// - `limit: Option<i64>`: Sets a limit on the returned values\n/// - `offset: Option<i64>`: Offsets the returned values\nasync fn example_companies_get_work_locations() -> anyhow::Result<()> {\n    let client = rippling_base_api::Client::new_from_env();\n    let result: Vec<rippling_base_api::types::WorkLocation> = client\n        .companies()\n        .get_work_locations(Some(4 as i64), Some(4 as i64))\n        .await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n",
      "libDocsLink": "https://docs.rs/rippling-base-api/latest/rippling-base-api/companies/struct.Companies.html#method.get_work_locations"
    }
  }
]