#![doc = r" This module contains the generated types for the library."]
use tabled::Tabled;
pub mod base64 {
    #![doc = " Base64 data that encodes to url safe base64, but can decode from multiple"]
    #![doc = " base64 implementations to account for various clients and libraries. Compatible"]
    #![doc = " with serde and JsonSchema."]
    use std::{convert::TryFrom, fmt};

    use serde::{
        de::{Error, Unexpected, Visitor},
        Deserialize, Deserializer, Serialize, Serializer,
    };
    static ALLOWED_DECODING_FORMATS: &[data_encoding::Encoding] = &[
        data_encoding::BASE64,
        data_encoding::BASE64URL,
        data_encoding::BASE64URL_NOPAD,
        data_encoding::BASE64_MIME,
        data_encoding::BASE64_NOPAD,
    ];
    #[derive(Debug, Clone, PartialEq, Eq)]
    #[doc = " A container for binary that should be base64 encoded in serialisation. In reverse"]
    #[doc = " when deserializing, will decode from many different types of base64 possible."]
    pub struct Base64Data(pub Vec<u8>);
    impl Base64Data {
        #[doc = " Return is the data is empty."]
        pub fn is_empty(&self) -> bool {
            self.0.is_empty()
        }
    }

    impl fmt::Display for Base64Data {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{}", data_encoding::BASE64URL_NOPAD.encode(&self.0))
        }
    }

    impl From<Base64Data> for Vec<u8> {
        fn from(data: Base64Data) -> Vec<u8> {
            data.0
        }
    }

    impl From<Vec<u8>> for Base64Data {
        fn from(data: Vec<u8>) -> Base64Data {
            Base64Data(data)
        }
    }

    impl AsRef<[u8]> for Base64Data {
        fn as_ref(&self) -> &[u8] {
            &self.0
        }
    }

    impl TryFrom<&str> for Base64Data {
        type Error = anyhow::Error;
        fn try_from(v: &str) -> Result<Self, Self::Error> {
            for config in ALLOWED_DECODING_FORMATS {
                if let Ok(data) = config.decode(v.as_bytes()) {
                    return Ok(Base64Data(data));
                }
            }
            anyhow::bail!("Could not decode base64 data: {}", v);
        }
    }

    struct Base64DataVisitor;
    impl<'de> Visitor<'de> for Base64DataVisitor {
        type Value = Base64Data;
        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            write!(formatter, "a base64 encoded string")
        }

        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
        where
            E: Error,
        {
            for config in ALLOWED_DECODING_FORMATS {
                if let Ok(data) = config.decode(v.as_bytes()) {
                    return Ok(Base64Data(data));
                }
            }
            Err(serde::de::Error::invalid_value(Unexpected::Str(v), &self))
        }
    }

    impl<'de> Deserialize<'de> for Base64Data {
        fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
        where
            D: Deserializer<'de>,
        {
            deserializer.deserialize_str(Base64DataVisitor)
        }
    }

    impl Serialize for Base64Data {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            let encoded = data_encoding::BASE64URL_NOPAD.encode(&self.0);
            serializer.serialize_str(&encoded)
        }
    }

    impl schemars::JsonSchema for Base64Data {
        fn schema_name() -> String {
            "Base64Data".to_string()
        }

        fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
            let mut obj = gen.root_schema_for::<String>().schema;
            obj.format = Some("byte".to_string());
            schemars::schema::Schema::Object(obj)
        }

        fn is_referenceable() -> bool {
            false
        }
    }

    #[cfg(test)]
    mod tests {
        use std::convert::TryFrom;

        use super::Base64Data;
        #[test]
        fn test_base64_try_from() {
            assert!(Base64Data::try_from("aGVsbG8=").is_ok());
            assert!(Base64Data::try_from("abcdefghij").is_err());
        }
    }
}

pub mod paginate {
    #![doc = " Utility functions used for pagination."]
    use anyhow::Result;
    #[doc = " A trait for types that allow pagination."]
    pub trait Pagination {
        #[doc = " The item that is paginated."]
        type Item: serde::de::DeserializeOwned;
        #[doc = " Returns true if the response has more pages."]
        fn has_more_pages(&self) -> bool;
        #[doc = " Modify a request to get the next page."]
        fn next_page(
            &self,
            req: reqwest::Request,
        ) -> Result<reqwest::Request, crate::types::error::Error>;
        #[doc = " Get the items from a page."]
        fn items(&self) -> Vec<Self::Item>;
    }
}

pub mod phone_number {
    #![doc = " A library to implement phone numbers for our database and JSON serialization and \
              deserialization."]
    use std::str::FromStr;

    use schemars::JsonSchema;
    #[doc = " A phone number."]
    #[derive(Debug, Default, Clone, PartialEq, Hash, Eq)]
    pub struct PhoneNumber(pub Option<phonenumber::PhoneNumber>);
    impl From<phonenumber::PhoneNumber> for PhoneNumber {
        fn from(id: phonenumber::PhoneNumber) -> PhoneNumber {
            PhoneNumber(Some(id))
        }
    }

    impl AsRef<Option<phonenumber::PhoneNumber>> for PhoneNumber {
        fn as_ref(&self) -> &Option<phonenumber::PhoneNumber> {
            &self.0
        }
    }

    impl std::ops::Deref for PhoneNumber {
        type Target = Option<phonenumber::PhoneNumber>;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    impl serde::ser::Serialize for PhoneNumber {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            serializer.serialize_str(&self.to_string())
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PhoneNumber {
        fn deserialize<D>(deserializer: D) -> Result<PhoneNumber, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let s = String::deserialize(deserializer).unwrap_or_default();
            PhoneNumber::from_str(&s).map_err(serde::de::Error::custom)
        }
    }

    impl std::str::FromStr for PhoneNumber {
        type Err = anyhow::Error;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            if s.trim().is_empty() {
                return Ok(PhoneNumber(None));
            }
            let s = if !s.trim().starts_with('+') {
                format!("+1{s}")
                    .replace('-', "")
                    .replace(['(', ')', ' '], "")
            } else {
                s.replace(['-', '(', ')', ' '], "")
            };
            Ok(PhoneNumber(Some(phonenumber::parse(None, &s).map_err(
                |e| anyhow::anyhow!("invalid phone number `{}`: {}", s, e),
            )?)))
        }
    }

    impl std::fmt::Display for PhoneNumber {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let s = if let Some(phone) = &self.0 {
                phone
                    .format()
                    .mode(phonenumber::Mode::International)
                    .to_string()
            } else {
                String::new()
            };
            write!(f, "{s}")
        }
    }

    impl JsonSchema for PhoneNumber {
        fn schema_name() -> String {
            "PhoneNumber".to_string()
        }

        fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
            let mut obj = gen.root_schema_for::<String>().schema;
            obj.format = Some("phone".to_string());
            schemars::schema::Schema::Object(obj)
        }

        fn is_referenceable() -> bool {
            false
        }
    }

    #[cfg(test)]
    mod test {
        use pretty_assertions::assert_eq;

        use super::PhoneNumber;
        #[test]
        fn test_parse_phone_number() {
            let mut phone = "+1-555-555-5555";
            let mut phone_parsed: PhoneNumber =
                serde_json::from_str(&format!(r#""{phone}""#)).unwrap();
            let mut expected = PhoneNumber(Some(phonenumber::parse(None, phone).unwrap()));
            assert_eq!(phone_parsed, expected);
            let mut expected_str = "+1 555-555-5555";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "555-555-5555";
            phone_parsed = serde_json::from_str(&format!(r#""{phone}""#)).unwrap();
            assert_eq!(phone_parsed, expected);
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "+1 555-555-5555";
            phone_parsed = serde_json::from_str(&format!(r#""{phone}""#)).unwrap();
            assert_eq!(phone_parsed, expected);
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "5555555555";
            phone_parsed = serde_json::from_str(&format!(r#""{phone}""#)).unwrap();
            assert_eq!(phone_parsed, expected);
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "(510) 864-1234";
            phone_parsed = serde_json::from_str(&format!(r#""{phone}""#)).unwrap();
            expected = PhoneNumber(Some(phonenumber::parse(None, "+15108641234").unwrap()));
            assert_eq!(phone_parsed, expected);
            expected_str = "+1 510-864-1234";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "(510)8641234";
            phone_parsed = serde_json::from_str(&format!(r#""{phone}""#)).unwrap();
            assert_eq!(phone_parsed, expected);
            expected_str = "+1 510-864-1234";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
            phone = "";
            phone_parsed = serde_json::from_str(&format!(r#""{phone}""#)).unwrap();
            assert_eq!(phone_parsed, PhoneNumber(None));
            assert_eq!("", serde_json::json!(phone_parsed));
            phone = "+49 30  1234 1234";
            phone_parsed = serde_json::from_str(&format!(r#""{phone}""#)).unwrap();
            expected = PhoneNumber(Some(phonenumber::parse(None, phone).unwrap()));
            assert_eq!(phone_parsed, expected);
            expected_str = "+49 30 12341234";
            assert_eq!(expected_str, serde_json::json!(phone_parsed));
        }
    }
}

pub mod error {
    #![doc = " Error methods."]
    #[doc = " Error produced by generated client methods."]
    pub enum Error {
        #[doc = " The request did not conform to API requirements."]
        InvalidRequest(String),
        #[doc = " A server error either due to the data, or with the connection."]
        CommunicationError(reqwest_middleware::Error),
        #[doc = " A request error, caused when building the request."]
        RequestError(reqwest::Error),
        #[doc = " An expected response whose deserialization failed."]
        SerdeError {
            #[doc = " The error."]
            error: format_serde_error::SerdeError,
            #[doc = " The response status."]
            status: reqwest::StatusCode,
        },
        #[doc = " An expected error response."]
        InvalidResponsePayload {
            #[doc = " The error."]
            error: reqwest_middleware::Error,
            #[doc = " The full response."]
            response: reqwest::Response,
        },
        #[doc = " A response not listed in the API description. This may represent a"]
        #[doc = " success or failure response; check `status().is_success()`."]
        UnexpectedResponse(reqwest::Response),
    }

    impl Error {
        #[doc = " Returns the status code, if the error was generated from a response."]
        pub fn status(&self) -> Option<reqwest::StatusCode> {
            match self {
                Error::InvalidRequest(_) => None,
                Error::RequestError(e) => e.status(),
                Error::CommunicationError(reqwest_middleware::Error::Reqwest(e)) => e.status(),
                Error::CommunicationError(reqwest_middleware::Error::Middleware(_)) => None,
                Error::SerdeError { error: _, status } => Some(*status),
                Error::InvalidResponsePayload { error: _, response } => Some(response.status()),
                Error::UnexpectedResponse(r) => Some(r.status()),
            }
        }

        #[doc = " Creates a new error from a response status and a serde error."]
        pub fn from_serde_error(
            e: format_serde_error::SerdeError,
            status: reqwest::StatusCode,
        ) -> Self {
            Self::SerdeError { error: e, status }
        }
    }

    impl From<reqwest_middleware::Error> for Error {
        fn from(e: reqwest_middleware::Error) -> Self {
            Self::CommunicationError(e)
        }
    }

    impl From<reqwest::Error> for Error {
        fn from(e: reqwest::Error) -> Self {
            Self::RequestError(e)
        }
    }

    impl std::fmt::Display for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                Error::InvalidRequest(s) => {
                    write!(f, "Invalid Request: {s}")
                }
                Error::CommunicationError(e) => {
                    write!(f, "Communication Error: {e}")
                }
                Error::RequestError(e) => {
                    write!(f, "Request Error: {e}")
                }
                Error::SerdeError { error, status: _ } => {
                    write!(f, "Serde Error: {error}")
                }
                Error::InvalidResponsePayload { error, response: _ } => {
                    write!(f, "Invalid Response Payload: {error}")
                }
                Error::UnexpectedResponse(r) => {
                    write!(f, "Unexpected Response: {r:?}")
                }
            }
        }
    }

    trait ErrorFormat {
        fn fmt_info(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
    }

    impl std::fmt::Debug for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            std::fmt::Display::fmt(self, f)
        }
    }

    impl std::error::Error for Error {
        fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
            match self {
                Error::CommunicationError(e) => Some(e),
                Error::SerdeError { error, status: _ } => Some(error),
                Error::InvalidResponsePayload { error, response: _ } => Some(error),
                _ => None,
            }
        }
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct SubresourceUris {}

impl std::fmt::Display for SubresourceUris {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for SubresourceUris {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<String> {
        vec![]
    }

    fn headers() -> Vec<String> {
        vec![]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010Account {
    #[doc = "The authorization token for this account. This token should be kept a secret, so no \
             sharing."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth_token: Option<String>,
    #[doc = "The date that this account was created, in GMT in RFC 2822 format"]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date that this account was last updated, in GMT in RFC 2822 format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "A human readable description of this account, up to 64 characters long. By default \
             the FriendlyName is your email address."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The unique 34 character id that represents the parent of this account. The \
             OwnerAccountSid of a parent account is it's own sid."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub owner_account_sid: Option<String>,
    #[doc = "A 34 character string that uniquely identifies this resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<AccountEnumStatus>,
    #[doc = "A Map of various subresources available for the given Account Instance"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<AccountEnumType>,
    #[doc = "The URI for this resource, relative to `https://api.twilio.com`"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010Account {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010Account {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(auth_token) = &self.auth_token {
                format!("{auth_token:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(owner_account_sid) = &self.owner_account_sid {
                format!("{owner_account_sid:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
            if let Some(type_) = &self.type_ {
                format!("{type_:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "auth_token".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "friendly_name".to_string(),
            "owner_account_sid".to_string(),
            "sid".to_string(),
            "status".to_string(),
            "subresource_uris".to_string(),
            "type_".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum AccountEnumStatus {
    #[serde(rename = "active")]
    #[display("active")]
    Active,
    #[serde(rename = "suspended")]
    #[display("suspended")]
    Suspended,
    #[serde(rename = "closed")]
    #[display("closed")]
    Closed,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum AccountEnumType {
    Trial,
    Full,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountAddress {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that is \
             responsible for the Address resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The city in which the address is located."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub city: Option<String>,
    #[doc = "The name associated with the address.This property has a maximum length of 16 4-byte \
             characters, or 21 3-byte characters."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub customer_name: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The string that you assigned to describe the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The ISO country code of the address."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iso_country: Option<String>,
    #[doc = "The postal code of the address."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postal_code: Option<String>,
    #[doc = "The state or region of the address."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[doc = "The unique string that that we created to identify the Address resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The number and street address of the address."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub street: Option<String>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "Whether emergency calling has been enabled on this number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emergency_enabled: Option<bool>,
    #[doc = "Whether the address has been validated to comply with local regulation. In countries \
             that require valid addresses, an invalid address will not be accepted. `true` \
             indicates the Address has been validated. `false` indicate the country doesn't \
             require validation or the Address is not valid."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub validated: Option<bool>,
    #[doc = "Whether the address has been verified to comply with regulation. In countries that \
             require valid addresses, an invalid address will not be accepted. `true` indicates \
             the Address has been verified. `false` indicate the country doesn't require verified \
             or the Address is not valid."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verified: Option<bool>,
    #[doc = "The additional number and street address of the address."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub street_secondary: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountAddress {
    const LENGTH: usize = 16;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(city) = &self.city {
                format!("{city:?}")
            } else {
                String::new()
            },
            if let Some(customer_name) = &self.customer_name {
                format!("{customer_name:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(iso_country) = &self.iso_country {
                format!("{iso_country:?}")
            } else {
                String::new()
            },
            if let Some(postal_code) = &self.postal_code {
                format!("{postal_code:?}")
            } else {
                String::new()
            },
            if let Some(region) = &self.region {
                format!("{region:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(street) = &self.street {
                format!("{street:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(emergency_enabled) = &self.emergency_enabled {
                format!("{emergency_enabled:?}")
            } else {
                String::new()
            },
            if let Some(validated) = &self.validated {
                format!("{validated:?}")
            } else {
                String::new()
            },
            if let Some(verified) = &self.verified {
                format!("{verified:?}")
            } else {
                String::new()
            },
            if let Some(street_secondary) = &self.street_secondary {
                format!("{street_secondary:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "city".to_string(),
            "customer_name".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "friendly_name".to_string(),
            "iso_country".to_string(),
            "postal_code".to_string(),
            "region".to_string(),
            "sid".to_string(),
            "street".to_string(),
            "uri".to_string(),
            "emergency_enabled".to_string(),
            "validated".to_string(),
            "verified".to_string(),
            "street_secondary".to_string(),
        ]
    }
}

#[doc = "The HTTP method we use to call `sms_fallback_url`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum SmsFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we use to call `sms_url`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum SmsMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we use to call `status_callback`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum StatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we use to call `voice_fallback_url`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum VoiceFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we use to call `voice_url`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum VoiceMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountApplication {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the Application resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to start a new TwiML session."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The string that you assigned to describe the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The URL we call using a POST method to send message status information to your \
             application."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message_status_callback: Option<String>,
    #[doc = "The unique string that that we created to identify the Application resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The HTTP method we use to call `sms_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_fallback_method: Option<SmsFallbackMethod>,
    #[doc = "The URL that we call when an error occurs while retrieving or executing the TwiML \
             from `sms_url`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_fallback_url: Option<String>,
    #[doc = "The HTTP method we use to call `sms_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_method: Option<SmsMethod>,
    #[doc = "The URL we call using a POST method to send status information to your application \
             about SMS messages that refer to the application."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_status_callback: Option<String>,
    #[doc = "The URL we call when the phone number receives an incoming SMS message."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_url: Option<String>,
    #[doc = "The URL we call using the `status_callback_method` to send status information to \
             your application."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status_callback: Option<String>,
    #[doc = "The HTTP method we use to call `status_callback`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status_callback_method: Option<StatusCallbackMethod>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "Whether we look up the caller's caller-ID name from the CNAM database (additional \
             charges apply). Can be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_caller_id_lookup: Option<bool>,
    #[doc = "The HTTP method we use to call `voice_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_fallback_method: Option<VoiceFallbackMethod>,
    #[doc = "The URL that we call when an error occurs retrieving or executing the TwiML \
             requested by `url`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_fallback_url: Option<String>,
    #[doc = "The HTTP method we use to call `voice_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_method: Option<VoiceMethod>,
    #[doc = "The URL we call when the phone number assigned to this application receives a call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_url: Option<String>,
    #[doc = "Whether to allow other Twilio accounts to dial this applicaton using Dial verb. Can \
             be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public_application_connect_enabled: Option<bool>,
}

impl std::fmt::Display for ApiV2010AccountApplication {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountApplication {
    const LENGTH: usize = 21;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(message_status_callback) = &self.message_status_callback {
                format!("{message_status_callback:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_method) = &self.sms_fallback_method {
                format!("{sms_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_url) = &self.sms_fallback_url {
                format!("{sms_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(sms_method) = &self.sms_method {
                format!("{sms_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_status_callback) = &self.sms_status_callback {
                format!("{sms_status_callback:?}")
            } else {
                String::new()
            },
            if let Some(sms_url) = &self.sms_url {
                format!("{sms_url:?}")
            } else {
                String::new()
            },
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(voice_caller_id_lookup) = &self.voice_caller_id_lookup {
                format!("{voice_caller_id_lookup:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_method) = &self.voice_fallback_method {
                format!("{voice_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_url) = &self.voice_fallback_url {
                format!("{voice_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_method) = &self.voice_method {
                format!("{voice_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_url) = &self.voice_url {
                format!("{voice_url:?}")
            } else {
                String::new()
            },
            if let Some(public_application_connect_enabled) =
                &self.public_application_connect_enabled
            {
                format!("{public_application_connect_enabled:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "friendly_name".to_string(),
            "message_status_callback".to_string(),
            "sid".to_string(),
            "sms_fallback_method".to_string(),
            "sms_fallback_url".to_string(),
            "sms_method".to_string(),
            "sms_status_callback".to_string(),
            "sms_url".to_string(),
            "status_callback".to_string(),
            "status_callback_method".to_string(),
            "uri".to_string(),
            "voice_caller_id_lookup".to_string(),
            "voice_fallback_method".to_string(),
            "voice_fallback_url".to_string(),
            "voice_method".to_string(),
            "voice_url".to_string(),
            "public_application_connect_enabled".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountAuthorizedConnectApp {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the AuthorizedConnectApp resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The company name set for the Connect App."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub connect_app_company_name: Option<String>,
    #[doc = "A detailed description of the Connect App."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub connect_app_description: Option<String>,
    #[doc = "The name of the Connect App."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub connect_app_friendly_name: Option<String>,
    #[doc = "The public URL for the Connect App."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub connect_app_homepage_url: Option<String>,
    #[doc = "The SID that we assigned to the Connect App."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub connect_app_sid: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The set of permissions that you authorized for the Connect App.  Can be: `get-all` \
             or `post-all`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<Vec<AuthorizedConnectAppEnumPermission>>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountAuthorizedConnectApp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountAuthorizedConnectApp {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(connect_app_company_name) = &self.connect_app_company_name {
                format!("{connect_app_company_name:?}")
            } else {
                String::new()
            },
            if let Some(connect_app_description) = &self.connect_app_description {
                format!("{connect_app_description:?}")
            } else {
                String::new()
            },
            if let Some(connect_app_friendly_name) = &self.connect_app_friendly_name {
                format!("{connect_app_friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(connect_app_homepage_url) = &self.connect_app_homepage_url {
                format!("{connect_app_homepage_url:?}")
            } else {
                String::new()
            },
            if let Some(connect_app_sid) = &self.connect_app_sid {
                format!("{connect_app_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(permissions) = &self.permissions {
                format!("{permissions:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "connect_app_company_name".to_string(),
            "connect_app_description".to_string(),
            "connect_app_friendly_name".to_string(),
            "connect_app_homepage_url".to_string(),
            "connect_app_sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "permissions".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum AuthorizedConnectAppEnumPermission {
    #[serde(rename = "get-all")]
    #[display("get-all")]
    GetAll,
    #[serde(rename = "post-all")]
    #[display("post-all")]
    PostAll,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountAvailablePhoneNumberCountry {
    #[doc = "The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of \
             the country."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub country_code: Option<String>,
    #[doc = "The name of the country."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub country: Option<String>,
    #[doc = "The URI of the Country resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "Whether all phone numbers available in the country are new to the Twilio platform. \
             `true` if they are and `false` if all numbers are not in the Twilio Phone Number \
             Beta program."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub beta: Option<bool>,
    #[doc = "A list of related AvailablePhoneNumber resources identified by their URIs relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
}

impl std::fmt::Display for ApiV2010AccountAvailablePhoneNumberCountry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountAvailablePhoneNumberCountry {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(country_code) = &self.country_code {
                format!("{country_code:?}")
            } else {
                String::new()
            },
            if let Some(country) = &self.country {
                format!("{country:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(beta) = &self.beta {
                format!("{beta:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "country_code".to_string(),
            "country".to_string(),
            "uri".to_string(),
            "beta".to_string(),
            "subresource_uris".to_string(),
        ]
    }
}

#[doc = "The set of Boolean properties that indicate whether a phone number can receive calls or \
         messages.  Capabilities are: `Voice`, `SMS`, and `MMS` and each capability can be: `true` \
         or `false`."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct Capabilities {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mms: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fax: Option<bool>,
}

impl std::fmt::Display for Capabilities {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for Capabilities {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(mms) = &self.mms {
                format!("{mms:?}")
            } else {
                String::new()
            },
            if let Some(sms) = &self.sms {
                format!("{sms:?}")
            } else {
                String::new()
            },
            if let Some(voice) = &self.voice {
                format!("{voice:?}")
            } else {
                String::new()
            },
            if let Some(fax) = &self.fax {
                format!("{fax:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "mms".to_string(),
            "sms".to_string(),
            "voice".to_string(),
            "fax".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberLocal {
    #[doc = "A formatted version of the phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: phone_number::PhoneNumber,
    #[doc = "The phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, \
             which consists of a + followed by the country code and subscriber number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone_number: phone_number::PhoneNumber,
    #[doc = "The [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) of this \
             phone number. Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lata: Option<String>,
    #[doc = "The locality or city of this phone number's location."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locality: Option<String>,
    #[doc = "The [rate center](https://en.wikipedia.org/wiki/Telephone_exchange) of this phone \
             number. Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rate_center: Option<String>,
    #[doc = "The latitude of this phone number's location. Available for only phone numbers from \
             the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub latitude: Option<f64>,
    #[doc = "The longitude of this phone number's location. Available for only phone numbers from \
             the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub longitude: Option<f64>,
    #[doc = "The two-letter state or province abbreviation of this phone number's location. \
             Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[doc = "The postal or ZIP code of this phone number's location. Available for only phone \
             numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postal_code: Option<String>,
    #[doc = "The [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of this \
             phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iso_country: Option<String>,
    #[doc = "The type of [Address](https://www.twilio.com/docs/usage/api/address) resource the \
             phone number requires. Can be: `none`, `any`, `local`, or `foreign`. `none` means no \
             address is required. `any` means an address is required, but it can be anywhere in \
             the world. `local` means an address in the phone number's country is required. \
             `foreign` means an address outside of the phone number's country is required."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address_requirements: Option<String>,
    #[doc = "Whether the phone number is new to the Twilio platform. Can be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub beta: Option<bool>,
    #[doc = "The set of Boolean properties that indicate whether a phone number can receive calls \
             or messages.  Capabilities are: `Voice`, `SMS`, and `MMS` and each capability can \
             be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<Capabilities>,
}

impl std::fmt::Display for ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberLocal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberLocal {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.friendly_name),
            format!("{:?}", self.phone_number),
            if let Some(lata) = &self.lata {
                format!("{lata:?}")
            } else {
                String::new()
            },
            if let Some(locality) = &self.locality {
                format!("{locality:?}")
            } else {
                String::new()
            },
            if let Some(rate_center) = &self.rate_center {
                format!("{rate_center:?}")
            } else {
                String::new()
            },
            if let Some(latitude) = &self.latitude {
                format!("{latitude:?}")
            } else {
                String::new()
            },
            if let Some(longitude) = &self.longitude {
                format!("{longitude:?}")
            } else {
                String::new()
            },
            if let Some(region) = &self.region {
                format!("{region:?}")
            } else {
                String::new()
            },
            if let Some(postal_code) = &self.postal_code {
                format!("{postal_code:?}")
            } else {
                String::new()
            },
            if let Some(iso_country) = &self.iso_country {
                format!("{iso_country:?}")
            } else {
                String::new()
            },
            if let Some(address_requirements) = &self.address_requirements {
                format!("{address_requirements:?}")
            } else {
                String::new()
            },
            if let Some(beta) = &self.beta {
                format!("{beta:?}")
            } else {
                String::new()
            },
            if let Some(capabilities) = &self.capabilities {
                format!("{capabilities:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "friendly_name".to_string(),
            "phone_number".to_string(),
            "lata".to_string(),
            "locality".to_string(),
            "rate_center".to_string(),
            "latitude".to_string(),
            "longitude".to_string(),
            "region".to_string(),
            "postal_code".to_string(),
            "iso_country".to_string(),
            "address_requirements".to_string(),
            "beta".to_string(),
            "capabilities".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberMachineToMachine {
    #[doc = "A formatted version of the phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: phone_number::PhoneNumber,
    #[doc = "The phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, \
             which consists of a + followed by the country code and subscriber number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone_number: phone_number::PhoneNumber,
    #[doc = "The [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) of this \
             phone number. Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lata: Option<String>,
    #[doc = "The locality or city of this phone number's location."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locality: Option<String>,
    #[doc = "The [rate center](https://en.wikipedia.org/wiki/Telephone_exchange) of this phone \
             number. Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rate_center: Option<String>,
    #[doc = "The latitude of this phone number's location. Available for only phone numbers from \
             the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub latitude: Option<f64>,
    #[doc = "The longitude of this phone number's location. Available for only phone numbers from \
             the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub longitude: Option<f64>,
    #[doc = "The two-letter state or province abbreviation of this phone number's location. \
             Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[doc = "The postal or ZIP code of this phone number's location. Available for only phone \
             numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postal_code: Option<String>,
    #[doc = "The [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of this \
             phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iso_country: Option<String>,
    #[doc = "The type of [Address](https://www.twilio.com/docs/usage/api/address) resource the \
             phone number requires. Can be: `none`, `any`, `local`, or `foreign`. `none` means no \
             address is required. `any` means an address is required, but it can be anywhere in \
             the world. `local` means an address in the phone number's country is required. \
             `foreign` means an address outside of the phone number's country is required."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address_requirements: Option<String>,
    #[doc = "Whether the phone number is new to the Twilio platform. Can be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub beta: Option<bool>,
    #[doc = "The set of Boolean properties that indicate whether a phone number can receive calls \
             or messages.  Capabilities are: `Voice`, `SMS`, and `MMS` and each capability can \
             be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<Capabilities>,
}

impl std::fmt::Display
    for ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberMachineToMachine
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled
    for ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberMachineToMachine
{
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.friendly_name),
            format!("{:?}", self.phone_number),
            if let Some(lata) = &self.lata {
                format!("{lata:?}")
            } else {
                String::new()
            },
            if let Some(locality) = &self.locality {
                format!("{locality:?}")
            } else {
                String::new()
            },
            if let Some(rate_center) = &self.rate_center {
                format!("{rate_center:?}")
            } else {
                String::new()
            },
            if let Some(latitude) = &self.latitude {
                format!("{latitude:?}")
            } else {
                String::new()
            },
            if let Some(longitude) = &self.longitude {
                format!("{longitude:?}")
            } else {
                String::new()
            },
            if let Some(region) = &self.region {
                format!("{region:?}")
            } else {
                String::new()
            },
            if let Some(postal_code) = &self.postal_code {
                format!("{postal_code:?}")
            } else {
                String::new()
            },
            if let Some(iso_country) = &self.iso_country {
                format!("{iso_country:?}")
            } else {
                String::new()
            },
            if let Some(address_requirements) = &self.address_requirements {
                format!("{address_requirements:?}")
            } else {
                String::new()
            },
            if let Some(beta) = &self.beta {
                format!("{beta:?}")
            } else {
                String::new()
            },
            if let Some(capabilities) = &self.capabilities {
                format!("{capabilities:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "friendly_name".to_string(),
            "phone_number".to_string(),
            "lata".to_string(),
            "locality".to_string(),
            "rate_center".to_string(),
            "latitude".to_string(),
            "longitude".to_string(),
            "region".to_string(),
            "postal_code".to_string(),
            "iso_country".to_string(),
            "address_requirements".to_string(),
            "beta".to_string(),
            "capabilities".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberMobile {
    #[doc = "A formatted version of the phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: phone_number::PhoneNumber,
    #[doc = "The phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, \
             which consists of a + followed by the country code and subscriber number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone_number: phone_number::PhoneNumber,
    #[doc = "The [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) of this \
             phone number. Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lata: Option<String>,
    #[doc = "The locality or city of this phone number's location."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locality: Option<String>,
    #[doc = "The [rate center](https://en.wikipedia.org/wiki/Telephone_exchange) of this phone \
             number. Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rate_center: Option<String>,
    #[doc = "The latitude of this phone number's location. Available for only phone numbers from \
             the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub latitude: Option<f64>,
    #[doc = "The longitude of this phone number's location. Available for only phone numbers from \
             the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub longitude: Option<f64>,
    #[doc = "The two-letter state or province abbreviation of this phone number's location. \
             Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[doc = "The postal or ZIP code of this phone number's location. Available for only phone \
             numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postal_code: Option<String>,
    #[doc = "The [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of this \
             phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iso_country: Option<String>,
    #[doc = "The type of [Address](https://www.twilio.com/docs/usage/api/address) resource the \
             phone number requires. Can be: `none`, `any`, `local`, or `foreign`. `none` means no \
             address is required. `any` means an address is required, but it can be anywhere in \
             the world. `local` means an address in the phone number's country is required. \
             `foreign` means an address outside of the phone number's country is required."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address_requirements: Option<String>,
    #[doc = "Whether the phone number is new to the Twilio platform. Can be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub beta: Option<bool>,
    #[doc = "The set of Boolean properties that indicate whether a phone number can receive calls \
             or messages.  Capabilities are: `Voice`, `SMS`, and `MMS` and each capability can \
             be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<Capabilities>,
}

impl std::fmt::Display for ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberMobile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberMobile {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.friendly_name),
            format!("{:?}", self.phone_number),
            if let Some(lata) = &self.lata {
                format!("{lata:?}")
            } else {
                String::new()
            },
            if let Some(locality) = &self.locality {
                format!("{locality:?}")
            } else {
                String::new()
            },
            if let Some(rate_center) = &self.rate_center {
                format!("{rate_center:?}")
            } else {
                String::new()
            },
            if let Some(latitude) = &self.latitude {
                format!("{latitude:?}")
            } else {
                String::new()
            },
            if let Some(longitude) = &self.longitude {
                format!("{longitude:?}")
            } else {
                String::new()
            },
            if let Some(region) = &self.region {
                format!("{region:?}")
            } else {
                String::new()
            },
            if let Some(postal_code) = &self.postal_code {
                format!("{postal_code:?}")
            } else {
                String::new()
            },
            if let Some(iso_country) = &self.iso_country {
                format!("{iso_country:?}")
            } else {
                String::new()
            },
            if let Some(address_requirements) = &self.address_requirements {
                format!("{address_requirements:?}")
            } else {
                String::new()
            },
            if let Some(beta) = &self.beta {
                format!("{beta:?}")
            } else {
                String::new()
            },
            if let Some(capabilities) = &self.capabilities {
                format!("{capabilities:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "friendly_name".to_string(),
            "phone_number".to_string(),
            "lata".to_string(),
            "locality".to_string(),
            "rate_center".to_string(),
            "latitude".to_string(),
            "longitude".to_string(),
            "region".to_string(),
            "postal_code".to_string(),
            "iso_country".to_string(),
            "address_requirements".to_string(),
            "beta".to_string(),
            "capabilities".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberNational {
    #[doc = "A formatted version of the phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: phone_number::PhoneNumber,
    #[doc = "The phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, \
             which consists of a + followed by the country code and subscriber number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone_number: phone_number::PhoneNumber,
    #[doc = "The [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) of this \
             phone number. Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lata: Option<String>,
    #[doc = "The locality or city of this phone number's location."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locality: Option<String>,
    #[doc = "The [rate center](https://en.wikipedia.org/wiki/Telephone_exchange) of this phone \
             number. Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rate_center: Option<String>,
    #[doc = "The latitude of this phone number's location. Available for only phone numbers from \
             the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub latitude: Option<f64>,
    #[doc = "The longitude of this phone number's location. Available for only phone numbers from \
             the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub longitude: Option<f64>,
    #[doc = "The two-letter state or province abbreviation of this phone number's location. \
             Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[doc = "The postal or ZIP code of this phone number's location. Available for only phone \
             numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postal_code: Option<String>,
    #[doc = "The [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of this \
             phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iso_country: Option<String>,
    #[doc = "The type of [Address](https://www.twilio.com/docs/usage/api/address) resource the \
             phone number requires. Can be: `none`, `any`, `local`, or `foreign`. `none` means no \
             address is required. `any` means an address is required, but it can be anywhere in \
             the world. `local` means an address in the phone number's country is required. \
             `foreign` means an address outside of the phone number's country is required."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address_requirements: Option<String>,
    #[doc = "Whether the phone number is new to the Twilio platform. Can be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub beta: Option<bool>,
    #[doc = "The set of Boolean properties that indicate whether a phone number can receive calls \
             or messages.  Capabilities are: `Voice`, `SMS`, and `MMS` and each capability can \
             be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<Capabilities>,
}

impl std::fmt::Display for ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberNational {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberNational {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.friendly_name),
            format!("{:?}", self.phone_number),
            if let Some(lata) = &self.lata {
                format!("{lata:?}")
            } else {
                String::new()
            },
            if let Some(locality) = &self.locality {
                format!("{locality:?}")
            } else {
                String::new()
            },
            if let Some(rate_center) = &self.rate_center {
                format!("{rate_center:?}")
            } else {
                String::new()
            },
            if let Some(latitude) = &self.latitude {
                format!("{latitude:?}")
            } else {
                String::new()
            },
            if let Some(longitude) = &self.longitude {
                format!("{longitude:?}")
            } else {
                String::new()
            },
            if let Some(region) = &self.region {
                format!("{region:?}")
            } else {
                String::new()
            },
            if let Some(postal_code) = &self.postal_code {
                format!("{postal_code:?}")
            } else {
                String::new()
            },
            if let Some(iso_country) = &self.iso_country {
                format!("{iso_country:?}")
            } else {
                String::new()
            },
            if let Some(address_requirements) = &self.address_requirements {
                format!("{address_requirements:?}")
            } else {
                String::new()
            },
            if let Some(beta) = &self.beta {
                format!("{beta:?}")
            } else {
                String::new()
            },
            if let Some(capabilities) = &self.capabilities {
                format!("{capabilities:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "friendly_name".to_string(),
            "phone_number".to_string(),
            "lata".to_string(),
            "locality".to_string(),
            "rate_center".to_string(),
            "latitude".to_string(),
            "longitude".to_string(),
            "region".to_string(),
            "postal_code".to_string(),
            "iso_country".to_string(),
            "address_requirements".to_string(),
            "beta".to_string(),
            "capabilities".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberSharedCost {
    #[doc = "A formatted version of the phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: phone_number::PhoneNumber,
    #[doc = "The phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, \
             which consists of a + followed by the country code and subscriber number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone_number: phone_number::PhoneNumber,
    #[doc = "The [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) of this \
             phone number. Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lata: Option<String>,
    #[doc = "The locality or city of this phone number's location."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locality: Option<String>,
    #[doc = "The [rate center](https://en.wikipedia.org/wiki/Telephone_exchange) of this phone \
             number. Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rate_center: Option<String>,
    #[doc = "The latitude of this phone number's location. Available for only phone numbers from \
             the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub latitude: Option<f64>,
    #[doc = "The longitude of this phone number's location. Available for only phone numbers from \
             the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub longitude: Option<f64>,
    #[doc = "The two-letter state or province abbreviation of this phone number's location. \
             Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[doc = "The postal or ZIP code of this phone number's location. Available for only phone \
             numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postal_code: Option<String>,
    #[doc = "The [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of this \
             phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iso_country: Option<String>,
    #[doc = "The type of [Address](https://www.twilio.com/docs/usage/api/address) resource the \
             phone number requires. Can be: `none`, `any`, `local`, or `foreign`. `none` means no \
             address is required. `any` means an address is required, but it can be anywhere in \
             the world. `local` means an address in the phone number's country is required. \
             `foreign` means an address outside of the phone number's country is required."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address_requirements: Option<String>,
    #[doc = "Whether the phone number is new to the Twilio platform. Can be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub beta: Option<bool>,
    #[doc = "The set of Boolean properties that indicate whether a phone number can receive calls \
             or messages.  Capabilities are: `Voice`, `SMS`, and `MMS` and each capability can \
             be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<Capabilities>,
}

impl std::fmt::Display
    for ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberSharedCost
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberSharedCost {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.friendly_name),
            format!("{:?}", self.phone_number),
            if let Some(lata) = &self.lata {
                format!("{lata:?}")
            } else {
                String::new()
            },
            if let Some(locality) = &self.locality {
                format!("{locality:?}")
            } else {
                String::new()
            },
            if let Some(rate_center) = &self.rate_center {
                format!("{rate_center:?}")
            } else {
                String::new()
            },
            if let Some(latitude) = &self.latitude {
                format!("{latitude:?}")
            } else {
                String::new()
            },
            if let Some(longitude) = &self.longitude {
                format!("{longitude:?}")
            } else {
                String::new()
            },
            if let Some(region) = &self.region {
                format!("{region:?}")
            } else {
                String::new()
            },
            if let Some(postal_code) = &self.postal_code {
                format!("{postal_code:?}")
            } else {
                String::new()
            },
            if let Some(iso_country) = &self.iso_country {
                format!("{iso_country:?}")
            } else {
                String::new()
            },
            if let Some(address_requirements) = &self.address_requirements {
                format!("{address_requirements:?}")
            } else {
                String::new()
            },
            if let Some(beta) = &self.beta {
                format!("{beta:?}")
            } else {
                String::new()
            },
            if let Some(capabilities) = &self.capabilities {
                format!("{capabilities:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "friendly_name".to_string(),
            "phone_number".to_string(),
            "lata".to_string(),
            "locality".to_string(),
            "rate_center".to_string(),
            "latitude".to_string(),
            "longitude".to_string(),
            "region".to_string(),
            "postal_code".to_string(),
            "iso_country".to_string(),
            "address_requirements".to_string(),
            "beta".to_string(),
            "capabilities".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberTollFree {
    #[doc = "A formatted version of the phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: phone_number::PhoneNumber,
    #[doc = "The phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, \
             which consists of a + followed by the country code and subscriber number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone_number: phone_number::PhoneNumber,
    #[doc = "The [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) of this \
             phone number. Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lata: Option<String>,
    #[doc = "The locality or city of this phone number's location."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locality: Option<String>,
    #[doc = "The [rate center](https://en.wikipedia.org/wiki/Telephone_exchange) of this phone \
             number. Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rate_center: Option<String>,
    #[doc = "The latitude of this phone number's location. Available for only phone numbers from \
             the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub latitude: Option<f64>,
    #[doc = "The longitude of this phone number's location. Available for only phone numbers from \
             the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub longitude: Option<f64>,
    #[doc = "The two-letter state or province abbreviation of this phone number's location. \
             Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[doc = "The postal or ZIP code of this phone number's location. Available for only phone \
             numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postal_code: Option<String>,
    #[doc = "The [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of this \
             phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iso_country: Option<String>,
    #[doc = "The type of [Address](https://www.twilio.com/docs/usage/api/address) resource the \
             phone number requires. Can be: `none`, `any`, `local`, or `foreign`. `none` means no \
             address is required. `any` means an address is required, but it can be anywhere in \
             the world. `local` means an address in the phone number's country is required. \
             `foreign` means an address outside of the phone number's country is required."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address_requirements: Option<String>,
    #[doc = "Whether the phone number is new to the Twilio platform. Can be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub beta: Option<bool>,
    #[doc = "The set of Boolean properties that indicate whether a phone number can receive calls \
             or messages.  Capabilities are: `Voice`, `SMS`, and `MMS` and each capability can \
             be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<Capabilities>,
}

impl std::fmt::Display for ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberTollFree {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberTollFree {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.friendly_name),
            format!("{:?}", self.phone_number),
            if let Some(lata) = &self.lata {
                format!("{lata:?}")
            } else {
                String::new()
            },
            if let Some(locality) = &self.locality {
                format!("{locality:?}")
            } else {
                String::new()
            },
            if let Some(rate_center) = &self.rate_center {
                format!("{rate_center:?}")
            } else {
                String::new()
            },
            if let Some(latitude) = &self.latitude {
                format!("{latitude:?}")
            } else {
                String::new()
            },
            if let Some(longitude) = &self.longitude {
                format!("{longitude:?}")
            } else {
                String::new()
            },
            if let Some(region) = &self.region {
                format!("{region:?}")
            } else {
                String::new()
            },
            if let Some(postal_code) = &self.postal_code {
                format!("{postal_code:?}")
            } else {
                String::new()
            },
            if let Some(iso_country) = &self.iso_country {
                format!("{iso_country:?}")
            } else {
                String::new()
            },
            if let Some(address_requirements) = &self.address_requirements {
                format!("{address_requirements:?}")
            } else {
                String::new()
            },
            if let Some(beta) = &self.beta {
                format!("{beta:?}")
            } else {
                String::new()
            },
            if let Some(capabilities) = &self.capabilities {
                format!("{capabilities:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "friendly_name".to_string(),
            "phone_number".to_string(),
            "lata".to_string(),
            "locality".to_string(),
            "rate_center".to_string(),
            "latitude".to_string(),
            "longitude".to_string(),
            "region".to_string(),
            "postal_code".to_string(),
            "iso_country".to_string(),
            "address_requirements".to_string(),
            "beta".to_string(),
            "capabilities".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberVoip {
    #[doc = "A formatted version of the phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: phone_number::PhoneNumber,
    #[doc = "The phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, \
             which consists of a + followed by the country code and subscriber number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone_number: phone_number::PhoneNumber,
    #[doc = "The [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) of this \
             phone number. Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lata: Option<String>,
    #[doc = "The locality or city of this phone number's location."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locality: Option<String>,
    #[doc = "The [rate center](https://en.wikipedia.org/wiki/Telephone_exchange) of this phone \
             number. Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rate_center: Option<String>,
    #[doc = "The latitude of this phone number's location. Available for only phone numbers from \
             the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub latitude: Option<f64>,
    #[doc = "The longitude of this phone number's location. Available for only phone numbers from \
             the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub longitude: Option<f64>,
    #[doc = "The two-letter state or province abbreviation of this phone number's location. \
             Available for only phone numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[doc = "The postal or ZIP code of this phone number's location. Available for only phone \
             numbers from the US and Canada."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postal_code: Option<String>,
    #[doc = "The [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of this \
             phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iso_country: Option<String>,
    #[doc = "The type of [Address](https://www.twilio.com/docs/usage/api/address) resource the \
             phone number requires. Can be: `none`, `any`, `local`, or `foreign`. `none` means no \
             address is required. `any` means an address is required, but it can be anywhere in \
             the world. `local` means an address in the phone number's country is required. \
             `foreign` means an address outside of the phone number's country is required."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address_requirements: Option<String>,
    #[doc = "Whether the phone number is new to the Twilio platform. Can be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub beta: Option<bool>,
    #[doc = "The set of Boolean properties that indicate whether a phone number can receive calls \
             or messages.  Capabilities are: `Voice`, `SMS`, and `MMS` and each capability can \
             be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<Capabilities>,
}

impl std::fmt::Display for ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberVoip {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberVoip {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.friendly_name),
            format!("{:?}", self.phone_number),
            if let Some(lata) = &self.lata {
                format!("{lata:?}")
            } else {
                String::new()
            },
            if let Some(locality) = &self.locality {
                format!("{locality:?}")
            } else {
                String::new()
            },
            if let Some(rate_center) = &self.rate_center {
                format!("{rate_center:?}")
            } else {
                String::new()
            },
            if let Some(latitude) = &self.latitude {
                format!("{latitude:?}")
            } else {
                String::new()
            },
            if let Some(longitude) = &self.longitude {
                format!("{longitude:?}")
            } else {
                String::new()
            },
            if let Some(region) = &self.region {
                format!("{region:?}")
            } else {
                String::new()
            },
            if let Some(postal_code) = &self.postal_code {
                format!("{postal_code:?}")
            } else {
                String::new()
            },
            if let Some(iso_country) = &self.iso_country {
                format!("{iso_country:?}")
            } else {
                String::new()
            },
            if let Some(address_requirements) = &self.address_requirements {
                format!("{address_requirements:?}")
            } else {
                String::new()
            },
            if let Some(beta) = &self.beta {
                format!("{beta:?}")
            } else {
                String::new()
            },
            if let Some(capabilities) = &self.capabilities {
                format!("{capabilities:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "friendly_name".to_string(),
            "phone_number".to_string(),
            "lata".to_string(),
            "locality".to_string(),
            "rate_center".to_string(),
            "latitude".to_string(),
            "longitude".to_string(),
            "region".to_string(),
            "postal_code".to_string(),
            "iso_country".to_string(),
            "address_requirements".to_string(),
            "beta".to_string(),
            "capabilities".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountBalance {
    #[doc = "The unique SID identifier of the Account."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The balance of the Account, in units specified by the unit parameter. Balance \
             changes may not be reflected immediately. Child accounts do not contain balance \
             information"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub balance: Option<String>,
    #[doc = "The units of currency for the account balance"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub currency: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountBalance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountBalance {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(balance) = &self.balance {
                format!("{balance:?}")
            } else {
                String::new()
            },
            if let Some(currency) = &self.currency {
                format!("{currency:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "balance".to_string(),
            "currency".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountCall {
    #[doc = "The unique string that we created to identify this Call resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The date and time in GMT that this resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that this resource was last updated, specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The SID that identifies the call that created this leg."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent_call_sid: Option<String>,
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             this Call resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The phone number, SIP address, Client identifier or SIM SID that received this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). SIP addresses are formatted as `name@company.com`. Client identifiers are formatted `client:name`. SIM SIDs are formatted as `sim:sid`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<String>,
    #[doc = "The phone number, SIP address or Client identifier that received this call. Formatted for display. Non-North American phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +442071838750)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to_formatted: Option<String>,
    #[doc = "The phone number, SIP address, Client identifier or SIM SID that made this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). SIP addresses are formatted as `name@company.com`. Client identifiers are formatted `client:name`. SIM SIDs are formatted as `sim:sid`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    #[doc = "The calling phone number, SIP address, or Client identifier formatted for display. Non-North American phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +442071838750)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from_formatted: Option<String>,
    #[doc = "If the call was inbound, this is the SID of the IncomingPhoneNumber resource that \
             received the call. If the call was outbound, it is the SID of the OutgoingCallerId \
             resource from which the call was placed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone_number_sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<CallEnumStatus>,
    #[doc = "The start time of the call, given as GMT in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format. Empty if the call has not yet been dialed."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub start_time: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The time the call ended, given as GMT in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format. Empty if the call did not complete successfully."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub end_time: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The length of the call in seconds. This value is empty for busy, failed, unanswered, \
             or ongoing calls."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    #[doc = "The charge for this call, in the currency associated with the account. Populated \
             after the call is completed. May not be immediately available."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    #[doc = "The currency in which `Price` is measured, in [ISO 4127](https://www.iso.org/iso/home/standards/currency_codes.htm) format (e.g., `USD`, `EUR`, `JPY`). Always capitalized for calls."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price_unit: Option<String>,
    #[doc = "A string describing the direction of the call. Can be: `inbound` for inbound calls, `outbound-api` for calls initiated via the REST API or `outbound-dial` for calls initiated by a `<Dial>` verb. Using [Elastic SIP Trunking](https://www.twilio.com/docs/sip-trunking), the values can be [`trunking-terminating`](https://www.twilio.com/docs/sip-trunking#termination) for outgoing calls from your communications infrastructure to the PSTN or [`trunking-originating`](https://www.twilio.com/docs/sip-trunking#origination) for incoming calls to your communications infrastructure from the PSTN."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub direction: Option<String>,
    #[doc = "Either `human` or `machine` if this call was initiated with answering machine \
             detection. Empty otherwise."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub answered_by: Option<String>,
    #[doc = "The API version used to create the call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "The forwarding phone number if this call was an incoming call forwarded from another \
             number (depends on carrier supporting forwarding). Otherwise, empty."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub forwarded_from: Option<String>,
    #[doc = "The Group SID associated with this call. If no Group is associated with the call, \
             the field is empty."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group_sid: Option<String>,
    #[doc = "The caller's name if this call was an incoming call to a phone number with caller ID \
             Lookup enabled. Otherwise, empty."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub caller_name: Option<String>,
    #[doc = "The wait time in milliseconds before the call is placed."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub queue_time: Option<String>,
    #[doc = "The unique identifier of the trunk resource that was used for this call. The field \
             is empty if the call was not made using a SIP trunk or if the call is not terminated."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub trunk_sid: Option<String>,
    #[doc = "The URI of this resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "A list of subresources available to this call, identified by their URIs relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
}

impl std::fmt::Display for ApiV2010AccountCall {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountCall {
    const LENGTH: usize = 26;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(parent_call_sid) = &self.parent_call_sid {
                format!("{parent_call_sid:?}")
            } else {
                String::new()
            },
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(to) = &self.to {
                format!("{to:?}")
            } else {
                String::new()
            },
            if let Some(to_formatted) = &self.to_formatted {
                format!("{to_formatted:?}")
            } else {
                String::new()
            },
            if let Some(from) = &self.from {
                format!("{from:?}")
            } else {
                String::new()
            },
            if let Some(from_formatted) = &self.from_formatted {
                format!("{from_formatted:?}")
            } else {
                String::new()
            },
            if let Some(phone_number_sid) = &self.phone_number_sid {
                format!("{phone_number_sid:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
            if let Some(start_time) = &self.start_time {
                format!("{start_time:?}")
            } else {
                String::new()
            },
            if let Some(end_time) = &self.end_time {
                format!("{end_time:?}")
            } else {
                String::new()
            },
            if let Some(duration) = &self.duration {
                format!("{duration:?}")
            } else {
                String::new()
            },
            if let Some(price) = &self.price {
                format!("{price:?}")
            } else {
                String::new()
            },
            if let Some(price_unit) = &self.price_unit {
                format!("{price_unit:?}")
            } else {
                String::new()
            },
            if let Some(direction) = &self.direction {
                format!("{direction:?}")
            } else {
                String::new()
            },
            if let Some(answered_by) = &self.answered_by {
                format!("{answered_by:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(forwarded_from) = &self.forwarded_from {
                format!("{forwarded_from:?}")
            } else {
                String::new()
            },
            if let Some(group_sid) = &self.group_sid {
                format!("{group_sid:?}")
            } else {
                String::new()
            },
            if let Some(caller_name) = &self.caller_name {
                format!("{caller_name:?}")
            } else {
                String::new()
            },
            if let Some(queue_time) = &self.queue_time {
                format!("{queue_time:?}")
            } else {
                String::new()
            },
            if let Some(trunk_sid) = &self.trunk_sid {
                format!("{trunk_sid:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "parent_call_sid".to_string(),
            "account_sid".to_string(),
            "to".to_string(),
            "to_formatted".to_string(),
            "from".to_string(),
            "from_formatted".to_string(),
            "phone_number_sid".to_string(),
            "status".to_string(),
            "start_time".to_string(),
            "end_time".to_string(),
            "duration".to_string(),
            "price".to_string(),
            "price_unit".to_string(),
            "direction".to_string(),
            "answered_by".to_string(),
            "api_version".to_string(),
            "forwarded_from".to_string(),
            "group_sid".to_string(),
            "caller_name".to_string(),
            "queue_time".to_string(),
            "trunk_sid".to_string(),
            "uri".to_string(),
            "subresource_uris".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CallEnumEvent {
    #[serde(rename = "initiated")]
    #[display("initiated")]
    Initiated,
    #[serde(rename = "ringing")]
    #[display("ringing")]
    Ringing,
    #[serde(rename = "answered")]
    #[display("answered")]
    Answered,
    #[serde(rename = "completed")]
    #[display("completed")]
    Completed,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CallEnumStatus {
    #[serde(rename = "queued")]
    #[display("queued")]
    Queued,
    #[serde(rename = "ringing")]
    #[display("ringing")]
    Ringing,
    #[serde(rename = "in-progress")]
    #[display("in-progress")]
    InProgress,
    #[serde(rename = "completed")]
    #[display("completed")]
    Completed,
    #[serde(rename = "busy")]
    #[display("busy")]
    Busy,
    #[serde(rename = "failed")]
    #[display("failed")]
    Failed,
    #[serde(rename = "no-answer")]
    #[display("no-answer")]
    NoAnswer,
    #[serde(rename = "canceled")]
    #[display("canceled")]
    Canceled,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CallEnumUpdateStatus {
    #[serde(rename = "canceled")]
    #[display("canceled")]
    Canceled,
    #[serde(rename = "completed")]
    #[display("completed")]
    Completed,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountCallCallEvent {
    #[doc = "Contains a dictionary representing the request of the call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<serde_json::Value>,
    #[doc = "Contains a dictionary representing the call response, including a list of the call \
             events."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<serde_json::Value>,
}

impl std::fmt::Display for ApiV2010AccountCallCallEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountCallCallEvent {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(request) = &self.request {
                format!("{request:?}")
            } else {
                String::new()
            },
            if let Some(response) = &self.response {
                format!("{response:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec!["request".to_string(), "response".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountCallCallFeedback {
    #[doc = "The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) \
             responsible for this resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The date that this resource was created, given in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date that this resource was last updated, given in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "A list of issues experienced during the call. The issues can be: `imperfect-audio`, \
             `dropped-call`, `incorrect-caller-id`, `post-dial-delay`, `digits-not-captured`, \
             `audio-latency`, `unsolicited-call`, or `one-way-audio`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issues: Option<Vec<CallFeedbackEnumIssues>>,
    #[doc = "`1` to `5` quality score where `1` represents imperfect experience and `5` \
             represents a perfect call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quality_score: Option<i64>,
    #[doc = "A 34 character string that uniquely identifies this resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountCallCallFeedback {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountCallCallFeedback {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(issues) = &self.issues {
                format!("{issues:?}")
            } else {
                String::new()
            },
            if let Some(quality_score) = &self.quality_score {
                format!("{quality_score:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "issues".to_string(),
            "quality_score".to_string(),
            "sid".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CallFeedbackEnumIssues {
    #[serde(rename = "audio-latency")]
    #[display("audio-latency")]
    AudioLatency,
    #[serde(rename = "digits-not-captured")]
    #[display("digits-not-captured")]
    DigitsNotCaptured,
    #[serde(rename = "dropped-call")]
    #[display("dropped-call")]
    DroppedCall,
    #[serde(rename = "imperfect-audio")]
    #[display("imperfect-audio")]
    ImperfectAudio,
    #[serde(rename = "incorrect-caller-id")]
    #[display("incorrect-caller-id")]
    IncorrectCallerId,
    #[serde(rename = "one-way-audio")]
    #[display("one-way-audio")]
    OneWayAudio,
    #[serde(rename = "post-dial-delay")]
    #[display("post-dial-delay")]
    PostDialDelay,
    #[serde(rename = "unsolicited-call")]
    #[display("unsolicited-call")]
    UnsolicitedCall,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountCallCallFeedbackSummary {
    #[doc = "The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) \
             responsible for this resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The total number of calls."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub call_count: Option<i64>,
    #[doc = "The total number of calls with a feedback entry."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub call_feedback_count: Option<i64>,
    #[doc = "The date that this resource was created, given in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date that this resource was last updated, given in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The last date for which feedback entries are included in this Feedback Summary, \
             formatted as `YYYY-MM-DD` and specified in UTC."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_date: Option<chrono::NaiveDate>,
    #[doc = "Whether the feedback summary includes subaccounts; `true` if it does, otherwise \
             `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub include_subaccounts: Option<bool>,
    #[doc = "A list of issues experienced during the call. The issues can be: `imperfect-audio`, \
             `dropped-call`, `incorrect-caller-id`, `post-dial-delay`, `digits-not-captured`, \
             `audio-latency`, or `one-way-audio`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issues: Option<Vec<serde_json::Value>>,
    #[doc = "The average QualityScore of the feedback entries."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quality_score_average: Option<f64>,
    #[doc = "The median QualityScore of the feedback entries."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quality_score_median: Option<f64>,
    #[doc = "The standard deviation of the quality scores."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quality_score_standard_deviation: Option<f64>,
    #[doc = "A 34 character string that uniquely identifies this resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The first date for which feedback entries are included in this feedback summary, \
             formatted as `YYYY-MM-DD` and specified in UTC."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_date: Option<chrono::NaiveDate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<CallFeedbackSummaryEnumStatus>,
}

impl std::fmt::Display for ApiV2010AccountCallCallFeedbackSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountCallCallFeedbackSummary {
    const LENGTH: usize = 14;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(call_count) = &self.call_count {
                format!("{call_count:?}")
            } else {
                String::new()
            },
            if let Some(call_feedback_count) = &self.call_feedback_count {
                format!("{call_feedback_count:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(end_date) = &self.end_date {
                format!("{end_date:?}")
            } else {
                String::new()
            },
            if let Some(include_subaccounts) = &self.include_subaccounts {
                format!("{include_subaccounts:?}")
            } else {
                String::new()
            },
            if let Some(issues) = &self.issues {
                format!("{issues:?}")
            } else {
                String::new()
            },
            if let Some(quality_score_average) = &self.quality_score_average {
                format!("{quality_score_average:?}")
            } else {
                String::new()
            },
            if let Some(quality_score_median) = &self.quality_score_median {
                format!("{quality_score_median:?}")
            } else {
                String::new()
            },
            if let Some(quality_score_standard_deviation) = &self.quality_score_standard_deviation {
                format!("{quality_score_standard_deviation:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(start_date) = &self.start_date {
                format!("{start_date:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "call_count".to_string(),
            "call_feedback_count".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "end_date".to_string(),
            "include_subaccounts".to_string(),
            "issues".to_string(),
            "quality_score_average".to_string(),
            "quality_score_median".to_string(),
            "quality_score_standard_deviation".to_string(),
            "sid".to_string(),
            "start_date".to_string(),
            "status".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CallFeedbackSummaryEnumStatus {
    #[serde(rename = "queued")]
    #[display("queued")]
    Queued,
    #[serde(rename = "in-progress")]
    #[display("in-progress")]
    InProgress,
    #[serde(rename = "completed")]
    #[display("completed")]
    Completed,
    #[serde(rename = "failed")]
    #[display("failed")]
    Failed,
}

#[doc = "The HTTP method used to generate the notification. If the notification was generated \
         during a phone call, this is the HTTP Method used to request the resource on your server. \
         If the notification was generated by your use of our REST API, this is the HTTP method \
         used to call the resource on our servers."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum RequestMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountCallCallNotification {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the Call Notification resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to create the Call Notification resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) the Call \
             Notification resource is associated with."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub call_sid: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "A unique error code for the error condition that is described in our [Error Dictionary](https://www.twilio.com/docs/api/errors)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error_code: Option<String>,
    #[doc = "An integer log level that corresponds to the type of notification: `0` is ERROR, `1` \
             is WARNING."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub log: Option<String>,
    #[doc = "The date the notification was actually generated in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format. Message buffering can cause this value to differ from `date_created`."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub message_date: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The text of the notification."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message_text: Option<String>,
    #[doc = "The URL for more information about the error condition. This value is a page in our [Error Dictionary](https://www.twilio.com/docs/api/errors)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub more_info: Option<String>,
    #[doc = "The HTTP method used to generate the notification. If the notification was generated \
             during a phone call, this is the HTTP Method used to request the resource on your \
             server. If the notification was generated by your use of our REST API, this is the \
             HTTP method used to call the resource on our servers."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_method: Option<RequestMethod>,
    #[doc = "The URL of the resource that generated the notification. If the notification was \
             generated during a phone call, this is the URL of the resource on your server that \
             caused the notification. If the notification was generated by your use of our REST \
             API, this is the URL of the resource you called."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_url: Option<String>,
    #[doc = "The unique string that that we created to identify the Call Notification resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountCallCallNotification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountCallCallNotification {
    const LENGTH: usize = 14;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(call_sid) = &self.call_sid {
                format!("{call_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(error_code) = &self.error_code {
                format!("{error_code:?}")
            } else {
                String::new()
            },
            if let Some(log) = &self.log {
                format!("{log:?}")
            } else {
                String::new()
            },
            if let Some(message_date) = &self.message_date {
                format!("{message_date:?}")
            } else {
                String::new()
            },
            if let Some(message_text) = &self.message_text {
                format!("{message_text:?}")
            } else {
                String::new()
            },
            if let Some(more_info) = &self.more_info {
                format!("{more_info:?}")
            } else {
                String::new()
            },
            if let Some(request_method) = &self.request_method {
                format!("{request_method:?}")
            } else {
                String::new()
            },
            if let Some(request_url) = &self.request_url {
                format!("{request_url:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "call_sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "error_code".to_string(),
            "log".to_string(),
            "message_date".to_string(),
            "message_text".to_string(),
            "more_info".to_string(),
            "request_method".to_string(),
            "request_url".to_string(),
            "sid".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountCallCallNotificationInstance {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the Call Notification resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to create the Call Notification resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) the Call \
             Notification resource is associated with."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub call_sid: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "A unique error code for the error condition that is described in our [Error Dictionary](https://www.twilio.com/docs/api/errors)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error_code: Option<String>,
    #[doc = "An integer log level that corresponds to the type of notification: `0` is ERROR, `1` \
             is WARNING."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub log: Option<String>,
    #[doc = "The date the notification was actually generated in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format. Message buffering can cause this value to differ from `date_created`."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub message_date: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The text of the notification."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message_text: Option<String>,
    #[doc = "The URL for more information about the error condition. This value is a page in our [Error Dictionary](https://www.twilio.com/docs/api/errors)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub more_info: Option<String>,
    #[doc = "The HTTP method used to generate the notification. If the notification was generated \
             during a phone call, this is the HTTP Method used to request the resource on your \
             server. If the notification was generated by your use of our REST API, this is the \
             HTTP method used to call the resource on our servers."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_method: Option<RequestMethod>,
    #[doc = "The URL of the resource that generated the notification. If the notification was \
             generated during a phone call, this is the URL of the resource on your server that \
             caused the notification. If the notification was generated by your use of our REST \
             API, this is the URL of the resource you called."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_url: Option<String>,
    #[doc = "The HTTP GET or POST variables we sent to your server. However, if the notification \
             was generated by our REST API, this contains the HTTP POST or PUT variables you sent \
             to our API."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_variables: Option<String>,
    #[doc = "The HTTP body returned by your server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response_body: Option<String>,
    #[doc = "The HTTP headers returned by your server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response_headers: Option<String>,
    #[doc = "The unique string that that we created to identify the Call Notification resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountCallCallNotificationInstance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountCallCallNotificationInstance {
    const LENGTH: usize = 17;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(call_sid) = &self.call_sid {
                format!("{call_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(error_code) = &self.error_code {
                format!("{error_code:?}")
            } else {
                String::new()
            },
            if let Some(log) = &self.log {
                format!("{log:?}")
            } else {
                String::new()
            },
            if let Some(message_date) = &self.message_date {
                format!("{message_date:?}")
            } else {
                String::new()
            },
            if let Some(message_text) = &self.message_text {
                format!("{message_text:?}")
            } else {
                String::new()
            },
            if let Some(more_info) = &self.more_info {
                format!("{more_info:?}")
            } else {
                String::new()
            },
            if let Some(request_method) = &self.request_method {
                format!("{request_method:?}")
            } else {
                String::new()
            },
            if let Some(request_url) = &self.request_url {
                format!("{request_url:?}")
            } else {
                String::new()
            },
            if let Some(request_variables) = &self.request_variables {
                format!("{request_variables:?}")
            } else {
                String::new()
            },
            if let Some(response_body) = &self.response_body {
                format!("{response_body:?}")
            } else {
                String::new()
            },
            if let Some(response_headers) = &self.response_headers {
                format!("{response_headers:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "call_sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "error_code".to_string(),
            "log".to_string(),
            "message_date".to_string(),
            "message_text".to_string(),
            "more_info".to_string(),
            "request_method".to_string(),
            "request_url".to_string(),
            "request_variables".to_string(),
            "response_body".to_string(),
            "response_headers".to_string(),
            "sid".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountCallCallRecording {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the Recording resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to make the recording."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) the \
             Recording resource is associated with."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub call_sid: Option<String>,
    #[doc = "The Conference SID that identifies the conference associated with the recording, if \
             a conference recording."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conference_sid: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated, specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The start time of the recording in GMT and in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub start_time: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The length of the recording in seconds."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    #[doc = "The unique string that that we created to identify the Recording resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The one-time cost of creating the recording in the `price_unit` currency."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<f64>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "How to decrypt the recording if it was encrypted using [Call Recording Encryption](https://www.twilio.com/docs/voice/tutorials/voice-recording-encryption) feature."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encryption_details: Option<serde_json::Value>,
    #[doc = "The currency used in the `price` property. Example: `USD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price_unit: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<CallRecordingEnumStatus>,
    #[doc = "The number of channels in the final recording file.  Can be: `1`, or `2`. Separating a two leg call into two separate channels of the recording file is supported in [Dial](https://www.twilio.com/docs/voice/twiml/dial#attributes-record) and [Outbound Rest API](https://www.twilio.com/docs/voice/make-calls) record options."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channels: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<CallRecordingEnumSource>,
    #[doc = "The error code that describes why the recording is `absent`. The error code is described in our [Error Dictionary](https://www.twilio.com/docs/api/errors). This value is null if the recording `status` is not `absent`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error_code: Option<i64>,
    #[doc = "The recorded track. Can be: `inbound`, `outbound`, or `both`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub track: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountCallCallRecording {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountCallCallRecording {
    const LENGTH: usize = 18;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(call_sid) = &self.call_sid {
                format!("{call_sid:?}")
            } else {
                String::new()
            },
            if let Some(conference_sid) = &self.conference_sid {
                format!("{conference_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(start_time) = &self.start_time {
                format!("{start_time:?}")
            } else {
                String::new()
            },
            if let Some(duration) = &self.duration {
                format!("{duration:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(price) = &self.price {
                format!("{price:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(encryption_details) = &self.encryption_details {
                format!("{encryption_details:?}")
            } else {
                String::new()
            },
            if let Some(price_unit) = &self.price_unit {
                format!("{price_unit:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
            if let Some(channels) = &self.channels {
                format!("{channels:?}")
            } else {
                String::new()
            },
            if let Some(source) = &self.source {
                format!("{source:?}")
            } else {
                String::new()
            },
            if let Some(error_code) = &self.error_code {
                format!("{error_code:?}")
            } else {
                String::new()
            },
            if let Some(track) = &self.track {
                format!("{track:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "call_sid".to_string(),
            "conference_sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "start_time".to_string(),
            "duration".to_string(),
            "sid".to_string(),
            "price".to_string(),
            "uri".to_string(),
            "encryption_details".to_string(),
            "price_unit".to_string(),
            "status".to_string(),
            "channels".to_string(),
            "source".to_string(),
            "error_code".to_string(),
            "track".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CallRecordingEnumStatus {
    #[serde(rename = "in-progress")]
    #[display("in-progress")]
    InProgress,
    #[serde(rename = "paused")]
    #[display("paused")]
    Paused,
    #[serde(rename = "stopped")]
    #[display("stopped")]
    Stopped,
    #[serde(rename = "processing")]
    #[display("processing")]
    Processing,
    #[serde(rename = "completed")]
    #[display("completed")]
    Completed,
    #[serde(rename = "absent")]
    #[display("absent")]
    Absent,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CallRecordingEnumSource {
    DialVerb,
    Conference,
    OutboundAPI,
    Trunking,
    RecordVerb,
    StartCallRecordingAPI,
    StartConferenceRecordingAPI,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountConference {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             this Conference resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The date and time in GMT that this resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that this resource was last updated, specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The API version used to create this conference."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "A string that you assigned to describe this conference room."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "A string that represents the Twilio Region where the conference audio was mixed. May \
             be `us1`, `ie1`,  `de1`, `sg1`, `br1`, `au1`, and `jp1`. Basic conference audio will \
             always be mixed in `us1`. Global Conference audio will be mixed nearest to the \
             majority of participants."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[doc = "The unique string that that we created to identify this Conference resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<ConferenceEnumStatus>,
    #[doc = "The URI of this resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "A list of related resources identified by their URIs relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason_conference_ended: Option<ConferenceEnumReasonConferenceEnded>,
    #[doc = "The call SID that caused the conference to end."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub call_sid_ending_conference: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountConference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountConference {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(region) = &self.region {
                format!("{region:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
            if let Some(reason_conference_ended) = &self.reason_conference_ended {
                format!("{reason_conference_ended:?}")
            } else {
                String::new()
            },
            if let Some(call_sid_ending_conference) = &self.call_sid_ending_conference {
                format!("{call_sid_ending_conference:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "api_version".to_string(),
            "friendly_name".to_string(),
            "region".to_string(),
            "sid".to_string(),
            "status".to_string(),
            "uri".to_string(),
            "subresource_uris".to_string(),
            "reason_conference_ended".to_string(),
            "call_sid_ending_conference".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum ConferenceEnumStatus {
    #[serde(rename = "init")]
    #[display("init")]
    Init,
    #[serde(rename = "in-progress")]
    #[display("in-progress")]
    InProgress,
    #[serde(rename = "completed")]
    #[display("completed")]
    Completed,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum ConferenceEnumUpdateStatus {
    #[serde(rename = "completed")]
    #[display("completed")]
    Completed,
}

impl std::default::Default for ConferenceEnumUpdateStatus {
    fn default() -> Self {
        ConferenceEnumUpdateStatus::Completed
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum ConferenceEnumReasonConferenceEnded {
    #[serde(rename = "conference-ended-via-api")]
    #[display("conference-ended-via-api")]
    ConferenceEndedViaApi,
    #[serde(rename = "participant-with-end-conference-on-exit-left")]
    #[display("participant-with-end-conference-on-exit-left")]
    ParticipantWithEndConferenceOnExitLeft,
    #[serde(rename = "participant-with-end-conference-on-exit-kicked")]
    #[display("participant-with-end-conference-on-exit-kicked")]
    ParticipantWithEndConferenceOnExitKicked,
    #[serde(rename = "last-participant-kicked")]
    #[display("last-participant-kicked")]
    LastParticipantKicked,
    #[serde(rename = "last-participant-left")]
    #[display("last-participant-left")]
    LastParticipantLeft,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountConferenceConferenceRecording {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the Conference Recording resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to create the recording."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) the \
             Conference Recording resource is associated with."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub call_sid: Option<String>,
    #[doc = "The Conference SID that identifies the conference associated with the recording."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conference_sid: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated, specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The start time of the recording in GMT and in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub start_time: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The length of the recording in seconds."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    #[doc = "The unique string that that we created to identify the Conference Recording resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The one-time cost of creating the recording in the `price_unit` currency."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    #[doc = "The currency used in the `price` property. Example: `USD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price_unit: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<ConferenceRecordingEnumStatus>,
    #[doc = "The number of channels in the final recording file.  Can be: `1`, or `2`. Separating a two leg call into two separate channels of the recording file is supported in [Dial](https://www.twilio.com/docs/voice/twiml/dial#attributes-record) and [Outbound Rest API](https://www.twilio.com/docs/voice/make-calls) record options."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channels: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<ConferenceRecordingEnumSource>,
    #[doc = "The error code that describes why the recording is `absent`. The error code is described in our [Error Dictionary](https://www.twilio.com/docs/api/errors). This value is null if the recording `status` is not `absent`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error_code: Option<i64>,
    #[doc = "How to decrypt the recording if it was encrypted using [Call Recording Encryption](https://www.twilio.com/docs/voice/tutorials/voice-recording-encryption) feature."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encryption_details: Option<serde_json::Value>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountConferenceConferenceRecording {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountConferenceConferenceRecording {
    const LENGTH: usize = 17;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(call_sid) = &self.call_sid {
                format!("{call_sid:?}")
            } else {
                String::new()
            },
            if let Some(conference_sid) = &self.conference_sid {
                format!("{conference_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(start_time) = &self.start_time {
                format!("{start_time:?}")
            } else {
                String::new()
            },
            if let Some(duration) = &self.duration {
                format!("{duration:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(price) = &self.price {
                format!("{price:?}")
            } else {
                String::new()
            },
            if let Some(price_unit) = &self.price_unit {
                format!("{price_unit:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
            if let Some(channels) = &self.channels {
                format!("{channels:?}")
            } else {
                String::new()
            },
            if let Some(source) = &self.source {
                format!("{source:?}")
            } else {
                String::new()
            },
            if let Some(error_code) = &self.error_code {
                format!("{error_code:?}")
            } else {
                String::new()
            },
            if let Some(encryption_details) = &self.encryption_details {
                format!("{encryption_details:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "call_sid".to_string(),
            "conference_sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "start_time".to_string(),
            "duration".to_string(),
            "sid".to_string(),
            "price".to_string(),
            "price_unit".to_string(),
            "status".to_string(),
            "channels".to_string(),
            "source".to_string(),
            "error_code".to_string(),
            "encryption_details".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum ConferenceRecordingEnumStatus {
    #[serde(rename = "in-progress")]
    #[display("in-progress")]
    InProgress,
    #[serde(rename = "paused")]
    #[display("paused")]
    Paused,
    #[serde(rename = "stopped")]
    #[display("stopped")]
    Stopped,
    #[serde(rename = "processing")]
    #[display("processing")]
    Processing,
    #[serde(rename = "completed")]
    #[display("completed")]
    Completed,
    #[serde(rename = "absent")]
    #[display("absent")]
    Absent,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum ConferenceRecordingEnumSource {
    DialVerb,
    Conference,
    OutboundAPI,
    Trunking,
    RecordVerb,
    StartCallRecordingAPI,
    StartConferenceRecordingAPI,
}

#[doc = "The HTTP method we use to call `deauthorize_callback_url`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum DeauthorizeCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountConnectApp {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the ConnectApp resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The URL we redirect the user to after we authenticate the user and obtain \
             authorization to access the Connect App."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorize_redirect_url: Option<String>,
    #[doc = "The company name set for the Connect App."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub company_name: Option<String>,
    #[doc = "The HTTP method we use to call `deauthorize_callback_url`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deauthorize_callback_method: Option<DeauthorizeCallbackMethod>,
    #[doc = "The URL we call using the `deauthorize_callback_method` to de-authorize the Connect \
             App."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deauthorize_callback_url: Option<String>,
    #[doc = "The description of the Connect App."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "The string that you assigned to describe the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The public URL where users can obtain more information about this Connect App."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub homepage_url: Option<String>,
    #[doc = "The set of permissions that your ConnectApp requests."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<Vec<ConnectAppEnumPermission>>,
    #[doc = "The unique string that that we created to identify the ConnectApp resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountConnectApp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountConnectApp {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(authorize_redirect_url) = &self.authorize_redirect_url {
                format!("{authorize_redirect_url:?}")
            } else {
                String::new()
            },
            if let Some(company_name) = &self.company_name {
                format!("{company_name:?}")
            } else {
                String::new()
            },
            if let Some(deauthorize_callback_method) = &self.deauthorize_callback_method {
                format!("{deauthorize_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(deauthorize_callback_url) = &self.deauthorize_callback_url {
                format!("{deauthorize_callback_url:?}")
            } else {
                String::new()
            },
            if let Some(description) = &self.description {
                format!("{description:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(homepage_url) = &self.homepage_url {
                format!("{homepage_url:?}")
            } else {
                String::new()
            },
            if let Some(permissions) = &self.permissions {
                format!("{permissions:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "authorize_redirect_url".to_string(),
            "company_name".to_string(),
            "deauthorize_callback_method".to_string(),
            "deauthorize_callback_url".to_string(),
            "description".to_string(),
            "friendly_name".to_string(),
            "homepage_url".to_string(),
            "permissions".to_string(),
            "sid".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum ConnectAppEnumPermission {
    #[serde(rename = "get-all")]
    #[display("get-all")]
    GetAll,
    #[serde(rename = "post-all")]
    #[display("post-all")]
    PostAll,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountAddressDependentPhoneNumber {
    #[doc = "The unique string that that we created to identify the DependentPhoneNumber resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the DependentPhoneNumber resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The string that you assigned to describe the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: phone_number::PhoneNumber,
    #[doc = "The phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, \
             which consists of a + followed by the country code and subscriber number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone_number: phone_number::PhoneNumber,
    #[doc = "The URL we call when the phone number receives a call. The `voice_url` will not be \
             used if a `voice_application_sid` or a `trunk_sid` is set."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_url: Option<String>,
    #[doc = "The HTTP method we use to call `voice_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_method: Option<VoiceMethod>,
    #[doc = "The HTTP method we use to call `voice_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_fallback_method: Option<VoiceFallbackMethod>,
    #[doc = "The URL that we call when an error occurs retrieving or executing the TwiML \
             requested by `url`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_fallback_url: Option<String>,
    #[doc = "Whether we look up the caller's caller-ID name from the CNAM database. Can be: \
             `true` or `false`. Caller ID lookups can cost $0.01 each."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_caller_id_lookup: Option<bool>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The HTTP method we use to call `sms_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_fallback_method: Option<SmsFallbackMethod>,
    #[doc = "The URL that we call when an error occurs while retrieving or executing the TwiML \
             from `sms_url`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_fallback_url: Option<String>,
    #[doc = "The HTTP method we use to call `sms_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_method: Option<SmsMethod>,
    #[doc = "The URL we call when the phone number receives an incoming SMS message."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address_requirements: Option<DependentPhoneNumberEnumAddressRequirement>,
    #[doc = "The set of Boolean properties that indicates whether a phone number can receive \
             calls or messages.  Capabilities are  `Voice`, `SMS`, and `MMS` and each capability \
             can be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<serde_json::Value>,
    #[doc = "The URL we call using the `status_callback_method` to send status information to \
             your application."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status_callback: Option<String>,
    #[doc = "The HTTP method we use to call `status_callback`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status_callback_method: Option<StatusCallbackMethod>,
    #[doc = "The API version used to start a new TwiML session."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "The SID of the application that handles SMS messages sent to the phone number. If an \
             `sms_application_sid` is present, we ignore all `sms_*_url` values and use those of \
             the application."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_application_sid: Option<String>,
    #[doc = "The SID of the application that handles calls to the phone number. If a \
             `voice_application_sid` is present, we ignore all of the voice urls and use those \
             set on the application. Setting a `voice_application_sid` will automatically delete \
             your `trunk_sid` and vice versa."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_application_sid: Option<String>,
    #[doc = "The SID of the Trunk that handles calls to the phone number. If a `trunk_sid` is \
             present, we ignore all of the voice urls and voice applications and use those set on \
             the Trunk. Setting a `trunk_sid` will automatically delete your \
             `voice_application_sid` and vice versa."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub trunk_sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emergency_status: Option<DependentPhoneNumberEnumEmergencyStatus>,
    #[doc = "The SID of the emergency address configuration that we use for emergency calling \
             from the phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emergency_address_sid: Option<String>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountAddressDependentPhoneNumber {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountAddressDependentPhoneNumber {
    const LENGTH: usize = 26;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            format!("{:?}", self.friendly_name),
            format!("{:?}", self.phone_number),
            if let Some(voice_url) = &self.voice_url {
                format!("{voice_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_method) = &self.voice_method {
                format!("{voice_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_method) = &self.voice_fallback_method {
                format!("{voice_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_url) = &self.voice_fallback_url {
                format!("{voice_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_caller_id_lookup) = &self.voice_caller_id_lookup {
                format!("{voice_caller_id_lookup:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_method) = &self.sms_fallback_method {
                format!("{sms_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_url) = &self.sms_fallback_url {
                format!("{sms_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(sms_method) = &self.sms_method {
                format!("{sms_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_url) = &self.sms_url {
                format!("{sms_url:?}")
            } else {
                String::new()
            },
            if let Some(address_requirements) = &self.address_requirements {
                format!("{address_requirements:?}")
            } else {
                String::new()
            },
            if let Some(capabilities) = &self.capabilities {
                format!("{capabilities:?}")
            } else {
                String::new()
            },
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(sms_application_sid) = &self.sms_application_sid {
                format!("{sms_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(voice_application_sid) = &self.voice_application_sid {
                format!("{voice_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(trunk_sid) = &self.trunk_sid {
                format!("{trunk_sid:?}")
            } else {
                String::new()
            },
            if let Some(emergency_status) = &self.emergency_status {
                format!("{emergency_status:?}")
            } else {
                String::new()
            },
            if let Some(emergency_address_sid) = &self.emergency_address_sid {
                format!("{emergency_address_sid:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "sid".to_string(),
            "account_sid".to_string(),
            "friendly_name".to_string(),
            "phone_number".to_string(),
            "voice_url".to_string(),
            "voice_method".to_string(),
            "voice_fallback_method".to_string(),
            "voice_fallback_url".to_string(),
            "voice_caller_id_lookup".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "sms_fallback_method".to_string(),
            "sms_fallback_url".to_string(),
            "sms_method".to_string(),
            "sms_url".to_string(),
            "address_requirements".to_string(),
            "capabilities".to_string(),
            "status_callback".to_string(),
            "status_callback_method".to_string(),
            "api_version".to_string(),
            "sms_application_sid".to_string(),
            "voice_application_sid".to_string(),
            "trunk_sid".to_string(),
            "emergency_status".to_string(),
            "emergency_address_sid".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum DependentPhoneNumberEnumAddressRequirement {
    #[serde(rename = "none")]
    #[display("none")]
    None,
    #[serde(rename = "any")]
    #[display("any")]
    Any,
    #[serde(rename = "local")]
    #[display("local")]
    Local,
    #[serde(rename = "foreign")]
    #[display("foreign")]
    Foreign,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum DependentPhoneNumberEnumEmergencyStatus {
    Active,
    Inactive,
}

#[doc = "The set of Boolean properties that indicate whether a phone number can receive calls or \
         messages.  Capabilities are  `Voice`, `SMS`, and `MMS` and each capability can be: `true` \
         or `false`."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountIncomingPhoneNumberCapabilities {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mms: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fax: Option<bool>,
}

impl std::fmt::Display for ApiV2010AccountIncomingPhoneNumberCapabilities {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountIncomingPhoneNumberCapabilities {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(mms) = &self.mms {
                format!("{mms:?}")
            } else {
                String::new()
            },
            if let Some(sms) = &self.sms {
                format!("{sms:?}")
            } else {
                String::new()
            },
            if let Some(voice) = &self.voice {
                format!("{voice:?}")
            } else {
                String::new()
            },
            if let Some(fax) = &self.fax {
                format!("{fax:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "mms".to_string(),
            "sms".to_string(),
            "voice".to_string(),
            "fax".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountIncomingPhoneNumber {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             this IncomingPhoneNumber resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The SID of the Address resource associated with the phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address_sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address_requirements: Option<IncomingPhoneNumberEnumAddressRequirement>,
    #[doc = "The API version used to start a new TwiML session."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "Whether the phone number is new to the Twilio platform. Can be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub beta: Option<bool>,
    #[doc = "The set of Boolean properties that indicate whether a phone number can receive calls \
             or messages.  Capabilities are  `Voice`, `SMS`, and `MMS` and each capability can \
             be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<ApiV2010AccountIncomingPhoneNumberCapabilities>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The string that you assigned to describe the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The SID of the Identity resource that we associate with the phone number. Some \
             regions require an Identity to meet local regulations."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identity_sid: Option<String>,
    #[doc = "The phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, \
             which consists of a + followed by the country code and subscriber number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone_number: phone_number::PhoneNumber,
    #[doc = "The phone number's origin. `twilio` identifies Twilio-owned phone numbers and \
             `hosted` identifies hosted phone numbers."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub origin: Option<String>,
    #[doc = "The unique string that that we created to identify this IncomingPhoneNumber resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The SID of the application that handles SMS messages sent to the phone number. If an \
             `sms_application_sid` is present, we ignore all `sms_*_url` values and use those of \
             the application."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_application_sid: Option<String>,
    #[doc = "The HTTP method we use to call `sms_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_fallback_method: Option<SmsFallbackMethod>,
    #[doc = "The URL that we call when an error occurs while retrieving or executing the TwiML \
             from `sms_url`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_fallback_url: Option<String>,
    #[doc = "The HTTP method we use to call `sms_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_method: Option<SmsMethod>,
    #[doc = "The URL we call when the phone number receives an incoming SMS message."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_url: Option<String>,
    #[doc = "The URL we call using the `status_callback_method` to send status information to \
             your application."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status_callback: Option<String>,
    #[doc = "The HTTP method we use to call `status_callback`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status_callback_method: Option<StatusCallbackMethod>,
    #[doc = "The SID of the Trunk that handles calls to the phone number. If a `trunk_sid` is \
             present, we ignore all of the voice urls and voice applications and use those set on \
             the Trunk. Setting a `trunk_sid` will automatically delete your \
             `voice_application_sid` and vice versa."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub trunk_sid: Option<String>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_receive_mode: Option<IncomingPhoneNumberEnumVoiceReceiveMode>,
    #[doc = "The SID of the application that handles calls to the phone number. If a \
             `voice_application_sid` is present, we ignore all of the voice urls and use those \
             set on the application. Setting a `voice_application_sid` will automatically delete \
             your `trunk_sid` and vice versa."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_application_sid: Option<String>,
    #[doc = "Whether we look up the caller's caller-ID name from the CNAM database ($0.01 per \
             look up). Can be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_caller_id_lookup: Option<bool>,
    #[doc = "The HTTP method we use to call `voice_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_fallback_method: Option<VoiceFallbackMethod>,
    #[doc = "The URL that we call when an error occurs retrieving or executing the TwiML \
             requested by `url`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_fallback_url: Option<String>,
    #[doc = "The HTTP method we use to call `voice_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_method: Option<VoiceMethod>,
    #[doc = "The URL we call when the phone number receives a call. The `voice_url` will not be \
             used if a `voice_application_sid` or a `trunk_sid` is set."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emergency_status: Option<IncomingPhoneNumberEnumEmergencyStatus>,
    #[doc = "The SID of the emergency address configuration that we use for emergency calling \
             from this phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emergency_address_sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emergency_address_status: Option<IncomingPhoneNumberEnumEmergencyAddressStatus>,
    #[doc = "The SID of the Bundle resource that you associate with the phone number. Some \
             regions require a Bundle to meet local Regulations."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bundle_sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountIncomingPhoneNumber {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountIncomingPhoneNumber {
    const LENGTH: usize = 34;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(address_sid) = &self.address_sid {
                format!("{address_sid:?}")
            } else {
                String::new()
            },
            if let Some(address_requirements) = &self.address_requirements {
                format!("{address_requirements:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(beta) = &self.beta {
                format!("{beta:?}")
            } else {
                String::new()
            },
            if let Some(capabilities) = &self.capabilities {
                format!("{capabilities:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(identity_sid) = &self.identity_sid {
                format!("{identity_sid:?}")
            } else {
                String::new()
            },
            format!("{:?}", self.phone_number),
            if let Some(origin) = &self.origin {
                format!("{origin:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(sms_application_sid) = &self.sms_application_sid {
                format!("{sms_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_method) = &self.sms_fallback_method {
                format!("{sms_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_url) = &self.sms_fallback_url {
                format!("{sms_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(sms_method) = &self.sms_method {
                format!("{sms_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_url) = &self.sms_url {
                format!("{sms_url:?}")
            } else {
                String::new()
            },
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(trunk_sid) = &self.trunk_sid {
                format!("{trunk_sid:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(voice_receive_mode) = &self.voice_receive_mode {
                format!("{voice_receive_mode:?}")
            } else {
                String::new()
            },
            if let Some(voice_application_sid) = &self.voice_application_sid {
                format!("{voice_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(voice_caller_id_lookup) = &self.voice_caller_id_lookup {
                format!("{voice_caller_id_lookup:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_method) = &self.voice_fallback_method {
                format!("{voice_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_url) = &self.voice_fallback_url {
                format!("{voice_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_method) = &self.voice_method {
                format!("{voice_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_url) = &self.voice_url {
                format!("{voice_url:?}")
            } else {
                String::new()
            },
            if let Some(emergency_status) = &self.emergency_status {
                format!("{emergency_status:?}")
            } else {
                String::new()
            },
            if let Some(emergency_address_sid) = &self.emergency_address_sid {
                format!("{emergency_address_sid:?}")
            } else {
                String::new()
            },
            if let Some(emergency_address_status) = &self.emergency_address_status {
                format!("{emergency_address_status:?}")
            } else {
                String::new()
            },
            if let Some(bundle_sid) = &self.bundle_sid {
                format!("{bundle_sid:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "address_sid".to_string(),
            "address_requirements".to_string(),
            "api_version".to_string(),
            "beta".to_string(),
            "capabilities".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "friendly_name".to_string(),
            "identity_sid".to_string(),
            "phone_number".to_string(),
            "origin".to_string(),
            "sid".to_string(),
            "sms_application_sid".to_string(),
            "sms_fallback_method".to_string(),
            "sms_fallback_url".to_string(),
            "sms_method".to_string(),
            "sms_url".to_string(),
            "status_callback".to_string(),
            "status_callback_method".to_string(),
            "trunk_sid".to_string(),
            "uri".to_string(),
            "voice_receive_mode".to_string(),
            "voice_application_sid".to_string(),
            "voice_caller_id_lookup".to_string(),
            "voice_fallback_method".to_string(),
            "voice_fallback_url".to_string(),
            "voice_method".to_string(),
            "voice_url".to_string(),
            "emergency_status".to_string(),
            "emergency_address_sid".to_string(),
            "emergency_address_status".to_string(),
            "bundle_sid".to_string(),
            "status".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum IncomingPhoneNumberEnumAddressRequirement {
    #[serde(rename = "none")]
    #[display("none")]
    None,
    #[serde(rename = "any")]
    #[display("any")]
    Any,
    #[serde(rename = "local")]
    #[display("local")]
    Local,
    #[serde(rename = "foreign")]
    #[display("foreign")]
    Foreign,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum IncomingPhoneNumberEnumEmergencyStatus {
    Active,
    Inactive,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum IncomingPhoneNumberEnumEmergencyAddressStatus {
    #[serde(rename = "registered")]
    #[display("registered")]
    Registered,
    #[serde(rename = "unregistered")]
    #[display("unregistered")]
    Unregistered,
    #[serde(rename = "pending-registration")]
    #[display("pending-registration")]
    PendingRegistration,
    #[serde(rename = "registration-failure")]
    #[display("registration-failure")]
    RegistrationFailure,
    #[serde(rename = "pending-unregistration")]
    #[display("pending-unregistration")]
    PendingUnregistration,
    #[serde(rename = "unregistration-failure")]
    #[display("unregistration-failure")]
    UnregistrationFailure,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum IncomingPhoneNumberEnumVoiceReceiveMode {
    #[serde(rename = "voice")]
    #[display("voice")]
    Voice,
    #[serde(rename = "fax")]
    #[display("fax")]
    Fax,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn {
    #[doc = "The unique string that that we created to identify the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The SID of the Phone Number to which the Add-on is assigned."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource_sid: Option<String>,
    #[doc = "The string that you assigned to describe the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "A short description of the functionality that the Add-on provides."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "A JSON string that represents the current configuration of this Add-on installation."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configuration: Option<serde_json::Value>,
    #[doc = "An application-defined string that uniquely identifies the resource. It can be used \
             in place of the resource's `sid` in the URL to address the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unique_name: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "A list of related resources identified by their relative URIs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
}

impl std::fmt::Display for ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(resource_sid) = &self.resource_sid {
                format!("{resource_sid:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(description) = &self.description {
                format!("{description:?}")
            } else {
                String::new()
            },
            if let Some(configuration) = &self.configuration {
                format!("{configuration:?}")
            } else {
                String::new()
            },
            if let Some(unique_name) = &self.unique_name {
                format!("{unique_name:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "sid".to_string(),
            "account_sid".to_string(),
            "resource_sid".to_string(),
            "friendly_name".to_string(),
            "description".to_string(),
            "configuration".to_string(),
            "unique_name".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "uri".to_string(),
            "subresource_uris".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOnIncomingPhoneNumberAssignedAddOnExtension
{
    #[doc = "The unique string that that we created to identify the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The SID of the Phone Number to which the Add-on is assigned."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource_sid: Option<String>,
    #[doc = "The SID that uniquely identifies the assigned Add-on installation."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assigned_add_on_sid: Option<String>,
    #[doc = "The string that you assigned to describe the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "A string that you assigned to describe the Product this Extension is used within."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub product_name: Option<String>,
    #[doc = "An application-defined string that uniquely identifies the resource. It can be used \
             in place of the resource's `sid` in the URL to address the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unique_name: Option<String>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "Whether the Extension will be invoked."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

impl std :: fmt :: Display for ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOnIncomingPhoneNumberAssignedAddOnExtension { fn fmt (& self , f : & mut std :: fmt :: Formatter < '_ >) -> Result < () , std :: fmt :: Error > { write ! (f , "{}" , serde_json :: to_string_pretty (self) . map_err (| _ | std :: fmt :: Error) ?) } }

impl tabled :: Tabled for ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOnIncomingPhoneNumberAssignedAddOnExtension { const LENGTH : usize = 9 ; fn fields (& self) -> Vec < String > { vec ! [if let Some (sid) = & self . sid { format ! ("{sid:?}" ) } else { String :: new () } , if let Some (account_sid) = & self . account_sid { format ! ("{account_sid:?}" ) } else { String :: new () } , if let Some (resource_sid) = & self . resource_sid { format ! ("{resource_sid:?}" ) } else { String :: new () } , if let Some (assigned_add_on_sid) = & self . assigned_add_on_sid { format ! ("{assigned_add_on_sid:?}" ) } else { String :: new () } , if let Some (friendly_name) = & self . friendly_name { format ! ("{friendly_name:?}" ) } else { String :: new () } , if let Some (product_name) = & self . product_name { format ! ("{product_name:?}" ) } else { String :: new () } , if let Some (unique_name) = & self . unique_name { format ! ("{unique_name:?}" ) } else { String :: new () } , if let Some (uri) = & self . uri { format ! ("{uri:?}" ) } else { String :: new () } , if let Some (enabled) = & self . enabled { format ! ("{enabled:?}" ) } else { String :: new () }] } fn headers () -> Vec < String > { vec ! ["sid" . to_string () , "account_sid" . to_string () , "resource_sid" . to_string () , "assigned_add_on_sid" . to_string () , "friendly_name" . to_string () , "product_name" . to_string () , "unique_name" . to_string () , "uri" . to_string () , "enabled" . to_string ()] } }

#[doc = "The set of Boolean properties that indicate whether a phone number can receive calls or \
         messages.  Capabilities are  `Voice`, `SMS`, and `MMS` and each capability can be: `true` \
         or `false`."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocalCapabilities {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mms: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fax: Option<bool>,
}

impl std::fmt::Display for ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocalCapabilities {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocalCapabilities {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(mms) = &self.mms {
                format!("{mms:?}")
            } else {
                String::new()
            },
            if let Some(sms) = &self.sms {
                format!("{sms:?}")
            } else {
                String::new()
            },
            if let Some(voice) = &self.voice {
                format!("{voice:?}")
            } else {
                String::new()
            },
            if let Some(fax) = &self.fax {
                format!("{fax:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "mms".to_string(),
            "sms".to_string(),
            "voice".to_string(),
            "fax".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocal {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The SID of the Address resource associated with the phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address_sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address_requirements: Option<IncomingPhoneNumberLocalEnumAddressRequirement>,
    #[doc = "The API version used to start a new TwiML session."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "Whether the phone number is new to the Twilio platform. Can be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub beta: Option<bool>,
    #[doc = "The set of Boolean properties that indicate whether a phone number can receive calls \
             or messages.  Capabilities are  `Voice`, `SMS`, and `MMS` and each capability can \
             be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities:
        Option<ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocalCapabilities>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The string that you assigned to describe the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The SID of the Identity resource that we associate with the phone number. Some \
             regions require an Identity to meet local regulations."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identity_sid: Option<String>,
    #[doc = "The phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, \
             which consists of a + followed by the country code and subscriber number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone_number: phone_number::PhoneNumber,
    #[doc = "The phone number's origin. `twilio` identifies Twilio-owned phone numbers and \
             `hosted` identifies hosted phone numbers."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub origin: Option<String>,
    #[doc = "The unique string that that we created to identify the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The SID of the application that handles SMS messages sent to the phone number. If an \
             `sms_application_sid` is present, we ignore all `sms_*_url` values and use those of \
             the application."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_application_sid: Option<String>,
    #[doc = "The HTTP method we use to call `sms_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_fallback_method: Option<SmsFallbackMethod>,
    #[doc = "The URL that we call when an error occurs while retrieving or executing the TwiML \
             from `sms_url`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_fallback_url: Option<String>,
    #[doc = "The HTTP method we use to call `sms_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_method: Option<SmsMethod>,
    #[doc = "The URL we call when the phone number receives an incoming SMS message."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_url: Option<String>,
    #[doc = "The URL we call using the `status_callback_method` to send status information to \
             your application."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status_callback: Option<String>,
    #[doc = "The HTTP method we use to call `status_callback`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status_callback_method: Option<StatusCallbackMethod>,
    #[doc = "The SID of the Trunk that handles calls to the phone number. If a `trunk_sid` is \
             present, we ignore all of the voice urls and voice applications and use those set on \
             the Trunk. Setting a `trunk_sid` will automatically delete your \
             `voice_application_sid` and vice versa."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub trunk_sid: Option<String>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_receive_mode: Option<IncomingPhoneNumberLocalEnumVoiceReceiveMode>,
    #[doc = "The SID of the application that handles calls to the phone number. If a \
             `voice_application_sid` is present, we ignore all of the voice urls and use those \
             set on the application. Setting a `voice_application_sid` will automatically delete \
             your `trunk_sid` and vice versa."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_application_sid: Option<String>,
    #[doc = "Whether we look up the caller's caller-ID name from the CNAM database ($0.01 per \
             look up). Can be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_caller_id_lookup: Option<bool>,
    #[doc = "The HTTP method we use to call `voice_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_fallback_method: Option<VoiceFallbackMethod>,
    #[doc = "The URL that we call when an error occurs retrieving or executing the TwiML \
             requested by `url`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_fallback_url: Option<String>,
    #[doc = "The HTTP method we use to call `voice_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_method: Option<VoiceMethod>,
    #[doc = "The URL we call when this phone number receives a call. The `voice_url` will not be \
             used if a `voice_application_sid` or a `trunk_sid` is set."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emergency_status: Option<IncomingPhoneNumberLocalEnumEmergencyStatus>,
    #[doc = "The SID of the emergency address configuration that we use for emergency calling \
             from this phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emergency_address_sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emergency_address_status: Option<IncomingPhoneNumberLocalEnumEmergencyAddressStatus>,
    #[doc = "The SID of the Bundle resource that you associate with the phone number. Some \
             regions require a Bundle to meet local Regulations."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bundle_sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocal {
    const LENGTH: usize = 34;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(address_sid) = &self.address_sid {
                format!("{address_sid:?}")
            } else {
                String::new()
            },
            if let Some(address_requirements) = &self.address_requirements {
                format!("{address_requirements:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(beta) = &self.beta {
                format!("{beta:?}")
            } else {
                String::new()
            },
            if let Some(capabilities) = &self.capabilities {
                format!("{capabilities:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(identity_sid) = &self.identity_sid {
                format!("{identity_sid:?}")
            } else {
                String::new()
            },
            format!("{:?}", self.phone_number),
            if let Some(origin) = &self.origin {
                format!("{origin:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(sms_application_sid) = &self.sms_application_sid {
                format!("{sms_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_method) = &self.sms_fallback_method {
                format!("{sms_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_url) = &self.sms_fallback_url {
                format!("{sms_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(sms_method) = &self.sms_method {
                format!("{sms_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_url) = &self.sms_url {
                format!("{sms_url:?}")
            } else {
                String::new()
            },
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(trunk_sid) = &self.trunk_sid {
                format!("{trunk_sid:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(voice_receive_mode) = &self.voice_receive_mode {
                format!("{voice_receive_mode:?}")
            } else {
                String::new()
            },
            if let Some(voice_application_sid) = &self.voice_application_sid {
                format!("{voice_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(voice_caller_id_lookup) = &self.voice_caller_id_lookup {
                format!("{voice_caller_id_lookup:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_method) = &self.voice_fallback_method {
                format!("{voice_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_url) = &self.voice_fallback_url {
                format!("{voice_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_method) = &self.voice_method {
                format!("{voice_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_url) = &self.voice_url {
                format!("{voice_url:?}")
            } else {
                String::new()
            },
            if let Some(emergency_status) = &self.emergency_status {
                format!("{emergency_status:?}")
            } else {
                String::new()
            },
            if let Some(emergency_address_sid) = &self.emergency_address_sid {
                format!("{emergency_address_sid:?}")
            } else {
                String::new()
            },
            if let Some(emergency_address_status) = &self.emergency_address_status {
                format!("{emergency_address_status:?}")
            } else {
                String::new()
            },
            if let Some(bundle_sid) = &self.bundle_sid {
                format!("{bundle_sid:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "address_sid".to_string(),
            "address_requirements".to_string(),
            "api_version".to_string(),
            "beta".to_string(),
            "capabilities".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "friendly_name".to_string(),
            "identity_sid".to_string(),
            "phone_number".to_string(),
            "origin".to_string(),
            "sid".to_string(),
            "sms_application_sid".to_string(),
            "sms_fallback_method".to_string(),
            "sms_fallback_url".to_string(),
            "sms_method".to_string(),
            "sms_url".to_string(),
            "status_callback".to_string(),
            "status_callback_method".to_string(),
            "trunk_sid".to_string(),
            "uri".to_string(),
            "voice_receive_mode".to_string(),
            "voice_application_sid".to_string(),
            "voice_caller_id_lookup".to_string(),
            "voice_fallback_method".to_string(),
            "voice_fallback_url".to_string(),
            "voice_method".to_string(),
            "voice_url".to_string(),
            "emergency_status".to_string(),
            "emergency_address_sid".to_string(),
            "emergency_address_status".to_string(),
            "bundle_sid".to_string(),
            "status".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum IncomingPhoneNumberLocalEnumAddressRequirement {
    #[serde(rename = "none")]
    #[display("none")]
    None,
    #[serde(rename = "any")]
    #[display("any")]
    Any,
    #[serde(rename = "local")]
    #[display("local")]
    Local,
    #[serde(rename = "foreign")]
    #[display("foreign")]
    Foreign,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum IncomingPhoneNumberLocalEnumEmergencyStatus {
    Active,
    Inactive,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum IncomingPhoneNumberLocalEnumEmergencyAddressStatus {
    #[serde(rename = "registered")]
    #[display("registered")]
    Registered,
    #[serde(rename = "unregistered")]
    #[display("unregistered")]
    Unregistered,
    #[serde(rename = "pending-registration")]
    #[display("pending-registration")]
    PendingRegistration,
    #[serde(rename = "registration-failure")]
    #[display("registration-failure")]
    RegistrationFailure,
    #[serde(rename = "pending-unregistration")]
    #[display("pending-unregistration")]
    PendingUnregistration,
    #[serde(rename = "unregistration-failure")]
    #[display("unregistration-failure")]
    UnregistrationFailure,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum IncomingPhoneNumberLocalEnumVoiceReceiveMode {
    #[serde(rename = "voice")]
    #[display("voice")]
    Voice,
    #[serde(rename = "fax")]
    #[display("fax")]
    Fax,
}

#[doc = "The set of Boolean properties that indicate whether a phone number can receive calls or \
         messages.  Capabilities are  `Voice`, `SMS`, and `MMS` and each capability can be: `true` \
         or `false`."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobileCapabilities {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mms: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fax: Option<bool>,
}

impl std::fmt::Display for ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobileCapabilities {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobileCapabilities {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(mms) = &self.mms {
                format!("{mms:?}")
            } else {
                String::new()
            },
            if let Some(sms) = &self.sms {
                format!("{sms:?}")
            } else {
                String::new()
            },
            if let Some(voice) = &self.voice {
                format!("{voice:?}")
            } else {
                String::new()
            },
            if let Some(fax) = &self.fax {
                format!("{fax:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "mms".to_string(),
            "sms".to_string(),
            "voice".to_string(),
            "fax".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobile {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The SID of the Address resource associated with the phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address_sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address_requirements: Option<IncomingPhoneNumberMobileEnumAddressRequirement>,
    #[doc = "The API version used to start a new TwiML session."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "Whether the phone number is new to the Twilio platform. Can be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub beta: Option<bool>,
    #[doc = "The set of Boolean properties that indicate whether a phone number can receive calls \
             or messages.  Capabilities are  `Voice`, `SMS`, and `MMS` and each capability can \
             be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities:
        Option<ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobileCapabilities>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The string that you assigned to describe the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The SID of the Identity resource that we associate with the phone number. Some \
             regions require an Identity to meet local regulations."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identity_sid: Option<String>,
    #[doc = "The phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, \
             which consists of a + followed by the country code and subscriber number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone_number: phone_number::PhoneNumber,
    #[doc = "The phone number's origin. `twilio` identifies Twilio-owned phone numbers and \
             `hosted` identifies hosted phone numbers."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub origin: Option<String>,
    #[doc = "The unique string that that we created to identify the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The SID of the application that handles SMS messages sent to the phone number. If an \
             `sms_application_sid` is present, we ignore all `sms_*_url` values and use those of \
             the application."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_application_sid: Option<String>,
    #[doc = "The HTTP method we use to call `sms_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_fallback_method: Option<SmsFallbackMethod>,
    #[doc = "The URL that we call when an error occurs while retrieving or executing the TwiML \
             from `sms_url`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_fallback_url: Option<String>,
    #[doc = "The HTTP method we use to call `sms_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_method: Option<SmsMethod>,
    #[doc = "The URL we call when the phone number receives an incoming SMS message."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_url: Option<String>,
    #[doc = "The URL we call using the `status_callback_method` to send status information to \
             your application."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status_callback: Option<String>,
    #[doc = "The HTTP method we use to call `status_callback`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status_callback_method: Option<StatusCallbackMethod>,
    #[doc = "The SID of the Trunk that handles calls to the phone number. If a `trunk_sid` is \
             present, we ignore all of the voice urls and voice applications and use those set on \
             the Trunk. Setting a `trunk_sid` will automatically delete your \
             `voice_application_sid` and vice versa."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub trunk_sid: Option<String>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_receive_mode: Option<IncomingPhoneNumberMobileEnumVoiceReceiveMode>,
    #[doc = "The SID of the application that handles calls to the phone number. If a \
             `voice_application_sid` is present, we ignore all of the voice urls and use those \
             set on the application. Setting a `voice_application_sid` will automatically delete \
             your `trunk_sid` and vice versa."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_application_sid: Option<String>,
    #[doc = "Whether we look up the caller's caller-ID name from the CNAM database ($0.01 per \
             look up). Can be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_caller_id_lookup: Option<bool>,
    #[doc = "The HTTP method we use to call `voice_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_fallback_method: Option<VoiceFallbackMethod>,
    #[doc = "The URL that we call when an error occurs retrieving or executing the TwiML \
             requested by `url`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_fallback_url: Option<String>,
    #[doc = "The HTTP method we use to call `voice_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_method: Option<VoiceMethod>,
    #[doc = "The URL we call when the phone number receives a call. The `voice_url` will not be \
             used if a `voice_application_sid` or a `trunk_sid` is set."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emergency_status: Option<IncomingPhoneNumberMobileEnumEmergencyStatus>,
    #[doc = "The SID of the emergency address configuration that we use for emergency calling \
             from this phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emergency_address_sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emergency_address_status: Option<IncomingPhoneNumberMobileEnumEmergencyAddressStatus>,
    #[doc = "The SID of the Bundle resource that you associate with the phone number. Some \
             regions require a Bundle to meet local Regulations."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bundle_sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobile {
    const LENGTH: usize = 34;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(address_sid) = &self.address_sid {
                format!("{address_sid:?}")
            } else {
                String::new()
            },
            if let Some(address_requirements) = &self.address_requirements {
                format!("{address_requirements:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(beta) = &self.beta {
                format!("{beta:?}")
            } else {
                String::new()
            },
            if let Some(capabilities) = &self.capabilities {
                format!("{capabilities:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(identity_sid) = &self.identity_sid {
                format!("{identity_sid:?}")
            } else {
                String::new()
            },
            format!("{:?}", self.phone_number),
            if let Some(origin) = &self.origin {
                format!("{origin:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(sms_application_sid) = &self.sms_application_sid {
                format!("{sms_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_method) = &self.sms_fallback_method {
                format!("{sms_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_url) = &self.sms_fallback_url {
                format!("{sms_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(sms_method) = &self.sms_method {
                format!("{sms_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_url) = &self.sms_url {
                format!("{sms_url:?}")
            } else {
                String::new()
            },
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(trunk_sid) = &self.trunk_sid {
                format!("{trunk_sid:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(voice_receive_mode) = &self.voice_receive_mode {
                format!("{voice_receive_mode:?}")
            } else {
                String::new()
            },
            if let Some(voice_application_sid) = &self.voice_application_sid {
                format!("{voice_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(voice_caller_id_lookup) = &self.voice_caller_id_lookup {
                format!("{voice_caller_id_lookup:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_method) = &self.voice_fallback_method {
                format!("{voice_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_url) = &self.voice_fallback_url {
                format!("{voice_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_method) = &self.voice_method {
                format!("{voice_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_url) = &self.voice_url {
                format!("{voice_url:?}")
            } else {
                String::new()
            },
            if let Some(emergency_status) = &self.emergency_status {
                format!("{emergency_status:?}")
            } else {
                String::new()
            },
            if let Some(emergency_address_sid) = &self.emergency_address_sid {
                format!("{emergency_address_sid:?}")
            } else {
                String::new()
            },
            if let Some(emergency_address_status) = &self.emergency_address_status {
                format!("{emergency_address_status:?}")
            } else {
                String::new()
            },
            if let Some(bundle_sid) = &self.bundle_sid {
                format!("{bundle_sid:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "address_sid".to_string(),
            "address_requirements".to_string(),
            "api_version".to_string(),
            "beta".to_string(),
            "capabilities".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "friendly_name".to_string(),
            "identity_sid".to_string(),
            "phone_number".to_string(),
            "origin".to_string(),
            "sid".to_string(),
            "sms_application_sid".to_string(),
            "sms_fallback_method".to_string(),
            "sms_fallback_url".to_string(),
            "sms_method".to_string(),
            "sms_url".to_string(),
            "status_callback".to_string(),
            "status_callback_method".to_string(),
            "trunk_sid".to_string(),
            "uri".to_string(),
            "voice_receive_mode".to_string(),
            "voice_application_sid".to_string(),
            "voice_caller_id_lookup".to_string(),
            "voice_fallback_method".to_string(),
            "voice_fallback_url".to_string(),
            "voice_method".to_string(),
            "voice_url".to_string(),
            "emergency_status".to_string(),
            "emergency_address_sid".to_string(),
            "emergency_address_status".to_string(),
            "bundle_sid".to_string(),
            "status".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum IncomingPhoneNumberMobileEnumAddressRequirement {
    #[serde(rename = "none")]
    #[display("none")]
    None,
    #[serde(rename = "any")]
    #[display("any")]
    Any,
    #[serde(rename = "local")]
    #[display("local")]
    Local,
    #[serde(rename = "foreign")]
    #[display("foreign")]
    Foreign,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum IncomingPhoneNumberMobileEnumEmergencyStatus {
    Active,
    Inactive,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum IncomingPhoneNumberMobileEnumEmergencyAddressStatus {
    #[serde(rename = "registered")]
    #[display("registered")]
    Registered,
    #[serde(rename = "unregistered")]
    #[display("unregistered")]
    Unregistered,
    #[serde(rename = "pending-registration")]
    #[display("pending-registration")]
    PendingRegistration,
    #[serde(rename = "registration-failure")]
    #[display("registration-failure")]
    RegistrationFailure,
    #[serde(rename = "pending-unregistration")]
    #[display("pending-unregistration")]
    PendingUnregistration,
    #[serde(rename = "unregistration-failure")]
    #[display("unregistration-failure")]
    UnregistrationFailure,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum IncomingPhoneNumberMobileEnumVoiceReceiveMode {
    #[serde(rename = "voice")]
    #[display("voice")]
    Voice,
    #[serde(rename = "fax")]
    #[display("fax")]
    Fax,
}

#[doc = "The set of Boolean properties that indicate whether a phone number can receive calls or \
         messages.  Capabilities are  `Voice`, `SMS`, and `MMS` and each capability can be: `true` \
         or `false`."]
#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFreeCapabilities {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mms: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fax: Option<bool>,
}

impl std::fmt::Display
    for ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFreeCapabilities
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFreeCapabilities {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(mms) = &self.mms {
                format!("{mms:?}")
            } else {
                String::new()
            },
            if let Some(sms) = &self.sms {
                format!("{sms:?}")
            } else {
                String::new()
            },
            if let Some(voice) = &self.voice {
                format!("{voice:?}")
            } else {
                String::new()
            },
            if let Some(fax) = &self.fax {
                format!("{fax:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "mms".to_string(),
            "sms".to_string(),
            "voice".to_string(),
            "fax".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFree {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The SID of the Address resource associated with the phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address_sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address_requirements: Option<IncomingPhoneNumberTollFreeEnumAddressRequirement>,
    #[doc = "The API version used to start a new TwiML session."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "Whether the phone number is new to the Twilio platform. Can be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub beta: Option<bool>,
    #[doc = "The set of Boolean properties that indicate whether a phone number can receive calls \
             or messages.  Capabilities are  `Voice`, `SMS`, and `MMS` and each capability can \
             be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities:
        Option<ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFreeCapabilities>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The string that you assigned to describe the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The SID of the Identity resource that we associate with the phone number. Some \
             regions require an Identity to meet local regulations."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identity_sid: Option<String>,
    #[doc = "The phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, \
             which consists of a + followed by the country code and subscriber number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone_number: phone_number::PhoneNumber,
    #[doc = "The phone number's origin. `twilio` identifies Twilio-owned phone numbers and \
             `hosted` identifies hosted phone numbers."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub origin: Option<String>,
    #[doc = "The unique string that that we created to identify the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The SID of the application that handles SMS messages sent to the phone number. If an \
             `sms_application_sid` is present, we ignore all `sms_*_url` values and use those of \
             the application."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_application_sid: Option<String>,
    #[doc = "The HTTP method we use to call `sms_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_fallback_method: Option<SmsFallbackMethod>,
    #[doc = "The URL that we call when an error occurs while retrieving or executing the TwiML \
             from `sms_url`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_fallback_url: Option<String>,
    #[doc = "The HTTP method we use to call `sms_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_method: Option<SmsMethod>,
    #[doc = "The URL we call when the phone number receives an incoming SMS message."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_url: Option<String>,
    #[doc = "The URL we call using the `status_callback_method` to send status information to \
             your application."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status_callback: Option<String>,
    #[doc = "The HTTP method we use to call `status_callback`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status_callback_method: Option<StatusCallbackMethod>,
    #[doc = "The SID of the Trunk that handles calls to the phone number. If a `trunk_sid` is \
             present, we ignore all of the voice urls and voice applications and use those set on \
             the Trunk. Setting a `trunk_sid` will automatically delete your \
             `voice_application_sid` and vice versa."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub trunk_sid: Option<String>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_receive_mode: Option<IncomingPhoneNumberTollFreeEnumVoiceReceiveMode>,
    #[doc = "The SID of the application that handles calls to the phone number. If a \
             `voice_application_sid` is present, we ignore all of the voice urls and use those \
             set on the application. Setting a `voice_application_sid` will automatically delete \
             your `trunk_sid` and vice versa."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_application_sid: Option<String>,
    #[doc = "Whether we look up the caller's caller-ID name from the CNAM database ($0.01 per \
             look up). Can be: `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_caller_id_lookup: Option<bool>,
    #[doc = "The HTTP method we use to call `voice_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_fallback_method: Option<VoiceFallbackMethod>,
    #[doc = "The URL that we call when an error occurs retrieving or executing the TwiML \
             requested by `url`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_fallback_url: Option<String>,
    #[doc = "The HTTP method we use to call `voice_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_method: Option<VoiceMethod>,
    #[doc = "The URL we call when the phone number receives a call. The `voice_url` will not be \
             used if a `voice_application_sid` or a `trunk_sid` is set."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emergency_status: Option<IncomingPhoneNumberTollFreeEnumEmergencyStatus>,
    #[doc = "The SID of the emergency address configuration that we use for emergency calling \
             from this phone number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emergency_address_sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emergency_address_status: Option<IncomingPhoneNumberTollFreeEnumEmergencyAddressStatus>,
    #[doc = "The SID of the Bundle resource that you associate with the phone number. Some \
             regions require a Bundle to meet local Regulations."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bundle_sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFree {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFree {
    const LENGTH: usize = 34;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(address_sid) = &self.address_sid {
                format!("{address_sid:?}")
            } else {
                String::new()
            },
            if let Some(address_requirements) = &self.address_requirements {
                format!("{address_requirements:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(beta) = &self.beta {
                format!("{beta:?}")
            } else {
                String::new()
            },
            if let Some(capabilities) = &self.capabilities {
                format!("{capabilities:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(identity_sid) = &self.identity_sid {
                format!("{identity_sid:?}")
            } else {
                String::new()
            },
            format!("{:?}", self.phone_number),
            if let Some(origin) = &self.origin {
                format!("{origin:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(sms_application_sid) = &self.sms_application_sid {
                format!("{sms_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_method) = &self.sms_fallback_method {
                format!("{sms_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_url) = &self.sms_fallback_url {
                format!("{sms_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(sms_method) = &self.sms_method {
                format!("{sms_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_url) = &self.sms_url {
                format!("{sms_url:?}")
            } else {
                String::new()
            },
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(trunk_sid) = &self.trunk_sid {
                format!("{trunk_sid:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(voice_receive_mode) = &self.voice_receive_mode {
                format!("{voice_receive_mode:?}")
            } else {
                String::new()
            },
            if let Some(voice_application_sid) = &self.voice_application_sid {
                format!("{voice_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(voice_caller_id_lookup) = &self.voice_caller_id_lookup {
                format!("{voice_caller_id_lookup:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_method) = &self.voice_fallback_method {
                format!("{voice_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_url) = &self.voice_fallback_url {
                format!("{voice_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_method) = &self.voice_method {
                format!("{voice_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_url) = &self.voice_url {
                format!("{voice_url:?}")
            } else {
                String::new()
            },
            if let Some(emergency_status) = &self.emergency_status {
                format!("{emergency_status:?}")
            } else {
                String::new()
            },
            if let Some(emergency_address_sid) = &self.emergency_address_sid {
                format!("{emergency_address_sid:?}")
            } else {
                String::new()
            },
            if let Some(emergency_address_status) = &self.emergency_address_status {
                format!("{emergency_address_status:?}")
            } else {
                String::new()
            },
            if let Some(bundle_sid) = &self.bundle_sid {
                format!("{bundle_sid:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "address_sid".to_string(),
            "address_requirements".to_string(),
            "api_version".to_string(),
            "beta".to_string(),
            "capabilities".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "friendly_name".to_string(),
            "identity_sid".to_string(),
            "phone_number".to_string(),
            "origin".to_string(),
            "sid".to_string(),
            "sms_application_sid".to_string(),
            "sms_fallback_method".to_string(),
            "sms_fallback_url".to_string(),
            "sms_method".to_string(),
            "sms_url".to_string(),
            "status_callback".to_string(),
            "status_callback_method".to_string(),
            "trunk_sid".to_string(),
            "uri".to_string(),
            "voice_receive_mode".to_string(),
            "voice_application_sid".to_string(),
            "voice_caller_id_lookup".to_string(),
            "voice_fallback_method".to_string(),
            "voice_fallback_url".to_string(),
            "voice_method".to_string(),
            "voice_url".to_string(),
            "emergency_status".to_string(),
            "emergency_address_sid".to_string(),
            "emergency_address_status".to_string(),
            "bundle_sid".to_string(),
            "status".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum IncomingPhoneNumberTollFreeEnumAddressRequirement {
    #[serde(rename = "none")]
    #[display("none")]
    None,
    #[serde(rename = "any")]
    #[display("any")]
    Any,
    #[serde(rename = "local")]
    #[display("local")]
    Local,
    #[serde(rename = "foreign")]
    #[display("foreign")]
    Foreign,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum IncomingPhoneNumberTollFreeEnumEmergencyStatus {
    Active,
    Inactive,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum IncomingPhoneNumberTollFreeEnumEmergencyAddressStatus {
    #[serde(rename = "registered")]
    #[display("registered")]
    Registered,
    #[serde(rename = "unregistered")]
    #[display("unregistered")]
    Unregistered,
    #[serde(rename = "pending-registration")]
    #[display("pending-registration")]
    PendingRegistration,
    #[serde(rename = "registration-failure")]
    #[display("registration-failure")]
    RegistrationFailure,
    #[serde(rename = "pending-unregistration")]
    #[display("pending-unregistration")]
    PendingUnregistration,
    #[serde(rename = "unregistration-failure")]
    #[display("unregistration-failure")]
    UnregistrationFailure,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum IncomingPhoneNumberTollFreeEnumVoiceReceiveMode {
    #[serde(rename = "voice")]
    #[display("voice")]
    Voice,
    #[serde(rename = "fax")]
    #[display("fax")]
    Fax,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountKey {
    #[doc = "The unique string that that we created to identify the Key resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The string that you assigned to describe the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
}

impl std::fmt::Display for ApiV2010AccountKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountKey {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "sid".to_string(),
            "friendly_name".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountMessageMedia {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             this Media resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The default [mime-type](https://en.wikipedia.org/wiki/Internet_media_type) of the \
             media, for example `image/jpeg`, `image/png`, or `image/gif`"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_type: Option<String>,
    #[doc = "The date and time in GMT that this resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that this resource was last updated, specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The SID of the resource that created the media."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent_sid: Option<String>,
    #[doc = "The unique string that that we created to identify this Media resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The URI of this resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountMessageMedia {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountMessageMedia {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(content_type) = &self.content_type {
                format!("{content_type:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(parent_sid) = &self.parent_sid {
                format!("{parent_sid:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "content_type".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "parent_sid".to_string(),
            "sid".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountQueueMember {
    #[doc = "The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) the \
             Member resource is associated with."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub call_sid: Option<String>,
    #[doc = "The date that the member was enqueued, given in RFC 2822 format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_enqueued: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "This member's current position in the queue."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub position: Option<i64>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "The number of seconds the member has been in the queue."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wait_time: Option<i64>,
    #[doc = "The SID of the Queue the member is in."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub queue_sid: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountQueueMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountQueueMember {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(call_sid) = &self.call_sid {
                format!("{call_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_enqueued) = &self.date_enqueued {
                format!("{date_enqueued:?}")
            } else {
                String::new()
            },
            if let Some(position) = &self.position {
                format!("{position:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(wait_time) = &self.wait_time {
                format!("{wait_time:?}")
            } else {
                String::new()
            },
            if let Some(queue_sid) = &self.queue_sid {
                format!("{queue_sid:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "call_sid".to_string(),
            "date_enqueued".to_string(),
            "position".to_string(),
            "uri".to_string(),
            "wait_time".to_string(),
            "queue_sid".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountMessage {
    #[doc = "The message text. Can be up to 1,600 characters long."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    #[doc = "The number of segments that make up the complete message. A message body that is too \
             large to be sent in a single SMS message is segmented and charged as multiple \
             messages. Inbound messages over 160 characters are reassembled when the message is \
             received. Note: When using a Messaging Service to send messages, `num_segments` will \
             always be 0 in Twilio's response to your API request."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub num_segments: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub direction: Option<MessageEnumDirection>,
    #[doc = "The phone number (in [E.164](https://en.wikipedia.org/wiki/E.164) format), [alphanumeric sender ID](https://www.twilio.com/docs/sms/send-messages#use-an-alphanumeric-sender-id), or [Wireless SIM](https://www.twilio.com/docs/wireless/tutorials/communications-guides/how-to-send-and-receive-text-messages) that initiated the message. For incoming messages, this will be the number of the sending phone. For outgoing messages, this value will be one of your Twilio phone numbers or the alphanumeric sender ID used."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: phone_number::PhoneNumber,
    #[doc = "The phone number in [E.164](https://en.wikipedia.org/wiki/E.164) format that \
             received the message. For incoming messages, this will be one of your Twilio phone \
             numbers. For outgoing messages, this will be the sending phone."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<String>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The amount billed for the message, in the currency specified by `price_unit`.  Note \
             that your account is charged for each segment we send to the handset. Populated \
             after the message has been sent. May not be immediately available."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    #[doc = "The description of the `error_code` if your message `status` is `failed` or \
             `undelivered`. If the message was successful, this value is null."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error_message: Option<String>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that sent the \
             message that created the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The number of media files associated with the message. A message can send up to 10 \
             media files."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub num_media: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<MessageEnumStatus>,
    #[doc = "The SID of the [Messaging Service](https://www.twilio.com/docs/sms/services/api) \
             used with the message. The value is null if a Messaging Service was not used."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub messaging_service_sid: Option<String>,
    #[doc = "The unique string that that we created to identify the Message resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The date and time in GMT that the resource was sent specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format. For outgoing messages, this is when we sent the message. For incoming messages, this is when we made the HTTP request to your application. "]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_sent: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The error code returned if your message `status` is `failed` or `undelivered`. The \
             error_code provides more information about the failure. If the message was \
             successful, this value is null."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error_code: Option<i64>,
    #[doc = "The currency in which `price` is measured, in [ISO 4127](https://www.iso.org/iso/home/standards/currency_codes.htm) format (e.g. `usd`, `eur`, `jpy`)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price_unit: Option<String>,
    #[doc = "The API version used to process the message."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "A list of related resources identified by their URIs relative to `https://api.twilio.com`"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
}

impl std::fmt::Display for ApiV2010AccountMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountMessage {
    const LENGTH: usize = 20;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(body) = &self.body {
                format!("{body:?}")
            } else {
                String::new()
            },
            if let Some(num_segments) = &self.num_segments {
                format!("{num_segments:?}")
            } else {
                String::new()
            },
            if let Some(direction) = &self.direction {
                format!("{direction:?}")
            } else {
                String::new()
            },
            format!("{:?}", self.from),
            if let Some(to) = &self.to {
                format!("{to:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(price) = &self.price {
                format!("{price:?}")
            } else {
                String::new()
            },
            if let Some(error_message) = &self.error_message {
                format!("{error_message:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(num_media) = &self.num_media {
                format!("{num_media:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
            if let Some(messaging_service_sid) = &self.messaging_service_sid {
                format!("{messaging_service_sid:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(date_sent) = &self.date_sent {
                format!("{date_sent:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(error_code) = &self.error_code {
                format!("{error_code:?}")
            } else {
                String::new()
            },
            if let Some(price_unit) = &self.price_unit {
                format!("{price_unit:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "body".to_string(),
            "num_segments".to_string(),
            "direction".to_string(),
            "from".to_string(),
            "to".to_string(),
            "date_updated".to_string(),
            "price".to_string(),
            "error_message".to_string(),
            "uri".to_string(),
            "account_sid".to_string(),
            "num_media".to_string(),
            "status".to_string(),
            "messaging_service_sid".to_string(),
            "sid".to_string(),
            "date_sent".to_string(),
            "date_created".to_string(),
            "error_code".to_string(),
            "price_unit".to_string(),
            "api_version".to_string(),
            "subresource_uris".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum MessageEnumStatus {
    #[serde(rename = "queued")]
    #[display("queued")]
    Queued,
    #[serde(rename = "sending")]
    #[display("sending")]
    Sending,
    #[serde(rename = "sent")]
    #[display("sent")]
    Sent,
    #[serde(rename = "failed")]
    #[display("failed")]
    Failed,
    #[serde(rename = "delivered")]
    #[display("delivered")]
    Delivered,
    #[serde(rename = "undelivered")]
    #[display("undelivered")]
    Undelivered,
    #[serde(rename = "receiving")]
    #[display("receiving")]
    Receiving,
    #[serde(rename = "received")]
    #[display("received")]
    Received,
    #[serde(rename = "accepted")]
    #[display("accepted")]
    Accepted,
    #[serde(rename = "scheduled")]
    #[display("scheduled")]
    Scheduled,
    #[serde(rename = "read")]
    #[display("read")]
    Read,
    #[serde(rename = "partially_delivered")]
    #[display("partially_delivered")]
    PartiallyDelivered,
    #[serde(rename = "canceled")]
    #[display("canceled")]
    Canceled,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum MessageEnumUpdateStatus {
    #[serde(rename = "canceled")]
    #[display("canceled")]
    Canceled,
}

impl std::default::Default for MessageEnumUpdateStatus {
    fn default() -> Self {
        MessageEnumUpdateStatus::Canceled
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum MessageEnumDirection {
    #[serde(rename = "inbound")]
    #[display("inbound")]
    Inbound,
    #[serde(rename = "outbound-api")]
    #[display("outbound-api")]
    OutboundApi,
    #[serde(rename = "outbound-call")]
    #[display("outbound-call")]
    OutboundCall,
    #[serde(rename = "outbound-reply")]
    #[display("outbound-reply")]
    OutboundReply,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum MessageEnumContentRetention {
    #[serde(rename = "retain")]
    #[display("retain")]
    Retain,
}

impl std::default::Default for MessageEnumContentRetention {
    fn default() -> Self {
        MessageEnumContentRetention::Retain
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum MessageEnumAddressRetention {
    #[serde(rename = "retain")]
    #[display("retain")]
    Retain,
}

impl std::default::Default for MessageEnumAddressRetention {
    fn default() -> Self {
        MessageEnumAddressRetention::Retain
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum MessageEnumTrafficType {
    #[serde(rename = "free")]
    #[display("free")]
    Free,
}

impl std::default::Default for MessageEnumTrafficType {
    fn default() -> Self {
        MessageEnumTrafficType::Free
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum MessageEnumScheduleType {
    #[serde(rename = "fixed")]
    #[display("fixed")]
    Fixed,
}

impl std::default::Default for MessageEnumScheduleType {
    fn default() -> Self {
        MessageEnumScheduleType::Fixed
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountMessageMessageFeedback {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the MessageFeedback resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The SID of the Message resource for which the feedback was provided."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message_sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub outcome: Option<MessageFeedbackEnumOutcome>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountMessageMessageFeedback {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountMessageMessageFeedback {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(message_sid) = &self.message_sid {
                format!("{message_sid:?}")
            } else {
                String::new()
            },
            if let Some(outcome) = &self.outcome {
                format!("{outcome:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "message_sid".to_string(),
            "outcome".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum MessageFeedbackEnumOutcome {
    #[serde(rename = "confirmed")]
    #[display("confirmed")]
    Confirmed,
    #[serde(rename = "unconfirmed")]
    #[display("unconfirmed")]
    Unconfirmed,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountNewKey {
    #[doc = "The unique string that that we created to identify the NewKey resource. You will use \
             this as the basic-auth `user` when authenticating to the API."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The string that you assigned to describe the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The date and time in GMT that the API Key was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the new API Key was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The secret your application uses to sign Access Tokens and to authenticate to the \
             REST API (you will use this as the basic-auth `password`).  **Note that for security \
             reasons, this field is ONLY returned when the API Key is first created.**"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountNewKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountNewKey {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(secret) = &self.secret {
                format!("{secret:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "sid".to_string(),
            "friendly_name".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "secret".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountNewSigningKey {
    #[doc = "The unique string that that we created to identify the NewSigningKey resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The string that you assigned to describe the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The secret your application uses to sign Access Tokens and to authenticate to the \
             REST API (you will use this as the basic-auth `password`).  **Note that for security \
             reasons, this field is ONLY returned when the API Key is first created.**"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountNewSigningKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountNewSigningKey {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(secret) = &self.secret {
                format!("{secret:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "sid".to_string(),
            "friendly_name".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "secret".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountNotification {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the Notification resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to generate the notification. Can be empty for events that \
             don't have a specific API version, such as incoming phone calls."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) the \
             Notification resource is associated with."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub call_sid: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "A unique error code for the error condition that is described in our [Error Dictionary](https://www.twilio.com/docs/api/errors)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error_code: Option<String>,
    #[doc = "An integer log level that corresponds to the type of notification: `0` is ERROR, `1` \
             is WARNING."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub log: Option<String>,
    #[doc = "The date the notification was actually generated in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format. Message buffering can cause this value to differ from `date_created`."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub message_date: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The text of the notification."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message_text: Option<String>,
    #[doc = "The URL for more information about the error condition. This value is a page in our [Error Dictionary](https://www.twilio.com/docs/api/errors)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub more_info: Option<String>,
    #[doc = "The HTTP method used to generate the notification. If the notification was generated \
             during a phone call, this is the HTTP Method used to request the resource on your \
             server. If the notification was generated by your use of our REST API, this is the \
             HTTP method used to call the resource on our servers."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_method: Option<RequestMethod>,
    #[doc = "The URL of the resource that generated the notification. If the notification was \
             generated during a phone call, this is the URL of the resource on your server that \
             caused the notification. If the notification was generated by your use of our REST \
             API, this is the URL of the resource you called."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_url: Option<String>,
    #[doc = "The unique string that that we created to identify the Notification resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountNotification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountNotification {
    const LENGTH: usize = 14;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(call_sid) = &self.call_sid {
                format!("{call_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(error_code) = &self.error_code {
                format!("{error_code:?}")
            } else {
                String::new()
            },
            if let Some(log) = &self.log {
                format!("{log:?}")
            } else {
                String::new()
            },
            if let Some(message_date) = &self.message_date {
                format!("{message_date:?}")
            } else {
                String::new()
            },
            if let Some(message_text) = &self.message_text {
                format!("{message_text:?}")
            } else {
                String::new()
            },
            if let Some(more_info) = &self.more_info {
                format!("{more_info:?}")
            } else {
                String::new()
            },
            if let Some(request_method) = &self.request_method {
                format!("{request_method:?}")
            } else {
                String::new()
            },
            if let Some(request_url) = &self.request_url {
                format!("{request_url:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "call_sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "error_code".to_string(),
            "log".to_string(),
            "message_date".to_string(),
            "message_text".to_string(),
            "more_info".to_string(),
            "request_method".to_string(),
            "request_url".to_string(),
            "sid".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountNotificationInstance {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the Notification resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to generate the notification. Can be empty for events that \
             don't have a specific API version, such as incoming phone calls."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) the \
             Notification resource is associated with."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub call_sid: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "A unique error code for the error condition that is described in our [Error Dictionary](https://www.twilio.com/docs/api/errors)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error_code: Option<String>,
    #[doc = "An integer log level that corresponds to the type of notification: `0` is ERROR, `1` \
             is WARNING."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub log: Option<String>,
    #[doc = "The date the notification was actually generated in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format. Message buffering can cause this value to differ from `date_created`."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub message_date: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The text of the notification."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message_text: Option<String>,
    #[doc = "The URL for more information about the error condition. This value is a page in our [Error Dictionary](https://www.twilio.com/docs/api/errors)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub more_info: Option<String>,
    #[doc = "The HTTP method used to generate the notification. If the notification was generated \
             during a phone call, this is the HTTP Method used to request the resource on your \
             server. If the notification was generated by your use of our REST API, this is the \
             HTTP method used to call the resource on our servers."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_method: Option<RequestMethod>,
    #[doc = "The URL of the resource that generated the notification. If the notification was \
             generated during a phone call, this is the URL of the resource on your server that \
             caused the notification. If the notification was generated by your use of our REST \
             API, this is the URL of the resource you called."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_url: Option<String>,
    #[doc = "The HTTP GET or POST variables we sent to your server. However, if the notification \
             was generated by our REST API, this contains the HTTP POST or PUT variables you sent \
             to our API."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request_variables: Option<String>,
    #[doc = "The HTTP body returned by your server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response_body: Option<String>,
    #[doc = "The HTTP headers returned by your server."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response_headers: Option<String>,
    #[doc = "The unique string that that we created to identify the Notification resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountNotificationInstance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountNotificationInstance {
    const LENGTH: usize = 17;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(call_sid) = &self.call_sid {
                format!("{call_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(error_code) = &self.error_code {
                format!("{error_code:?}")
            } else {
                String::new()
            },
            if let Some(log) = &self.log {
                format!("{log:?}")
            } else {
                String::new()
            },
            if let Some(message_date) = &self.message_date {
                format!("{message_date:?}")
            } else {
                String::new()
            },
            if let Some(message_text) = &self.message_text {
                format!("{message_text:?}")
            } else {
                String::new()
            },
            if let Some(more_info) = &self.more_info {
                format!("{more_info:?}")
            } else {
                String::new()
            },
            if let Some(request_method) = &self.request_method {
                format!("{request_method:?}")
            } else {
                String::new()
            },
            if let Some(request_url) = &self.request_url {
                format!("{request_url:?}")
            } else {
                String::new()
            },
            if let Some(request_variables) = &self.request_variables {
                format!("{request_variables:?}")
            } else {
                String::new()
            },
            if let Some(response_body) = &self.response_body {
                format!("{response_body:?}")
            } else {
                String::new()
            },
            if let Some(response_headers) = &self.response_headers {
                format!("{response_headers:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "call_sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "error_code".to_string(),
            "log".to_string(),
            "message_date".to_string(),
            "message_text".to_string(),
            "more_info".to_string(),
            "request_method".to_string(),
            "request_url".to_string(),
            "request_variables".to_string(),
            "response_body".to_string(),
            "response_headers".to_string(),
            "sid".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountOutgoingCallerId {
    #[doc = "The unique string that that we created to identify the OutgoingCallerId resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The string that you assigned to describe the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the OutgoingCallerId resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, \
             which consists of a + followed by the country code and subscriber number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone_number: phone_number::PhoneNumber,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountOutgoingCallerId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountOutgoingCallerId {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            format!("{:?}", self.phone_number),
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "friendly_name".to_string(),
            "account_sid".to_string(),
            "phone_number".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountConferenceParticipant {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the Participant resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) the \
             Participant resource is associated with."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub call_sid: Option<String>,
    #[doc = "The user-specified label of this participant, if one was given when the participant \
             was created. This may be used to fetch, update or delete the participant."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    #[doc = "The SID of the participant who is being `coached`. The participant being coached is \
             the only participant who can hear the participant who is `coaching`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub call_sid_to_coach: Option<String>,
    #[doc = "Whether the participant is coaching another call. Can be: `true` or `false`. If not \
             present, defaults to `false` unless `call_sid_to_coach` is defined. If `true`, \
             `call_sid_to_coach` must be defined."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub coaching: Option<bool>,
    #[doc = "The SID of the conference the participant is in."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conference_sid: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "Whether the conference ends when the participant leaves. Can be: `true` or `false` \
             and the default is `false`. If `true`, the conference ends and all other \
             participants drop out when the participant leaves."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_conference_on_exit: Option<bool>,
    #[doc = "Whether the participant is muted. Can be `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub muted: Option<bool>,
    #[doc = "Whether the participant is on hold. Can be `true` or `false`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hold: Option<bool>,
    #[doc = "Whether the conference starts when the participant joins the conference, if it has \
             not already started. Can be: `true` or `false` and the default is `true`. If `false` \
             and the conference has not started, the participant is muted and hears background \
             music until another participant starts the conference."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_conference_on_enter: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<ParticipantEnumStatus>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountConferenceParticipant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountConferenceParticipant {
    const LENGTH: usize = 14;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(call_sid) = &self.call_sid {
                format!("{call_sid:?}")
            } else {
                String::new()
            },
            if let Some(label) = &self.label {
                format!("{label:?}")
            } else {
                String::new()
            },
            if let Some(call_sid_to_coach) = &self.call_sid_to_coach {
                format!("{call_sid_to_coach:?}")
            } else {
                String::new()
            },
            if let Some(coaching) = &self.coaching {
                format!("{coaching:?}")
            } else {
                String::new()
            },
            if let Some(conference_sid) = &self.conference_sid {
                format!("{conference_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(end_conference_on_exit) = &self.end_conference_on_exit {
                format!("{end_conference_on_exit:?}")
            } else {
                String::new()
            },
            if let Some(muted) = &self.muted {
                format!("{muted:?}")
            } else {
                String::new()
            },
            if let Some(hold) = &self.hold {
                format!("{hold:?}")
            } else {
                String::new()
            },
            if let Some(start_conference_on_enter) = &self.start_conference_on_enter {
                format!("{start_conference_on_enter:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "call_sid".to_string(),
            "label".to_string(),
            "call_sid_to_coach".to_string(),
            "coaching".to_string(),
            "conference_sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "end_conference_on_exit".to_string(),
            "muted".to_string(),
            "hold".to_string(),
            "start_conference_on_enter".to_string(),
            "status".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum ParticipantEnumStatus {
    #[serde(rename = "queued")]
    #[display("queued")]
    Queued,
    #[serde(rename = "connecting")]
    #[display("connecting")]
    Connecting,
    #[serde(rename = "ringing")]
    #[display("ringing")]
    Ringing,
    #[serde(rename = "connected")]
    #[display("connected")]
    Connected,
    #[serde(rename = "complete")]
    #[display("complete")]
    Complete,
    #[serde(rename = "failed")]
    #[display("failed")]
    Failed,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountCallPayments {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the Payments resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) the \
             Payments resource is associated with. This will refer to the call sid that is \
             producing the payment card (credit/ACH) information thru DTMF."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub call_sid: Option<String>,
    #[doc = "The SID of the Payments resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountCallPayments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountCallPayments {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(call_sid) = &self.call_sid {
                format!("{call_sid:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "call_sid".to_string(),
            "sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum PaymentsEnumPaymentMethod {
    #[serde(rename = "credit-card")]
    #[display("credit-card")]
    CreditCard,
    #[serde(rename = "ach-debit")]
    #[display("ach-debit")]
    AchDebit,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum PaymentsEnumBankAccountType {
    #[serde(rename = "consumer-checking")]
    #[display("consumer-checking")]
    ConsumerChecking,
    #[serde(rename = "consumer-savings")]
    #[display("consumer-savings")]
    ConsumerSavings,
    #[serde(rename = "commercial-checking")]
    #[display("commercial-checking")]
    CommercialChecking,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum PaymentsEnumTokenType {
    #[serde(rename = "one-time")]
    #[display("one-time")]
    OneTime,
    #[serde(rename = "reusable")]
    #[display("reusable")]
    Reusable,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum PaymentsEnumCapture {
    #[serde(rename = "payment-card-number")]
    #[display("payment-card-number")]
    PaymentCardNumber,
    #[serde(rename = "expiration-date")]
    #[display("expiration-date")]
    ExpirationDate,
    #[serde(rename = "security-code")]
    #[display("security-code")]
    SecurityCode,
    #[serde(rename = "postal-code")]
    #[display("postal-code")]
    PostalCode,
    #[serde(rename = "bank-routing-number")]
    #[display("bank-routing-number")]
    BankRoutingNumber,
    #[serde(rename = "bank-account-number")]
    #[display("bank-account-number")]
    BankAccountNumber,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum PaymentsEnumStatus {
    #[serde(rename = "complete")]
    #[display("complete")]
    Complete,
    #[serde(rename = "cancel")]
    #[display("cancel")]
    Cancel,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountQueue {
    #[doc = "The date and time in GMT that this resource was last updated, specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The number of calls currently in the queue."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub current_size: Option<i64>,
    #[doc = "A string that you assigned to describe this resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The URI of this resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             this Queue resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = " The average wait time in seconds of the members in this queue. This is calculated \
             at the time of the request."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub average_wait_time: Option<i64>,
    #[doc = "The unique string that that we created to identify this Queue resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The date and time in GMT that this resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = " The maximum number of calls that can be in the queue. The default is 100 and the \
             maximum is 5000."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max_size: Option<i64>,
}

impl std::fmt::Display for ApiV2010AccountQueue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountQueue {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(current_size) = &self.current_size {
                format!("{current_size:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(average_wait_time) = &self.average_wait_time {
                format!("{average_wait_time:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(max_size) = &self.max_size {
                format!("{max_size:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "date_updated".to_string(),
            "current_size".to_string(),
            "friendly_name".to_string(),
            "uri".to_string(),
            "account_sid".to_string(),
            "average_wait_time".to_string(),
            "sid".to_string(),
            "date_created".to_string(),
            "max_size".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountRecording {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the Recording resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used during the recording."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) the \
             Recording resource is associated with. This will always refer to the parent leg of a \
             two-leg call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub call_sid: Option<String>,
    #[doc = "The Conference SID that identifies the conference associated with the recording, if \
             a conference recording."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conference_sid: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The start time of the recording in GMT and in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub start_time: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The length of the recording in seconds."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    #[doc = "The unique string that that we created to identify the Recording resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The one-time cost of creating the recording in the `price_unit` currency."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    #[doc = "The currency used in the `price` property. Example: `USD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price_unit: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<RecordingEnumStatus>,
    #[doc = "The number of channels in the final recording file. Can be: `1` or `2`. You can split a call with two legs into two separate recording channels if you record using [TwiML Dial](https://www.twilio.com/docs/voice/twiml/dial#record) or the [Outbound Rest API](https://www.twilio.com/docs/voice/make-calls#manage-your-outbound-call)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channels: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<RecordingEnumSource>,
    #[doc = "The error code that describes why the recording is `absent`. The error code is described in our [Error Dictionary](https://www.twilio.com/docs/api/errors). This value is null if the recording `status` is not `absent`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error_code: Option<i64>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "How to decrypt the recording if it was encrypted using [Call Recording Encryption](https://www.twilio.com/docs/voice/tutorials/voice-recording-encryption) feature."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encryption_details: Option<serde_json::Value>,
    #[doc = "A list of related resources identified by their relative URIs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
    #[doc = "The URL of the media file associated with this recording resource. When stored \
             externally, this is the full URL location of the media file."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub media_url: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountRecording {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountRecording {
    const LENGTH: usize = 19;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(call_sid) = &self.call_sid {
                format!("{call_sid:?}")
            } else {
                String::new()
            },
            if let Some(conference_sid) = &self.conference_sid {
                format!("{conference_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(start_time) = &self.start_time {
                format!("{start_time:?}")
            } else {
                String::new()
            },
            if let Some(duration) = &self.duration {
                format!("{duration:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(price) = &self.price {
                format!("{price:?}")
            } else {
                String::new()
            },
            if let Some(price_unit) = &self.price_unit {
                format!("{price_unit:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
            if let Some(channels) = &self.channels {
                format!("{channels:?}")
            } else {
                String::new()
            },
            if let Some(source) = &self.source {
                format!("{source:?}")
            } else {
                String::new()
            },
            if let Some(error_code) = &self.error_code {
                format!("{error_code:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(encryption_details) = &self.encryption_details {
                format!("{encryption_details:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
            if let Some(media_url) = &self.media_url {
                format!("{media_url:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "call_sid".to_string(),
            "conference_sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "start_time".to_string(),
            "duration".to_string(),
            "sid".to_string(),
            "price".to_string(),
            "price_unit".to_string(),
            "status".to_string(),
            "channels".to_string(),
            "source".to_string(),
            "error_code".to_string(),
            "uri".to_string(),
            "encryption_details".to_string(),
            "subresource_uris".to_string(),
            "media_url".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum RecordingEnumStatus {
    #[serde(rename = "in-progress")]
    #[display("in-progress")]
    InProgress,
    #[serde(rename = "paused")]
    #[display("paused")]
    Paused,
    #[serde(rename = "stopped")]
    #[display("stopped")]
    Stopped,
    #[serde(rename = "processing")]
    #[display("processing")]
    Processing,
    #[serde(rename = "completed")]
    #[display("completed")]
    Completed,
    #[serde(rename = "absent")]
    #[display("absent")]
    Absent,
    #[serde(rename = "deleted")]
    #[display("deleted")]
    Deleted,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum RecordingEnumSource {
    DialVerb,
    Conference,
    OutboundAPI,
    Trunking,
    RecordVerb,
    StartCallRecordingAPI,
    StartConferenceRecordingAPI,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountRecordingRecordingAddOnResult {
    #[doc = "The unique string that that we created to identify the Recording AddOnResult \
             resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the Recording AddOnResult resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<RecordingAddOnResultEnumStatus>,
    #[doc = "The SID of the Add-on to which the result belongs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add_on_sid: Option<String>,
    #[doc = "The SID of the Add-on configuration."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add_on_configuration_sid: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the result was completed specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_completed: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The SID of the recording to which the AddOnResult resource belongs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reference_sid: Option<String>,
    #[doc = "A list of related resources identified by their relative URIs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
}

impl std::fmt::Display for ApiV2010AccountRecordingRecordingAddOnResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountRecordingRecordingAddOnResult {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
            if let Some(add_on_sid) = &self.add_on_sid {
                format!("{add_on_sid:?}")
            } else {
                String::new()
            },
            if let Some(add_on_configuration_sid) = &self.add_on_configuration_sid {
                format!("{add_on_configuration_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(date_completed) = &self.date_completed {
                format!("{date_completed:?}")
            } else {
                String::new()
            },
            if let Some(reference_sid) = &self.reference_sid {
                format!("{reference_sid:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "sid".to_string(),
            "account_sid".to_string(),
            "status".to_string(),
            "add_on_sid".to_string(),
            "add_on_configuration_sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "date_completed".to_string(),
            "reference_sid".to_string(),
            "subresource_uris".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum RecordingAddOnResultEnumStatus {
    #[serde(rename = "canceled")]
    #[display("canceled")]
    Canceled,
    #[serde(rename = "completed")]
    #[display("completed")]
    Completed,
    #[serde(rename = "deleted")]
    #[display("deleted")]
    Deleted,
    #[serde(rename = "failed")]
    #[display("failed")]
    Failed,
    #[serde(rename = "in-progress")]
    #[display("in-progress")]
    InProgress,
    #[serde(rename = "init")]
    #[display("init")]
    Init,
    #[serde(rename = "processing")]
    #[display("processing")]
    Processing,
    #[serde(rename = "queued")]
    #[display("queued")]
    Queued,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountRecordingRecordingAddOnResultRecordingAddOnResultPayload {
    #[doc = "The unique string that that we created to identify the Recording AddOnResult Payload \
             resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The SID of the AddOnResult to which the payload belongs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add_on_result_sid: Option<String>,
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the Recording AddOnResult Payload resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The string provided by the vendor that describes the payload."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    #[doc = "The SID of the Add-on to which the result belongs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add_on_sid: Option<String>,
    #[doc = "The SID of the Add-on configuration."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add_on_configuration_sid: Option<String>,
    #[doc = "The MIME type of the payload."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_type: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The SID of the recording to which the AddOnResult resource that contains the payload \
             belongs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reference_sid: Option<String>,
    #[doc = "A list of related resources identified by their relative URIs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
}

impl std::fmt::Display for ApiV2010AccountRecordingRecordingAddOnResultRecordingAddOnResultPayload {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountRecordingRecordingAddOnResultRecordingAddOnResultPayload {
    const LENGTH: usize = 11;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(add_on_result_sid) = &self.add_on_result_sid {
                format!("{add_on_result_sid:?}")
            } else {
                String::new()
            },
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(label) = &self.label {
                format!("{label:?}")
            } else {
                String::new()
            },
            if let Some(add_on_sid) = &self.add_on_sid {
                format!("{add_on_sid:?}")
            } else {
                String::new()
            },
            if let Some(add_on_configuration_sid) = &self.add_on_configuration_sid {
                format!("{add_on_configuration_sid:?}")
            } else {
                String::new()
            },
            if let Some(content_type) = &self.content_type {
                format!("{content_type:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(reference_sid) = &self.reference_sid {
                format!("{reference_sid:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "sid".to_string(),
            "add_on_result_sid".to_string(),
            "account_sid".to_string(),
            "label".to_string(),
            "add_on_sid".to_string(),
            "add_on_configuration_sid".to_string(),
            "content_type".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "reference_sid".to_string(),
            "subresource_uris".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountRecordingRecordingTranscription {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the Transcription resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to create the transcription."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The duration of the transcribed audio in seconds."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    #[doc = "The charge for the transcript in the currency associated with the account. This \
             value is populated after the transcript is complete so it may not be available \
             immediately."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<f64>,
    #[doc = "The currency in which `price` is measured, in [ISO 4127](https://www.iso.org/iso/home/standards/currency_codes.htm) format (e.g. `usd`, `eur`, `jpy`)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price_unit: Option<String>,
    #[doc = "The SID of the [Recording](https://www.twilio.com/docs/voice/api/recording) from \
             which the transcription was created."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub recording_sid: Option<String>,
    #[doc = "The unique string that that we created to identify the Transcription resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<RecordingTranscriptionEnumStatus>,
    #[doc = "The text content of the transcription."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub transcription_text: Option<String>,
    #[doc = "The transcription type."]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountRecordingRecordingTranscription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountRecordingRecordingTranscription {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(duration) = &self.duration {
                format!("{duration:?}")
            } else {
                String::new()
            },
            if let Some(price) = &self.price {
                format!("{price:?}")
            } else {
                String::new()
            },
            if let Some(price_unit) = &self.price_unit {
                format!("{price_unit:?}")
            } else {
                String::new()
            },
            if let Some(recording_sid) = &self.recording_sid {
                format!("{recording_sid:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
            if let Some(transcription_text) = &self.transcription_text {
                format!("{transcription_text:?}")
            } else {
                String::new()
            },
            if let Some(type_) = &self.type_ {
                format!("{type_:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "duration".to_string(),
            "price".to_string(),
            "price_unit".to_string(),
            "recording_sid".to_string(),
            "sid".to_string(),
            "status".to_string(),
            "transcription_text".to_string(),
            "type_".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum RecordingTranscriptionEnumStatus {
    #[serde(rename = "in-progress")]
    #[display("in-progress")]
    InProgress,
    #[serde(rename = "completed")]
    #[display("completed")]
    Completed,
    #[serde(rename = "failed")]
    #[display("failed")]
    Failed,
}

#[doc = "The HTTP method we use to call the `sms_fallback_url`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum ApiV2010AccountShortCodeSmsFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we use to call the `sms_url`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum ApiV2010AccountShortCodeSmsMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountShortCode {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             this ShortCode resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to start a new TwiML session when an SMS message is sent to \
             this short code."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "The date and time in GMT that this resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that this resource was last updated, specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "A string that you assigned to describe this resource. By default, the `FriendlyName` \
             is the short code."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The short code. e.g., 894546."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub short_code: Option<String>,
    #[doc = "The unique string that that we created to identify this ShortCode resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The HTTP method we use to call the `sms_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_fallback_method: Option<ApiV2010AccountShortCodeSmsFallbackMethod>,
    #[doc = "The URL that we call if an error occurs while retrieving or executing the TwiML from \
             `sms_url`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_fallback_url: Option<String>,
    #[doc = "The HTTP method we use to call the `sms_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_method: Option<ApiV2010AccountShortCodeSmsMethod>,
    #[doc = "The URL we call when receiving an incoming SMS message to this short code."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sms_url: Option<String>,
    #[doc = "The URI of this resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountShortCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountShortCode {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(short_code) = &self.short_code {
                format!("{short_code:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_method) = &self.sms_fallback_method {
                format!("{sms_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_url) = &self.sms_fallback_url {
                format!("{sms_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(sms_method) = &self.sms_method {
                format!("{sms_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_url) = &self.sms_url {
                format!("{sms_url:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "friendly_name".to_string(),
            "short_code".to_string(),
            "sid".to_string(),
            "sms_fallback_method".to_string(),
            "sms_fallback_url".to_string(),
            "sms_method".to_string(),
            "sms_url".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountSigningKey {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
}

impl std::fmt::Display for ApiV2010AccountSigningKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountSigningKey {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "sid".to_string(),
            "friendly_name".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountSip {}

impl std::fmt::Display for ApiV2010AccountSip {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountSip {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<String> {
        vec![]
    }

    fn headers() -> Vec<String> {
        vec![]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountSipSipDomainSipAuth {}

impl std::fmt::Display for ApiV2010AccountSipSipDomainSipAuth {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountSipSipDomainSipAuth {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<String> {
        vec![]
    }

    fn headers() -> Vec<String> {
        vec![]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountSipSipDomainSipAuthSipAuthCalls {}

impl std::fmt::Display for ApiV2010AccountSipSipDomainSipAuthSipAuthCalls {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountSipSipDomainSipAuthSipAuthCalls {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<String> {
        vec![]
    }

    fn headers() -> Vec<String> {
        vec![]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the CredentialListMapping resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The string that you assigned to describe the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The unique string that that we created to identify the CredentialListMapping \
             resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
}

impl std::fmt::Display
    for ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled
    for ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping
{
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "friendly_name".to_string(),
            "sid".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the IpAccessControlListMapping resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The string that you assigned to describe the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The unique string that that we created to identify the IpAccessControlListMapping \
             resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
}

impl std::fmt::Display
    for ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled
    for ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping
{
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "friendly_name".to_string(),
            "sid".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrations {}

impl std::fmt::Display for ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrations {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<String> {
        vec![]
    }

    fn headers() -> Vec<String> {
        vec![]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping
{
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the CredentialListMapping resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The string that you assigned to describe the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The unique string that that we created to identify the CredentialListMapping \
             resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
}

impl std :: fmt :: Display for ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping { fn fmt (& self , f : & mut std :: fmt :: Formatter < '_ >) -> Result < () , std :: fmt :: Error > { write ! (f , "{}" , serde_json :: to_string_pretty (self) . map_err (| _ | std :: fmt :: Error) ?) } }

impl tabled :: Tabled for ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping { const LENGTH : usize = 5 ; fn fields (& self) -> Vec < String > { vec ! [if let Some (account_sid) = & self . account_sid { format ! ("{account_sid:?}" ) } else { String :: new () } , if let Some (date_created) = & self . date_created { format ! ("{date_created:?}" ) } else { String :: new () } , if let Some (date_updated) = & self . date_updated { format ! ("{date_updated:?}" ) } else { String :: new () } , if let Some (friendly_name) = & self . friendly_name { format ! ("{friendly_name:?}" ) } else { String :: new () } , if let Some (sid) = & self . sid { format ! ("{sid:?}" ) } else { String :: new () }] } fn headers () -> Vec < String > { vec ! ["account_sid" . to_string () , "date_created" . to_string () , "date_updated" . to_string () , "friendly_name" . to_string () , "sid" . to_string ()] } }

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountSipSipCredentialListSipCredential {
    #[doc = "A 34 character string that uniquely identifies this resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The unique id of the Account that is responsible for this resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The unique id that identifies the credential list that includes this credential."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credential_list_sid: Option<String>,
    #[doc = "The username for this credential."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
    #[doc = "The date that this resource was created, given as GMT in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date that this resource was last updated, given as GMT in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The URI for this resource, relative to `https://api.twilio.com`"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountSipSipCredentialListSipCredential {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountSipSipCredentialListSipCredential {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(credential_list_sid) = &self.credential_list_sid {
                format!("{credential_list_sid:?}")
            } else {
                String::new()
            },
            if let Some(username) = &self.username {
                format!("{username:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "sid".to_string(),
            "account_sid".to_string(),
            "credential_list_sid".to_string(),
            "username".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountSipSipCredentialList {
    #[doc = "The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) that \
             owns this resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The date that this resource was created, given as GMT in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date that this resource was last updated, given as GMT in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "A human readable descriptive text that describes the CredentialList, up to 64 \
             characters long."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "A 34 character string that uniquely identifies this resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "A list of credentials associated with this credential list."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
    #[doc = "The URI for this resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountSipSipCredentialList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountSipSipCredentialList {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "friendly_name".to_string(),
            "sid".to_string(),
            "subresource_uris".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountSipSipDomainSipCredentialListMapping {
    #[doc = "The unique id of the Account that is responsible for this resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The date that this resource was created, given as GMT in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date that this resource was last updated, given as GMT in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The unique string that is created to identify the SipDomain resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain_sid: Option<String>,
    #[doc = "A human readable descriptive text for this resource, up to 64 characters long."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "A 34 character string that uniquely identifies this resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The URI for this resource, relative to `https://api.twilio.com`"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountSipSipDomainSipCredentialListMapping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountSipSipDomainSipCredentialListMapping {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(domain_sid) = &self.domain_sid {
                format!("{domain_sid:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "domain_sid".to_string(),
            "friendly_name".to_string(),
            "sid".to_string(),
            "uri".to_string(),
        ]
    }
}

#[doc = "The HTTP method we use to call `voice_status_callback_url`. Either `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum VoiceStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountSipSipDomain {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the SipDomain resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to process the call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "The types of authentication you have mapped to your domain. Can be: `IP_ACL` and \
             `CREDENTIAL_LIST`. If you have both defined for your domain, both will be returned \
             in a comma delimited string. If `auth_type` is not defined, the domain will not be \
             able to receive any traffic."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth_type: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The unique address you reserve on Twilio to which you route your SIP traffic. Domain \
             names can contain letters, digits, and \"-\" and must end with `sip.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain_name: Option<String>,
    #[doc = "The string that you assigned to describe the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The unique string that that we created to identify the SipDomain resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "The HTTP method we use to call `voice_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_fallback_method: Option<VoiceFallbackMethod>,
    #[doc = "The URL that we call when an error occurs while retrieving or executing the TwiML \
             requested from `voice_url`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_fallback_url: Option<String>,
    #[doc = "The HTTP method we use to call `voice_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_method: Option<VoiceMethod>,
    #[doc = "The HTTP method we use to call `voice_status_callback_url`. Either `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_status_callback_method: Option<VoiceStatusCallbackMethod>,
    #[doc = "The URL that we call to pass status parameters (such as call ended) to your \
             application."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_status_callback_url: Option<String>,
    #[doc = "The URL we call using the `voice_method` when the domain receives a call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub voice_url: Option<String>,
    #[doc = "A list of mapping resources associated with the SIP Domain resource identified by \
             their relative URIs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
    #[doc = "Whether to allow SIP Endpoints to register with the domain to receive calls."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sip_registration: Option<bool>,
    #[doc = "Whether emergency calling is enabled for the domain. If enabled, allows emergency \
             calls on the domain from phone numbers with validated addresses."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emergency_calling_enabled: Option<bool>,
    #[doc = "Whether secure SIP is enabled for the domain. If enabled, TLS will be enforced and \
             SRTP will be negotiated on all incoming calls to this sip domain."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secure: Option<bool>,
    #[doc = "The SID of the BYOC Trunk(Bring Your Own Carrier) resource that the Sip Domain will \
             be associated with."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub byoc_trunk_sid: Option<String>,
    #[doc = "Whether an emergency caller sid is configured for the domain. If present, this phone \
             number will be used as the callback for the emergency call."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emergency_caller_sid: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountSipSipDomain {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountSipSipDomain {
    const LENGTH: usize = 21;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(auth_type) = &self.auth_type {
                format!("{auth_type:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(domain_name) = &self.domain_name {
                format!("{domain_name:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_method) = &self.voice_fallback_method {
                format!("{voice_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_url) = &self.voice_fallback_url {
                format!("{voice_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_method) = &self.voice_method {
                format!("{voice_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_status_callback_method) = &self.voice_status_callback_method {
                format!("{voice_status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_status_callback_url) = &self.voice_status_callback_url {
                format!("{voice_status_callback_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_url) = &self.voice_url {
                format!("{voice_url:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
            if let Some(sip_registration) = &self.sip_registration {
                format!("{sip_registration:?}")
            } else {
                String::new()
            },
            if let Some(emergency_calling_enabled) = &self.emergency_calling_enabled {
                format!("{emergency_calling_enabled:?}")
            } else {
                String::new()
            },
            if let Some(secure) = &self.secure {
                format!("{secure:?}")
            } else {
                String::new()
            },
            if let Some(byoc_trunk_sid) = &self.byoc_trunk_sid {
                format!("{byoc_trunk_sid:?}")
            } else {
                String::new()
            },
            if let Some(emergency_caller_sid) = &self.emergency_caller_sid {
                format!("{emergency_caller_sid:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "auth_type".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "domain_name".to_string(),
            "friendly_name".to_string(),
            "sid".to_string(),
            "uri".to_string(),
            "voice_fallback_method".to_string(),
            "voice_fallback_url".to_string(),
            "voice_method".to_string(),
            "voice_status_callback_method".to_string(),
            "voice_status_callback_url".to_string(),
            "voice_url".to_string(),
            "subresource_uris".to_string(),
            "sip_registration".to_string(),
            "emergency_calling_enabled".to_string(),
            "secure".to_string(),
            "byoc_trunk_sid".to_string(),
            "emergency_caller_sid".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountSipSipIpAccessControlList {
    #[doc = "A 34 character string that uniquely identifies this resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) that \
             owns this resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "A human readable descriptive text, up to 255 characters long."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The date that this resource was created, given as GMT in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date that this resource was last updated, given as GMT in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "A list of the IpAddress resources associated with this IP access control list \
             resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
    #[doc = "The URI for this resource, relative to `https://api.twilio.com`"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountSipSipIpAccessControlList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountSipSipIpAccessControlList {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "sid".to_string(),
            "account_sid".to_string(),
            "friendly_name".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "subresource_uris".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountSipSipDomainSipIpAccessControlListMapping {
    #[doc = "The unique id of the Account that is responsible for this resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The date that this resource was created, given as GMT in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date that this resource was last updated, given as GMT in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The unique string that is created to identify the SipDomain resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain_sid: Option<String>,
    #[doc = "A human readable descriptive text for this resource, up to 64 characters long."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "A 34 character string that uniquely identifies this resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The URI for this resource, relative to `https://api.twilio.com`"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountSipSipDomainSipIpAccessControlListMapping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountSipSipDomainSipIpAccessControlListMapping {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(domain_sid) = &self.domain_sid {
                format!("{domain_sid:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "domain_sid".to_string(),
            "friendly_name".to_string(),
            "sid".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountSipSipIpAccessControlListSipIpAddress {
    #[doc = "A 34 character string that uniquely identifies this resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The unique id of the Account that is responsible for this resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "A human readable descriptive text for this resource, up to 255 characters long."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "An IP address in dotted decimal notation from which you want to accept traffic. Any \
             SIP requests from this IP address will be allowed by Twilio. IPv4 only supported \
             today."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<String>,
    #[doc = "An integer representing the length of the CIDR prefix to use with this IP address \
             when accepting traffic. By default the entire IP address is used."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr_prefix_length: Option<i64>,
    #[doc = "The unique id of the IpAccessControlList resource that includes this resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip_access_control_list_sid: Option<String>,
    #[doc = "The date that this resource was created, given as GMT in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date that this resource was last updated, given as GMT in [RFC 2822](https://www.php.net/manual/en/class.datetime.php#datetime.constants.rfc2822) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The URI for this resource, relative to `https://api.twilio.com`"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountSipSipIpAccessControlListSipIpAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountSipSipIpAccessControlListSipIpAddress {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(ip_address) = &self.ip_address {
                format!("{ip_address:?}")
            } else {
                String::new()
            },
            if let Some(cidr_prefix_length) = &self.cidr_prefix_length {
                format!("{cidr_prefix_length:?}")
            } else {
                String::new()
            },
            if let Some(ip_access_control_list_sid) = &self.ip_access_control_list_sid {
                format!("{ip_access_control_list_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "sid".to_string(),
            "account_sid".to_string(),
            "friendly_name".to_string(),
            "ip_address".to_string(),
            "cidr_prefix_length".to_string(),
            "ip_access_control_list_sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountCallSiprec {
    #[doc = "The SID of the Siprec resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             this Siprec resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) the \
             Siprec resource is associated with."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub call_sid: Option<String>,
    #[doc = "The user-specified name of this Siprec, if one was given when the Siprec was \
             created. This may be used to stop the Siprec."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<SiprecEnumStatus>,
    #[doc = "The date and time in GMT that this resource was last updated, specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountCallSiprec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountCallSiprec {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(call_sid) = &self.call_sid {
                format!("{call_sid:?}")
            } else {
                String::new()
            },
            if let Some(name) = &self.name {
                format!("{name:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "sid".to_string(),
            "account_sid".to_string(),
            "call_sid".to_string(),
            "name".to_string(),
            "status".to_string(),
            "date_updated".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum SiprecEnumTrack {
    #[serde(rename = "inbound_track")]
    #[display("inbound_track")]
    InboundTrack,
    #[serde(rename = "outbound_track")]
    #[display("outbound_track")]
    OutboundTrack,
    #[serde(rename = "both_tracks")]
    #[display("both_tracks")]
    BothTracks,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum SiprecEnumStatus {
    #[serde(rename = "in-progress")]
    #[display("in-progress")]
    InProgress,
    #[serde(rename = "stopped")]
    #[display("stopped")]
    Stopped,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum SiprecEnumUpdateStatus {
    #[serde(rename = "stopped")]
    #[display("stopped")]
    Stopped,
}

impl std::default::Default for SiprecEnumUpdateStatus {
    fn default() -> Self {
        SiprecEnumUpdateStatus::Stopped
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountCallStream {
    #[doc = "The SID of the Stream resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             this Stream resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) the \
             Stream resource is associated with."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub call_sid: Option<String>,
    #[doc = "The user-specified name of this Stream, if one was given when the Stream was \
             created. This may be used to stop the Stream."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<StreamEnumStatus>,
    #[doc = "The date and time in GMT that this resource was last updated, specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountCallStream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountCallStream {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(call_sid) = &self.call_sid {
                format!("{call_sid:?}")
            } else {
                String::new()
            },
            if let Some(name) = &self.name {
                format!("{name:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "sid".to_string(),
            "account_sid".to_string(),
            "call_sid".to_string(),
            "name".to_string(),
            "status".to_string(),
            "date_updated".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum StreamEnumTrack {
    #[serde(rename = "inbound_track")]
    #[display("inbound_track")]
    InboundTrack,
    #[serde(rename = "outbound_track")]
    #[display("outbound_track")]
    OutboundTrack,
    #[serde(rename = "both_tracks")]
    #[display("both_tracks")]
    BothTracks,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum StreamEnumStatus {
    #[serde(rename = "in-progress")]
    #[display("in-progress")]
    InProgress,
    #[serde(rename = "stopped")]
    #[display("stopped")]
    Stopped,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum StreamEnumUpdateStatus {
    #[serde(rename = "stopped")]
    #[display("stopped")]
    Stopped,
}

impl std::default::Default for StreamEnumUpdateStatus {
    fn default() -> Self {
        StreamEnumUpdateStatus::Stopped
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct IceServers {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credential: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub urls: Option<String>,
}

impl std::fmt::Display for IceServers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for IceServers {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(credential) = &self.credential {
                format!("{credential:?}")
            } else {
                String::new()
            },
            if let Some(username) = &self.username {
                format!("{username:?}")
            } else {
                String::new()
            },
            if let Some(url) = &self.url {
                format!("{url:?}")
            } else {
                String::new()
            },
            if let Some(urls) = &self.urls {
                format!("{urls:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "credential".to_string(),
            "username".to_string(),
            "url".to_string(),
            "urls".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountToken {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the Token resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "An array representing the ephemeral credentials and the STUN and TURN server URIs."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ice_servers: Option<Vec<IceServers>>,
    #[doc = "The temporary password that the username will use when authenticating with Twilio."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    #[doc = "The duration in seconds for which the username and password are valid."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<String>,
    #[doc = "The temporary username that uniquely identifies a Token."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountToken {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountToken {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(ice_servers) = &self.ice_servers {
                format!("{ice_servers:?}")
            } else {
                String::new()
            },
            if let Some(password) = &self.password {
                format!("{password:?}")
            } else {
                String::new()
            },
            if let Some(ttl) = &self.ttl {
                format!("{ttl:?}")
            } else {
                String::new()
            },
            if let Some(username) = &self.username {
                format!("{username:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "ice_servers".to_string(),
            "password".to_string(),
            "ttl".to_string(),
            "username".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountTranscription {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             the Transcription resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to create the transcription."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The duration of the transcribed audio in seconds."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    #[doc = "The charge for the transcript in the currency associated with the account. This \
             value is populated after the transcript is complete so it may not be available \
             immediately."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<f64>,
    #[doc = "The currency in which `price` is measured, in [ISO 4127](https://www.iso.org/iso/home/standards/currency_codes.htm) format (e.g. `usd`, `eur`, `jpy`)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price_unit: Option<String>,
    #[doc = "The SID of the [Recording](https://www.twilio.com/docs/voice/api/recording) from \
             which the transcription was created."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub recording_sid: Option<String>,
    #[doc = "The unique string that that we created to identify the Transcription resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<TranscriptionEnumStatus>,
    #[doc = "The text content of the transcription."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub transcription_text: Option<String>,
    #[doc = "The transcription type. Can only be: `fast`."]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountTranscription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountTranscription {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(duration) = &self.duration {
                format!("{duration:?}")
            } else {
                String::new()
            },
            if let Some(price) = &self.price {
                format!("{price:?}")
            } else {
                String::new()
            },
            if let Some(price_unit) = &self.price_unit {
                format!("{price_unit:?}")
            } else {
                String::new()
            },
            if let Some(recording_sid) = &self.recording_sid {
                format!("{recording_sid:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
            if let Some(transcription_text) = &self.transcription_text {
                format!("{transcription_text:?}")
            } else {
                String::new()
            },
            if let Some(type_) = &self.type_ {
                format!("{type_:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "date_created".to_string(),
            "date_updated".to_string(),
            "duration".to_string(),
            "price".to_string(),
            "price_unit".to_string(),
            "recording_sid".to_string(),
            "sid".to_string(),
            "status".to_string(),
            "transcription_text".to_string(),
            "type_".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum TranscriptionEnumStatus {
    #[serde(rename = "in-progress")]
    #[display("in-progress")]
    InProgress,
    #[serde(rename = "completed")]
    #[display("completed")]
    Completed,
    #[serde(rename = "failed")]
    #[display("failed")]
    Failed,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountUsage {}

impl std::fmt::Display for ApiV2010AccountUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountUsage {
    const LENGTH: usize = 0;
    fn fields(&self) -> Vec<String> {
        vec![]
    }

    fn headers() -> Vec<String> {
        vec![]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountUsageUsageRecord {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that accrued \
             the usage."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to create the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "Usage records up to date as of this timestamp, formatted as \
             YYYY-MM-DDTHH:MM:SS+00:00. All timestamps are in GMT"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub as_of: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub category: Option<UsageRecordEnumCategory>,
    #[doc = "The number of usage events, such as the number of calls."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<String>,
    #[doc = "The units in which `count` is measured, such as `calls` for calls or `messages` for \
             SMS."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count_unit: Option<String>,
    #[doc = "A plain-language description of the usage category."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "The last date for which usage is included in the UsageRecord. The date is specified \
             in GMT and formatted as `YYYY-MM-DD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_date: Option<chrono::NaiveDate>,
    #[doc = "The total price of the usage in the currency specified in `price_unit` and \
             associated with the account."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<f64>,
    #[doc = "The currency in which `price` is measured, in [ISO 4127](https://www.iso.org/iso/home/standards/currency_codes.htm) format, such as `usd`, `eur`, and `jpy`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price_unit: Option<String>,
    #[doc = "The first date for which usage is included in this UsageRecord. The date is \
             specified in GMT and formatted as `YYYY-MM-DD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_date: Option<chrono::NaiveDate>,
    #[doc = "A list of related resources identified by their URIs. For more information, see [List Subresources](https://www.twilio.com/docs/usage/api/usage-record#list-subresources)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "The amount used to bill usage and measured in units described in `usage_unit`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage: Option<String>,
    #[doc = "The units in which `usage` is measured, such as `minutes` for calls or `messages` \
             for SMS."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_unit: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountUsageUsageRecord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountUsageUsageRecord {
    const LENGTH: usize = 15;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(as_of) = &self.as_of {
                format!("{as_of:?}")
            } else {
                String::new()
            },
            if let Some(category) = &self.category {
                format!("{category:?}")
            } else {
                String::new()
            },
            if let Some(count) = &self.count {
                format!("{count:?}")
            } else {
                String::new()
            },
            if let Some(count_unit) = &self.count_unit {
                format!("{count_unit:?}")
            } else {
                String::new()
            },
            if let Some(description) = &self.description {
                format!("{description:?}")
            } else {
                String::new()
            },
            if let Some(end_date) = &self.end_date {
                format!("{end_date:?}")
            } else {
                String::new()
            },
            if let Some(price) = &self.price {
                format!("{price:?}")
            } else {
                String::new()
            },
            if let Some(price_unit) = &self.price_unit {
                format!("{price_unit:?}")
            } else {
                String::new()
            },
            if let Some(start_date) = &self.start_date {
                format!("{start_date:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(usage) = &self.usage {
                format!("{usage:?}")
            } else {
                String::new()
            },
            if let Some(usage_unit) = &self.usage_unit {
                format!("{usage_unit:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "as_of".to_string(),
            "category".to_string(),
            "count".to_string(),
            "count_unit".to_string(),
            "description".to_string(),
            "end_date".to_string(),
            "price".to_string(),
            "price_unit".to_string(),
            "start_date".to_string(),
            "subresource_uris".to_string(),
            "uri".to_string(),
            "usage".to_string(),
            "usage_unit".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UsageRecordEnumCategory {
    #[serde(rename = "a2p-registration-fees")]
    #[display("a2p-registration-fees")]
    A2PRegistrationFees,
    #[serde(rename = "agent-conference")]
    #[display("agent-conference")]
    AgentConference,
    #[serde(rename = "amazon-polly")]
    #[display("amazon-polly")]
    AmazonPolly,
    #[serde(rename = "answering-machine-detection")]
    #[display("answering-machine-detection")]
    AnsweringMachineDetection,
    #[serde(rename = "authy-authentications")]
    #[display("authy-authentications")]
    AuthyAuthentications,
    #[serde(rename = "authy-calls-outbound")]
    #[display("authy-calls-outbound")]
    AuthyCallsOutbound,
    #[serde(rename = "authy-monthly-fees")]
    #[display("authy-monthly-fees")]
    AuthyMonthlyFees,
    #[serde(rename = "authy-phone-intelligence")]
    #[display("authy-phone-intelligence")]
    AuthyPhoneIntelligence,
    #[serde(rename = "authy-phone-verifications")]
    #[display("authy-phone-verifications")]
    AuthyPhoneVerifications,
    #[serde(rename = "authy-sms-outbound")]
    #[display("authy-sms-outbound")]
    AuthySmsOutbound,
    #[serde(rename = "call-progess-events")]
    #[display("call-progess-events")]
    CallProgessEvents,
    #[serde(rename = "calleridlookups")]
    #[display("calleridlookups")]
    Calleridlookups,
    #[serde(rename = "calls")]
    #[display("calls")]
    Calls,
    #[serde(rename = "calls-client")]
    #[display("calls-client")]
    CallsClient,
    #[serde(rename = "calls-globalconference")]
    #[display("calls-globalconference")]
    CallsGlobalconference,
    #[serde(rename = "calls-inbound")]
    #[display("calls-inbound")]
    CallsInbound,
    #[serde(rename = "calls-inbound-local")]
    #[display("calls-inbound-local")]
    CallsInboundLocal,
    #[serde(rename = "calls-inbound-mobile")]
    #[display("calls-inbound-mobile")]
    CallsInboundMobile,
    #[serde(rename = "calls-inbound-tollfree")]
    #[display("calls-inbound-tollfree")]
    CallsInboundTollfree,
    #[serde(rename = "calls-outbound")]
    #[display("calls-outbound")]
    CallsOutbound,
    #[serde(rename = "calls-pay-verb-transactions")]
    #[display("calls-pay-verb-transactions")]
    CallsPayVerbTransactions,
    #[serde(rename = "calls-recordings")]
    #[display("calls-recordings")]
    CallsRecordings,
    #[serde(rename = "calls-sip")]
    #[display("calls-sip")]
    CallsSip,
    #[serde(rename = "calls-sip-inbound")]
    #[display("calls-sip-inbound")]
    CallsSipInbound,
    #[serde(rename = "calls-sip-outbound")]
    #[display("calls-sip-outbound")]
    CallsSipOutbound,
    #[serde(rename = "calls-transfers")]
    #[display("calls-transfers")]
    CallsTransfers,
    #[serde(rename = "carrier-lookups")]
    #[display("carrier-lookups")]
    CarrierLookups,
    #[serde(rename = "conversations")]
    #[display("conversations")]
    Conversations,
    #[serde(rename = "conversations-api-requests")]
    #[display("conversations-api-requests")]
    ConversationsApiRequests,
    #[serde(rename = "conversations-conversation-events")]
    #[display("conversations-conversation-events")]
    ConversationsConversationEvents,
    #[serde(rename = "conversations-endpoint-connectivity")]
    #[display("conversations-endpoint-connectivity")]
    ConversationsEndpointConnectivity,
    #[serde(rename = "conversations-events")]
    #[display("conversations-events")]
    ConversationsEvents,
    #[serde(rename = "conversations-participant-events")]
    #[display("conversations-participant-events")]
    ConversationsParticipantEvents,
    #[serde(rename = "conversations-participants")]
    #[display("conversations-participants")]
    ConversationsParticipants,
    #[serde(rename = "cps")]
    #[display("cps")]
    Cps,
    #[serde(rename = "flex-usage")]
    #[display("flex-usage")]
    FlexUsage,
    #[serde(rename = "fraud-lookups")]
    #[display("fraud-lookups")]
    FraudLookups,
    #[serde(rename = "group-rooms")]
    #[display("group-rooms")]
    GroupRooms,
    #[serde(rename = "group-rooms-data-track")]
    #[display("group-rooms-data-track")]
    GroupRoomsDataTrack,
    #[serde(rename = "group-rooms-encrypted-media-recorded")]
    #[display("group-rooms-encrypted-media-recorded")]
    GroupRoomsEncryptedMediaRecorded,
    #[serde(rename = "group-rooms-media-downloaded")]
    #[display("group-rooms-media-downloaded")]
    GroupRoomsMediaDownloaded,
    #[serde(rename = "group-rooms-media-recorded")]
    #[display("group-rooms-media-recorded")]
    GroupRoomsMediaRecorded,
    #[serde(rename = "group-rooms-media-routed")]
    #[display("group-rooms-media-routed")]
    GroupRoomsMediaRouted,
    #[serde(rename = "group-rooms-media-stored")]
    #[display("group-rooms-media-stored")]
    GroupRoomsMediaStored,
    #[serde(rename = "group-rooms-participant-minutes")]
    #[display("group-rooms-participant-minutes")]
    GroupRoomsParticipantMinutes,
    #[serde(rename = "group-rooms-recorded-minutes")]
    #[display("group-rooms-recorded-minutes")]
    GroupRoomsRecordedMinutes,
    #[serde(rename = "imp-v1-usage")]
    #[display("imp-v1-usage")]
    ImpUsage,
    #[serde(rename = "lookups")]
    #[display("lookups")]
    Lookups,
    #[serde(rename = "marketplace")]
    #[display("marketplace")]
    Marketplace,
    #[serde(rename = "marketplace-algorithmia-named-entity-recognition")]
    #[display("marketplace-algorithmia-named-entity-recognition")]
    MarketplaceAlgorithmiaNamedEntityRecognition,
    #[serde(rename = "marketplace-cadence-transcription")]
    #[display("marketplace-cadence-transcription")]
    MarketplaceCadenceTranscription,
    #[serde(rename = "marketplace-cadence-translation")]
    #[display("marketplace-cadence-translation")]
    MarketplaceCadenceTranslation,
    #[serde(rename = "marketplace-capio-speech-to-text")]
    #[display("marketplace-capio-speech-to-text")]
    MarketplaceCapioSpeechToText,
    #[serde(rename = "marketplace-convriza-ababa")]
    #[display("marketplace-convriza-ababa")]
    MarketplaceConvrizaAbaba,
    #[serde(rename = "marketplace-deepgram-phrase-detector")]
    #[display("marketplace-deepgram-phrase-detector")]
    MarketplaceDeepgramPhraseDetector,
    #[serde(rename = "marketplace-digital-segment-business-info")]
    #[display("marketplace-digital-segment-business-info")]
    MarketplaceDigitalSegmentBusinessInfo,
    #[serde(rename = "marketplace-facebook-offline-conversions")]
    #[display("marketplace-facebook-offline-conversions")]
    MarketplaceFacebookOfflineConversions,
    #[serde(rename = "marketplace-google-speech-to-text")]
    #[display("marketplace-google-speech-to-text")]
    MarketplaceGoogleSpeechToText,
    #[serde(rename = "marketplace-ibm-watson-message-insights")]
    #[display("marketplace-ibm-watson-message-insights")]
    MarketplaceIbmWatsonMessageInsights,
    #[serde(rename = "marketplace-ibm-watson-message-sentiment")]
    #[display("marketplace-ibm-watson-message-sentiment")]
    MarketplaceIbmWatsonMessageSentiment,
    #[serde(rename = "marketplace-ibm-watson-recording-analysis")]
    #[display("marketplace-ibm-watson-recording-analysis")]
    MarketplaceIbmWatsonRecordingAnalysis,
    #[serde(rename = "marketplace-ibm-watson-tone-analyzer")]
    #[display("marketplace-ibm-watson-tone-analyzer")]
    MarketplaceIbmWatsonToneAnalyzer,
    #[serde(rename = "marketplace-icehook-systems-scout")]
    #[display("marketplace-icehook-systems-scout")]
    MarketplaceIcehookSystemsScout,
    #[serde(rename = "marketplace-infogroup-dataaxle-bizinfo")]
    #[display("marketplace-infogroup-dataaxle-bizinfo")]
    MarketplaceInfogroupDataaxleBizinfo,
    #[serde(rename = "marketplace-keen-io-contact-center-analytics")]
    #[display("marketplace-keen-io-contact-center-analytics")]
    MarketplaceKeenIoContactCenterAnalytics,
    #[serde(rename = "marketplace-marchex-cleancall")]
    #[display("marketplace-marchex-cleancall")]
    MarketplaceMarchexCleancall,
    #[serde(rename = "marketplace-marchex-sentiment-analysis-for-sms")]
    #[display("marketplace-marchex-sentiment-analysis-for-sms")]
    MarketplaceMarchexSentimentAnalysisForSms,
    #[serde(rename = "marketplace-marketplace-nextcaller-social-id")]
    #[display("marketplace-marketplace-nextcaller-social-id")]
    MarketplaceMarketplaceNextcallerSocialId,
    #[serde(rename = "marketplace-mobile-commons-opt-out-classifier")]
    #[display("marketplace-mobile-commons-opt-out-classifier")]
    MarketplaceMobileCommonsOptOutClassifier,
    #[serde(rename = "marketplace-nexiwave-voicemail-to-text")]
    #[display("marketplace-nexiwave-voicemail-to-text")]
    MarketplaceNexiwaveVoicemailToText,
    #[serde(rename = "marketplace-nextcaller-advanced-caller-identification")]
    #[display("marketplace-nextcaller-advanced-caller-identification")]
    MarketplaceNextcallerAdvancedCallerIdentification,
    #[serde(rename = "marketplace-nomorobo-spam-score")]
    #[display("marketplace-nomorobo-spam-score")]
    MarketplaceNomoroboSpamScore,
    #[serde(rename = "marketplace-payfone-tcpa-compliance")]
    #[display("marketplace-payfone-tcpa-compliance")]
    MarketplacePayfoneTcpaCompliance,
    #[serde(rename = "marketplace-remeeting-automatic-speech-recognition")]
    #[display("marketplace-remeeting-automatic-speech-recognition")]
    MarketplaceRemeetingAutomaticSpeechRecognition,
    #[serde(rename = "marketplace-tcpa-defense-solutions-blacklist-feed")]
    #[display("marketplace-tcpa-defense-solutions-blacklist-feed")]
    MarketplaceTcpaDefenseSolutionsBlacklistFeed,
    #[serde(rename = "marketplace-telo-opencnam")]
    #[display("marketplace-telo-opencnam")]
    MarketplaceTeloOpencnam,
    #[serde(rename = "marketplace-truecnam-true-spam")]
    #[display("marketplace-truecnam-true-spam")]
    MarketplaceTruecnamTrueSpam,
    #[serde(rename = "marketplace-twilio-caller-name-lookup-us")]
    #[display("marketplace-twilio-caller-name-lookup-us")]
    MarketplaceTwilioCallerNameLookupUs,
    #[serde(rename = "marketplace-twilio-carrier-information-lookup")]
    #[display("marketplace-twilio-carrier-information-lookup")]
    MarketplaceTwilioCarrierInformationLookup,
    #[serde(rename = "marketplace-voicebase-pci")]
    #[display("marketplace-voicebase-pci")]
    MarketplaceVoicebasePci,
    #[serde(rename = "marketplace-voicebase-transcription")]
    #[display("marketplace-voicebase-transcription")]
    MarketplaceVoicebaseTranscription,
    #[serde(rename = "marketplace-voicebase-transcription-custom-vocabulary")]
    #[display("marketplace-voicebase-transcription-custom-vocabulary")]
    MarketplaceVoicebaseTranscriptionCustomVocabulary,
    #[serde(rename = "marketplace-whitepages-pro-caller-identification")]
    #[display("marketplace-whitepages-pro-caller-identification")]
    MarketplaceWhitepagesProCallerIdentification,
    #[serde(rename = "marketplace-whitepages-pro-phone-intelligence")]
    #[display("marketplace-whitepages-pro-phone-intelligence")]
    MarketplaceWhitepagesProPhoneIntelligence,
    #[serde(rename = "marketplace-whitepages-pro-phone-reputation")]
    #[display("marketplace-whitepages-pro-phone-reputation")]
    MarketplaceWhitepagesProPhoneReputation,
    #[serde(rename = "marketplace-wolfarm-spoken-results")]
    #[display("marketplace-wolfarm-spoken-results")]
    MarketplaceWolfarmSpokenResults,
    #[serde(rename = "marketplace-wolfram-short-answer")]
    #[display("marketplace-wolfram-short-answer")]
    MarketplaceWolframShortAnswer,
    #[serde(rename = "marketplace-ytica-contact-center-reporting-analytics")]
    #[display("marketplace-ytica-contact-center-reporting-analytics")]
    MarketplaceYticaContactCenterReportingAnalytics,
    #[serde(rename = "mediastorage")]
    #[display("mediastorage")]
    Mediastorage,
    #[serde(rename = "mms")]
    #[display("mms")]
    Mms,
    #[serde(rename = "mms-inbound")]
    #[display("mms-inbound")]
    MmsInbound,
    #[serde(rename = "mms-inbound-longcode")]
    #[display("mms-inbound-longcode")]
    MmsInboundLongcode,
    #[serde(rename = "mms-inbound-shortcode")]
    #[display("mms-inbound-shortcode")]
    MmsInboundShortcode,
    #[serde(rename = "mms-messages-carrierfees")]
    #[display("mms-messages-carrierfees")]
    MmsMessagesCarrierfees,
    #[serde(rename = "mms-outbound")]
    #[display("mms-outbound")]
    MmsOutbound,
    #[serde(rename = "mms-outbound-longcode")]
    #[display("mms-outbound-longcode")]
    MmsOutboundLongcode,
    #[serde(rename = "mms-outbound-shortcode")]
    #[display("mms-outbound-shortcode")]
    MmsOutboundShortcode,
    #[serde(rename = "monitor-reads")]
    #[display("monitor-reads")]
    MonitorReads,
    #[serde(rename = "monitor-storage")]
    #[display("monitor-storage")]
    MonitorStorage,
    #[serde(rename = "monitor-writes")]
    #[display("monitor-writes")]
    MonitorWrites,
    #[serde(rename = "notify")]
    #[display("notify")]
    Notify,
    #[serde(rename = "notify-actions-attempts")]
    #[display("notify-actions-attempts")]
    NotifyActionsAttempts,
    #[serde(rename = "notify-channels")]
    #[display("notify-channels")]
    NotifyChannels,
    #[serde(rename = "number-format-lookups")]
    #[display("number-format-lookups")]
    NumberFormatLookups,
    #[serde(rename = "pchat")]
    #[display("pchat")]
    Pchat,
    #[serde(rename = "pchat-users")]
    #[display("pchat-users")]
    PchatUsers,
    #[serde(rename = "peer-to-peer-rooms-participant-minutes")]
    #[display("peer-to-peer-rooms-participant-minutes")]
    PeerToPeerRoomsParticipantMinutes,
    #[serde(rename = "pfax")]
    #[display("pfax")]
    Pfax,
    #[serde(rename = "pfax-minutes")]
    #[display("pfax-minutes")]
    PfaxMinutes,
    #[serde(rename = "pfax-minutes-inbound")]
    #[display("pfax-minutes-inbound")]
    PfaxMinutesInbound,
    #[serde(rename = "pfax-minutes-outbound")]
    #[display("pfax-minutes-outbound")]
    PfaxMinutesOutbound,
    #[serde(rename = "pfax-pages")]
    #[display("pfax-pages")]
    PfaxPages,
    #[serde(rename = "phonenumbers")]
    #[display("phonenumbers")]
    Phonenumbers,
    #[serde(rename = "phonenumbers-cps")]
    #[display("phonenumbers-cps")]
    PhonenumbersCps,
    #[serde(rename = "phonenumbers-emergency")]
    #[display("phonenumbers-emergency")]
    PhonenumbersEmergency,
    #[serde(rename = "phonenumbers-local")]
    #[display("phonenumbers-local")]
    PhonenumbersLocal,
    #[serde(rename = "phonenumbers-mobile")]
    #[display("phonenumbers-mobile")]
    PhonenumbersMobile,
    #[serde(rename = "phonenumbers-setups")]
    #[display("phonenumbers-setups")]
    PhonenumbersSetups,
    #[serde(rename = "phonenumbers-tollfree")]
    #[display("phonenumbers-tollfree")]
    PhonenumbersTollfree,
    #[serde(rename = "premiumsupport")]
    #[display("premiumsupport")]
    Premiumsupport,
    #[serde(rename = "proxy")]
    #[display("proxy")]
    Proxy,
    #[serde(rename = "proxy-active-sessions")]
    #[display("proxy-active-sessions")]
    ProxyActiveSessions,
    #[serde(rename = "pstnconnectivity")]
    #[display("pstnconnectivity")]
    Pstnconnectivity,
    #[serde(rename = "pv")]
    #[display("pv")]
    Pv,
    #[serde(rename = "pv-composition-media-downloaded")]
    #[display("pv-composition-media-downloaded")]
    PvCompositionMediaDownloaded,
    #[serde(rename = "pv-composition-media-encrypted")]
    #[display("pv-composition-media-encrypted")]
    PvCompositionMediaEncrypted,
    #[serde(rename = "pv-composition-media-stored")]
    #[display("pv-composition-media-stored")]
    PvCompositionMediaStored,
    #[serde(rename = "pv-composition-minutes")]
    #[display("pv-composition-minutes")]
    PvCompositionMinutes,
    #[serde(rename = "pv-recording-compositions")]
    #[display("pv-recording-compositions")]
    PvRecordingCompositions,
    #[serde(rename = "pv-room-participants")]
    #[display("pv-room-participants")]
    PvRoomParticipants,
    #[serde(rename = "pv-room-participants-au1")]
    #[display("pv-room-participants-au1")]
    PvRoomParticipantsAu1,
    #[serde(rename = "pv-room-participants-br1")]
    #[display("pv-room-participants-br1")]
    PvRoomParticipantsBr1,
    #[serde(rename = "pv-room-participants-ie1")]
    #[display("pv-room-participants-ie1")]
    PvRoomParticipantsIe1,
    #[serde(rename = "pv-room-participants-jp1")]
    #[display("pv-room-participants-jp1")]
    PvRoomParticipantsJp1,
    #[serde(rename = "pv-room-participants-sg1")]
    #[display("pv-room-participants-sg1")]
    PvRoomParticipantsSg1,
    #[serde(rename = "pv-room-participants-us1")]
    #[display("pv-room-participants-us1")]
    PvRoomParticipantsUs1,
    #[serde(rename = "pv-room-participants-us2")]
    #[display("pv-room-participants-us2")]
    PvRoomParticipantsUs2,
    #[serde(rename = "pv-rooms")]
    #[display("pv-rooms")]
    PvRooms,
    #[serde(rename = "pv-sip-endpoint-registrations")]
    #[display("pv-sip-endpoint-registrations")]
    PvSipEndpointRegistrations,
    #[serde(rename = "recordings")]
    #[display("recordings")]
    Recordings,
    #[serde(rename = "recordingstorage")]
    #[display("recordingstorage")]
    Recordingstorage,
    #[serde(rename = "rooms-group-bandwidth")]
    #[display("rooms-group-bandwidth")]
    RoomsGroupBandwidth,
    #[serde(rename = "rooms-group-minutes")]
    #[display("rooms-group-minutes")]
    RoomsGroupMinutes,
    #[serde(rename = "rooms-peer-to-peer-minutes")]
    #[display("rooms-peer-to-peer-minutes")]
    RoomsPeerToPeerMinutes,
    #[serde(rename = "shortcodes")]
    #[display("shortcodes")]
    Shortcodes,
    #[serde(rename = "shortcodes-customerowned")]
    #[display("shortcodes-customerowned")]
    ShortcodesCustomerowned,
    #[serde(rename = "shortcodes-mms-enablement")]
    #[display("shortcodes-mms-enablement")]
    ShortcodesMmsEnablement,
    #[serde(rename = "shortcodes-mps")]
    #[display("shortcodes-mps")]
    ShortcodesMps,
    #[serde(rename = "shortcodes-random")]
    #[display("shortcodes-random")]
    ShortcodesRandom,
    #[serde(rename = "shortcodes-uk")]
    #[display("shortcodes-uk")]
    ShortcodesUk,
    #[serde(rename = "shortcodes-vanity")]
    #[display("shortcodes-vanity")]
    ShortcodesVanity,
    #[serde(rename = "small-group-rooms")]
    #[display("small-group-rooms")]
    SmallGroupRooms,
    #[serde(rename = "small-group-rooms-data-track")]
    #[display("small-group-rooms-data-track")]
    SmallGroupRoomsDataTrack,
    #[serde(rename = "small-group-rooms-participant-minutes")]
    #[display("small-group-rooms-participant-minutes")]
    SmallGroupRoomsParticipantMinutes,
    #[serde(rename = "sms")]
    #[display("sms")]
    Sms,
    #[serde(rename = "sms-inbound")]
    #[display("sms-inbound")]
    SmsInbound,
    #[serde(rename = "sms-inbound-longcode")]
    #[display("sms-inbound-longcode")]
    SmsInboundLongcode,
    #[serde(rename = "sms-inbound-shortcode")]
    #[display("sms-inbound-shortcode")]
    SmsInboundShortcode,
    #[serde(rename = "sms-messages-carrierfees")]
    #[display("sms-messages-carrierfees")]
    SmsMessagesCarrierfees,
    #[serde(rename = "sms-messages-features")]
    #[display("sms-messages-features")]
    SmsMessagesFeatures,
    #[serde(rename = "sms-messages-features-senderid")]
    #[display("sms-messages-features-senderid")]
    SmsMessagesFeaturesSenderid,
    #[serde(rename = "sms-outbound")]
    #[display("sms-outbound")]
    SmsOutbound,
    #[serde(rename = "sms-outbound-content-inspection")]
    #[display("sms-outbound-content-inspection")]
    SmsOutboundContentInspection,
    #[serde(rename = "sms-outbound-longcode")]
    #[display("sms-outbound-longcode")]
    SmsOutboundLongcode,
    #[serde(rename = "sms-outbound-shortcode")]
    #[display("sms-outbound-shortcode")]
    SmsOutboundShortcode,
    #[serde(rename = "speech-recognition")]
    #[display("speech-recognition")]
    SpeechRecognition,
    #[serde(rename = "studio-engagements")]
    #[display("studio-engagements")]
    StudioEngagements,
    #[serde(rename = "sync")]
    #[display("sync")]
    Sync,
    #[serde(rename = "sync-actions")]
    #[display("sync-actions")]
    SyncActions,
    #[serde(rename = "sync-endpoint-hours")]
    #[display("sync-endpoint-hours")]
    SyncEndpointHours,
    #[serde(rename = "sync-endpoint-hours-above-daily-cap")]
    #[display("sync-endpoint-hours-above-daily-cap")]
    SyncEndpointHoursAboveDailyCap,
    #[serde(rename = "taskrouter-tasks")]
    #[display("taskrouter-tasks")]
    TaskrouterTasks,
    #[serde(rename = "totalprice")]
    #[display("totalprice")]
    Totalprice,
    #[serde(rename = "transcriptions")]
    #[display("transcriptions")]
    Transcriptions,
    #[serde(rename = "trunking-cps")]
    #[display("trunking-cps")]
    TrunkingCps,
    #[serde(rename = "trunking-emergency-calls")]
    #[display("trunking-emergency-calls")]
    TrunkingEmergencyCalls,
    #[serde(rename = "trunking-origination")]
    #[display("trunking-origination")]
    TrunkingOrigination,
    #[serde(rename = "trunking-origination-local")]
    #[display("trunking-origination-local")]
    TrunkingOriginationLocal,
    #[serde(rename = "trunking-origination-mobile")]
    #[display("trunking-origination-mobile")]
    TrunkingOriginationMobile,
    #[serde(rename = "trunking-origination-tollfree")]
    #[display("trunking-origination-tollfree")]
    TrunkingOriginationTollfree,
    #[serde(rename = "trunking-recordings")]
    #[display("trunking-recordings")]
    TrunkingRecordings,
    #[serde(rename = "trunking-secure")]
    #[display("trunking-secure")]
    TrunkingSecure,
    #[serde(rename = "trunking-termination")]
    #[display("trunking-termination")]
    TrunkingTermination,
    #[serde(rename = "turnmegabytes")]
    #[display("turnmegabytes")]
    Turnmegabytes,
    #[serde(rename = "turnmegabytes-australia")]
    #[display("turnmegabytes-australia")]
    TurnmegabytesAustralia,
    #[serde(rename = "turnmegabytes-brasil")]
    #[display("turnmegabytes-brasil")]
    TurnmegabytesBrasil,
    #[serde(rename = "turnmegabytes-germany")]
    #[display("turnmegabytes-germany")]
    TurnmegabytesGermany,
    #[serde(rename = "turnmegabytes-india")]
    #[display("turnmegabytes-india")]
    TurnmegabytesIndia,
    #[serde(rename = "turnmegabytes-ireland")]
    #[display("turnmegabytes-ireland")]
    TurnmegabytesIreland,
    #[serde(rename = "turnmegabytes-japan")]
    #[display("turnmegabytes-japan")]
    TurnmegabytesJapan,
    #[serde(rename = "turnmegabytes-singapore")]
    #[display("turnmegabytes-singapore")]
    TurnmegabytesSingapore,
    #[serde(rename = "turnmegabytes-useast")]
    #[display("turnmegabytes-useast")]
    TurnmegabytesUseast,
    #[serde(rename = "turnmegabytes-uswest")]
    #[display("turnmegabytes-uswest")]
    TurnmegabytesUswest,
    #[serde(rename = "twilio-interconnect")]
    #[display("twilio-interconnect")]
    TwilioInterconnect,
    #[serde(rename = "verify-push")]
    #[display("verify-push")]
    VerifyPush,
    #[serde(rename = "verify-totp")]
    #[display("verify-totp")]
    VerifyTotp,
    #[serde(rename = "verify-whatsapp-conversations-business-initiated")]
    #[display("verify-whatsapp-conversations-business-initiated")]
    VerifyWhatsappConversationsBusinessInitiated,
    #[serde(rename = "video-recordings")]
    #[display("video-recordings")]
    VideoRecordings,
    #[serde(rename = "virtual-agent")]
    #[display("virtual-agent")]
    VirtualAgent,
    #[serde(rename = "voice-insights")]
    #[display("voice-insights")]
    VoiceInsights,
    #[serde(rename = "voice-insights-client-insights-on-demand-minute")]
    #[display("voice-insights-client-insights-on-demand-minute")]
    VoiceInsightsClientInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-ptsn-insights-on-demand-minute")]
    #[display("voice-insights-ptsn-insights-on-demand-minute")]
    VoiceInsightsPtsnInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-interface-insights-on-demand-minute")]
    #[display("voice-insights-sip-interface-insights-on-demand-minute")]
    VoiceInsightsSipInterfaceInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-trunking-insights-on-demand-minute")]
    #[display("voice-insights-sip-trunking-insights-on-demand-minute")]
    VoiceInsightsSipTrunkingInsightsOnDemandMinute,
    #[serde(rename = "wireless")]
    #[display("wireless")]
    Wireless,
    #[serde(rename = "wireless-orders")]
    #[display("wireless-orders")]
    WirelessOrders,
    #[serde(rename = "wireless-orders-artwork")]
    #[display("wireless-orders-artwork")]
    WirelessOrdersArtwork,
    #[serde(rename = "wireless-orders-bulk")]
    #[display("wireless-orders-bulk")]
    WirelessOrdersBulk,
    #[serde(rename = "wireless-orders-esim")]
    #[display("wireless-orders-esim")]
    WirelessOrdersEsim,
    #[serde(rename = "wireless-orders-starter")]
    #[display("wireless-orders-starter")]
    WirelessOrdersStarter,
    #[serde(rename = "wireless-usage")]
    #[display("wireless-usage")]
    WirelessUsage,
    #[serde(rename = "wireless-usage-commands")]
    #[display("wireless-usage-commands")]
    WirelessUsageCommands,
    #[serde(rename = "wireless-usage-commands-africa")]
    #[display("wireless-usage-commands-africa")]
    WirelessUsageCommandsAfrica,
    #[serde(rename = "wireless-usage-commands-asia")]
    #[display("wireless-usage-commands-asia")]
    WirelessUsageCommandsAsia,
    #[serde(rename = "wireless-usage-commands-centralandsouthamerica")]
    #[display("wireless-usage-commands-centralandsouthamerica")]
    WirelessUsageCommandsCentralandsouthamerica,
    #[serde(rename = "wireless-usage-commands-europe")]
    #[display("wireless-usage-commands-europe")]
    WirelessUsageCommandsEurope,
    #[serde(rename = "wireless-usage-commands-home")]
    #[display("wireless-usage-commands-home")]
    WirelessUsageCommandsHome,
    #[serde(rename = "wireless-usage-commands-northamerica")]
    #[display("wireless-usage-commands-northamerica")]
    WirelessUsageCommandsNorthamerica,
    #[serde(rename = "wireless-usage-commands-oceania")]
    #[display("wireless-usage-commands-oceania")]
    WirelessUsageCommandsOceania,
    #[serde(rename = "wireless-usage-commands-roaming")]
    #[display("wireless-usage-commands-roaming")]
    WirelessUsageCommandsRoaming,
    #[serde(rename = "wireless-usage-data")]
    #[display("wireless-usage-data")]
    WirelessUsageData,
    #[serde(rename = "wireless-usage-data-africa")]
    #[display("wireless-usage-data-africa")]
    WirelessUsageDataAfrica,
    #[serde(rename = "wireless-usage-data-asia")]
    #[display("wireless-usage-data-asia")]
    WirelessUsageDataAsia,
    #[serde(rename = "wireless-usage-data-centralandsouthamerica")]
    #[display("wireless-usage-data-centralandsouthamerica")]
    WirelessUsageDataCentralandsouthamerica,
    #[serde(rename = "wireless-usage-data-custom-additionalmb")]
    #[display("wireless-usage-data-custom-additionalmb")]
    WirelessUsageDataCustomAdditionalmb,
    #[serde(rename = "wireless-usage-data-custom-first5mb")]
    #[display("wireless-usage-data-custom-first5mb")]
    WirelessUsageDataCustomFirst5Mb,
    #[serde(rename = "wireless-usage-data-domestic-roaming")]
    #[display("wireless-usage-data-domestic-roaming")]
    WirelessUsageDataDomesticRoaming,
    #[serde(rename = "wireless-usage-data-europe")]
    #[display("wireless-usage-data-europe")]
    WirelessUsageDataEurope,
    #[serde(rename = "wireless-usage-data-individual-additionalgb")]
    #[display("wireless-usage-data-individual-additionalgb")]
    WirelessUsageDataIndividualAdditionalgb,
    #[serde(rename = "wireless-usage-data-individual-firstgb")]
    #[display("wireless-usage-data-individual-firstgb")]
    WirelessUsageDataIndividualFirstgb,
    #[serde(rename = "wireless-usage-data-international-roaming-canada")]
    #[display("wireless-usage-data-international-roaming-canada")]
    WirelessUsageDataInternationalRoamingCanada,
    #[serde(rename = "wireless-usage-data-international-roaming-india")]
    #[display("wireless-usage-data-international-roaming-india")]
    WirelessUsageDataInternationalRoamingIndia,
    #[serde(rename = "wireless-usage-data-international-roaming-mexico")]
    #[display("wireless-usage-data-international-roaming-mexico")]
    WirelessUsageDataInternationalRoamingMexico,
    #[serde(rename = "wireless-usage-data-northamerica")]
    #[display("wireless-usage-data-northamerica")]
    WirelessUsageDataNorthamerica,
    #[serde(rename = "wireless-usage-data-oceania")]
    #[display("wireless-usage-data-oceania")]
    WirelessUsageDataOceania,
    #[serde(rename = "wireless-usage-data-pooled")]
    #[display("wireless-usage-data-pooled")]
    WirelessUsageDataPooled,
    #[serde(rename = "wireless-usage-data-pooled-downlink")]
    #[display("wireless-usage-data-pooled-downlink")]
    WirelessUsageDataPooledDownlink,
    #[serde(rename = "wireless-usage-data-pooled-uplink")]
    #[display("wireless-usage-data-pooled-uplink")]
    WirelessUsageDataPooledUplink,
    #[serde(rename = "wireless-usage-mrc")]
    #[display("wireless-usage-mrc")]
    WirelessUsageMrc,
    #[serde(rename = "wireless-usage-mrc-custom")]
    #[display("wireless-usage-mrc-custom")]
    WirelessUsageMrcCustom,
    #[serde(rename = "wireless-usage-mrc-individual")]
    #[display("wireless-usage-mrc-individual")]
    WirelessUsageMrcIndividual,
    #[serde(rename = "wireless-usage-mrc-pooled")]
    #[display("wireless-usage-mrc-pooled")]
    WirelessUsageMrcPooled,
    #[serde(rename = "wireless-usage-mrc-suspended")]
    #[display("wireless-usage-mrc-suspended")]
    WirelessUsageMrcSuspended,
    #[serde(rename = "wireless-usage-sms")]
    #[display("wireless-usage-sms")]
    WirelessUsageSms,
    #[serde(rename = "wireless-usage-voice")]
    #[display("wireless-usage-voice")]
    WirelessUsageVoice,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountUsageUsageRecordUsageRecordAllTime {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that accrued \
             the usage."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to create the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "Usage records up to date as of this timestamp, formatted as \
             YYYY-MM-DDTHH:MM:SS+00:00. All timestamps are in GMT"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub as_of: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub category: Option<UsageRecordAllTimeEnumCategory>,
    #[doc = "The number of usage events, such as the number of calls."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<String>,
    #[doc = "The units in which `count` is measured, such as `calls` for calls or `messages` for \
             SMS."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count_unit: Option<String>,
    #[doc = "A plain-language description of the usage category."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "The last date for which usage is included in the UsageRecord. The date is specified \
             in GMT and formatted as `YYYY-MM-DD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_date: Option<chrono::NaiveDate>,
    #[doc = "The total price of the usage in the currency specified in `price_unit` and \
             associated with the account."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<f64>,
    #[doc = "The currency in which `price` is measured, in [ISO 4127](https://www.iso.org/iso/home/standards/currency_codes.htm) format, such as `usd`, `eur`, and `jpy`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price_unit: Option<String>,
    #[doc = "The first date for which usage is included in this UsageRecord. The date is \
             specified in GMT and formatted as `YYYY-MM-DD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_date: Option<chrono::NaiveDate>,
    #[doc = "A list of related resources identified by their URIs. For more information, see [List Subresources](https://www.twilio.com/docs/usage/api/usage-record#list-subresources)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "The amount used to bill usage and measured in units described in `usage_unit`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage: Option<String>,
    #[doc = "The units in which `usage` is measured, such as `minutes` for calls or `messages` \
             for SMS."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_unit: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountUsageUsageRecordUsageRecordAllTime {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountUsageUsageRecordUsageRecordAllTime {
    const LENGTH: usize = 15;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(as_of) = &self.as_of {
                format!("{as_of:?}")
            } else {
                String::new()
            },
            if let Some(category) = &self.category {
                format!("{category:?}")
            } else {
                String::new()
            },
            if let Some(count) = &self.count {
                format!("{count:?}")
            } else {
                String::new()
            },
            if let Some(count_unit) = &self.count_unit {
                format!("{count_unit:?}")
            } else {
                String::new()
            },
            if let Some(description) = &self.description {
                format!("{description:?}")
            } else {
                String::new()
            },
            if let Some(end_date) = &self.end_date {
                format!("{end_date:?}")
            } else {
                String::new()
            },
            if let Some(price) = &self.price {
                format!("{price:?}")
            } else {
                String::new()
            },
            if let Some(price_unit) = &self.price_unit {
                format!("{price_unit:?}")
            } else {
                String::new()
            },
            if let Some(start_date) = &self.start_date {
                format!("{start_date:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(usage) = &self.usage {
                format!("{usage:?}")
            } else {
                String::new()
            },
            if let Some(usage_unit) = &self.usage_unit {
                format!("{usage_unit:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "as_of".to_string(),
            "category".to_string(),
            "count".to_string(),
            "count_unit".to_string(),
            "description".to_string(),
            "end_date".to_string(),
            "price".to_string(),
            "price_unit".to_string(),
            "start_date".to_string(),
            "subresource_uris".to_string(),
            "uri".to_string(),
            "usage".to_string(),
            "usage_unit".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UsageRecordAllTimeEnumCategory {
    #[serde(rename = "a2p-registration-fees")]
    #[display("a2p-registration-fees")]
    A2PRegistrationFees,
    #[serde(rename = "agent-conference")]
    #[display("agent-conference")]
    AgentConference,
    #[serde(rename = "amazon-polly")]
    #[display("amazon-polly")]
    AmazonPolly,
    #[serde(rename = "answering-machine-detection")]
    #[display("answering-machine-detection")]
    AnsweringMachineDetection,
    #[serde(rename = "authy-authentications")]
    #[display("authy-authentications")]
    AuthyAuthentications,
    #[serde(rename = "authy-calls-outbound")]
    #[display("authy-calls-outbound")]
    AuthyCallsOutbound,
    #[serde(rename = "authy-monthly-fees")]
    #[display("authy-monthly-fees")]
    AuthyMonthlyFees,
    #[serde(rename = "authy-phone-intelligence")]
    #[display("authy-phone-intelligence")]
    AuthyPhoneIntelligence,
    #[serde(rename = "authy-phone-verifications")]
    #[display("authy-phone-verifications")]
    AuthyPhoneVerifications,
    #[serde(rename = "authy-sms-outbound")]
    #[display("authy-sms-outbound")]
    AuthySmsOutbound,
    #[serde(rename = "call-progess-events")]
    #[display("call-progess-events")]
    CallProgessEvents,
    #[serde(rename = "calleridlookups")]
    #[display("calleridlookups")]
    Calleridlookups,
    #[serde(rename = "calls")]
    #[display("calls")]
    Calls,
    #[serde(rename = "calls-client")]
    #[display("calls-client")]
    CallsClient,
    #[serde(rename = "calls-globalconference")]
    #[display("calls-globalconference")]
    CallsGlobalconference,
    #[serde(rename = "calls-inbound")]
    #[display("calls-inbound")]
    CallsInbound,
    #[serde(rename = "calls-inbound-local")]
    #[display("calls-inbound-local")]
    CallsInboundLocal,
    #[serde(rename = "calls-inbound-mobile")]
    #[display("calls-inbound-mobile")]
    CallsInboundMobile,
    #[serde(rename = "calls-inbound-tollfree")]
    #[display("calls-inbound-tollfree")]
    CallsInboundTollfree,
    #[serde(rename = "calls-outbound")]
    #[display("calls-outbound")]
    CallsOutbound,
    #[serde(rename = "calls-pay-verb-transactions")]
    #[display("calls-pay-verb-transactions")]
    CallsPayVerbTransactions,
    #[serde(rename = "calls-recordings")]
    #[display("calls-recordings")]
    CallsRecordings,
    #[serde(rename = "calls-sip")]
    #[display("calls-sip")]
    CallsSip,
    #[serde(rename = "calls-sip-inbound")]
    #[display("calls-sip-inbound")]
    CallsSipInbound,
    #[serde(rename = "calls-sip-outbound")]
    #[display("calls-sip-outbound")]
    CallsSipOutbound,
    #[serde(rename = "calls-transfers")]
    #[display("calls-transfers")]
    CallsTransfers,
    #[serde(rename = "carrier-lookups")]
    #[display("carrier-lookups")]
    CarrierLookups,
    #[serde(rename = "conversations")]
    #[display("conversations")]
    Conversations,
    #[serde(rename = "conversations-api-requests")]
    #[display("conversations-api-requests")]
    ConversationsApiRequests,
    #[serde(rename = "conversations-conversation-events")]
    #[display("conversations-conversation-events")]
    ConversationsConversationEvents,
    #[serde(rename = "conversations-endpoint-connectivity")]
    #[display("conversations-endpoint-connectivity")]
    ConversationsEndpointConnectivity,
    #[serde(rename = "conversations-events")]
    #[display("conversations-events")]
    ConversationsEvents,
    #[serde(rename = "conversations-participant-events")]
    #[display("conversations-participant-events")]
    ConversationsParticipantEvents,
    #[serde(rename = "conversations-participants")]
    #[display("conversations-participants")]
    ConversationsParticipants,
    #[serde(rename = "cps")]
    #[display("cps")]
    Cps,
    #[serde(rename = "flex-usage")]
    #[display("flex-usage")]
    FlexUsage,
    #[serde(rename = "fraud-lookups")]
    #[display("fraud-lookups")]
    FraudLookups,
    #[serde(rename = "group-rooms")]
    #[display("group-rooms")]
    GroupRooms,
    #[serde(rename = "group-rooms-data-track")]
    #[display("group-rooms-data-track")]
    GroupRoomsDataTrack,
    #[serde(rename = "group-rooms-encrypted-media-recorded")]
    #[display("group-rooms-encrypted-media-recorded")]
    GroupRoomsEncryptedMediaRecorded,
    #[serde(rename = "group-rooms-media-downloaded")]
    #[display("group-rooms-media-downloaded")]
    GroupRoomsMediaDownloaded,
    #[serde(rename = "group-rooms-media-recorded")]
    #[display("group-rooms-media-recorded")]
    GroupRoomsMediaRecorded,
    #[serde(rename = "group-rooms-media-routed")]
    #[display("group-rooms-media-routed")]
    GroupRoomsMediaRouted,
    #[serde(rename = "group-rooms-media-stored")]
    #[display("group-rooms-media-stored")]
    GroupRoomsMediaStored,
    #[serde(rename = "group-rooms-participant-minutes")]
    #[display("group-rooms-participant-minutes")]
    GroupRoomsParticipantMinutes,
    #[serde(rename = "group-rooms-recorded-minutes")]
    #[display("group-rooms-recorded-minutes")]
    GroupRoomsRecordedMinutes,
    #[serde(rename = "imp-v1-usage")]
    #[display("imp-v1-usage")]
    ImpUsage,
    #[serde(rename = "lookups")]
    #[display("lookups")]
    Lookups,
    #[serde(rename = "marketplace")]
    #[display("marketplace")]
    Marketplace,
    #[serde(rename = "marketplace-algorithmia-named-entity-recognition")]
    #[display("marketplace-algorithmia-named-entity-recognition")]
    MarketplaceAlgorithmiaNamedEntityRecognition,
    #[serde(rename = "marketplace-cadence-transcription")]
    #[display("marketplace-cadence-transcription")]
    MarketplaceCadenceTranscription,
    #[serde(rename = "marketplace-cadence-translation")]
    #[display("marketplace-cadence-translation")]
    MarketplaceCadenceTranslation,
    #[serde(rename = "marketplace-capio-speech-to-text")]
    #[display("marketplace-capio-speech-to-text")]
    MarketplaceCapioSpeechToText,
    #[serde(rename = "marketplace-convriza-ababa")]
    #[display("marketplace-convriza-ababa")]
    MarketplaceConvrizaAbaba,
    #[serde(rename = "marketplace-deepgram-phrase-detector")]
    #[display("marketplace-deepgram-phrase-detector")]
    MarketplaceDeepgramPhraseDetector,
    #[serde(rename = "marketplace-digital-segment-business-info")]
    #[display("marketplace-digital-segment-business-info")]
    MarketplaceDigitalSegmentBusinessInfo,
    #[serde(rename = "marketplace-facebook-offline-conversions")]
    #[display("marketplace-facebook-offline-conversions")]
    MarketplaceFacebookOfflineConversions,
    #[serde(rename = "marketplace-google-speech-to-text")]
    #[display("marketplace-google-speech-to-text")]
    MarketplaceGoogleSpeechToText,
    #[serde(rename = "marketplace-ibm-watson-message-insights")]
    #[display("marketplace-ibm-watson-message-insights")]
    MarketplaceIbmWatsonMessageInsights,
    #[serde(rename = "marketplace-ibm-watson-message-sentiment")]
    #[display("marketplace-ibm-watson-message-sentiment")]
    MarketplaceIbmWatsonMessageSentiment,
    #[serde(rename = "marketplace-ibm-watson-recording-analysis")]
    #[display("marketplace-ibm-watson-recording-analysis")]
    MarketplaceIbmWatsonRecordingAnalysis,
    #[serde(rename = "marketplace-ibm-watson-tone-analyzer")]
    #[display("marketplace-ibm-watson-tone-analyzer")]
    MarketplaceIbmWatsonToneAnalyzer,
    #[serde(rename = "marketplace-icehook-systems-scout")]
    #[display("marketplace-icehook-systems-scout")]
    MarketplaceIcehookSystemsScout,
    #[serde(rename = "marketplace-infogroup-dataaxle-bizinfo")]
    #[display("marketplace-infogroup-dataaxle-bizinfo")]
    MarketplaceInfogroupDataaxleBizinfo,
    #[serde(rename = "marketplace-keen-io-contact-center-analytics")]
    #[display("marketplace-keen-io-contact-center-analytics")]
    MarketplaceKeenIoContactCenterAnalytics,
    #[serde(rename = "marketplace-marchex-cleancall")]
    #[display("marketplace-marchex-cleancall")]
    MarketplaceMarchexCleancall,
    #[serde(rename = "marketplace-marchex-sentiment-analysis-for-sms")]
    #[display("marketplace-marchex-sentiment-analysis-for-sms")]
    MarketplaceMarchexSentimentAnalysisForSms,
    #[serde(rename = "marketplace-marketplace-nextcaller-social-id")]
    #[display("marketplace-marketplace-nextcaller-social-id")]
    MarketplaceMarketplaceNextcallerSocialId,
    #[serde(rename = "marketplace-mobile-commons-opt-out-classifier")]
    #[display("marketplace-mobile-commons-opt-out-classifier")]
    MarketplaceMobileCommonsOptOutClassifier,
    #[serde(rename = "marketplace-nexiwave-voicemail-to-text")]
    #[display("marketplace-nexiwave-voicemail-to-text")]
    MarketplaceNexiwaveVoicemailToText,
    #[serde(rename = "marketplace-nextcaller-advanced-caller-identification")]
    #[display("marketplace-nextcaller-advanced-caller-identification")]
    MarketplaceNextcallerAdvancedCallerIdentification,
    #[serde(rename = "marketplace-nomorobo-spam-score")]
    #[display("marketplace-nomorobo-spam-score")]
    MarketplaceNomoroboSpamScore,
    #[serde(rename = "marketplace-payfone-tcpa-compliance")]
    #[display("marketplace-payfone-tcpa-compliance")]
    MarketplacePayfoneTcpaCompliance,
    #[serde(rename = "marketplace-remeeting-automatic-speech-recognition")]
    #[display("marketplace-remeeting-automatic-speech-recognition")]
    MarketplaceRemeetingAutomaticSpeechRecognition,
    #[serde(rename = "marketplace-tcpa-defense-solutions-blacklist-feed")]
    #[display("marketplace-tcpa-defense-solutions-blacklist-feed")]
    MarketplaceTcpaDefenseSolutionsBlacklistFeed,
    #[serde(rename = "marketplace-telo-opencnam")]
    #[display("marketplace-telo-opencnam")]
    MarketplaceTeloOpencnam,
    #[serde(rename = "marketplace-truecnam-true-spam")]
    #[display("marketplace-truecnam-true-spam")]
    MarketplaceTruecnamTrueSpam,
    #[serde(rename = "marketplace-twilio-caller-name-lookup-us")]
    #[display("marketplace-twilio-caller-name-lookup-us")]
    MarketplaceTwilioCallerNameLookupUs,
    #[serde(rename = "marketplace-twilio-carrier-information-lookup")]
    #[display("marketplace-twilio-carrier-information-lookup")]
    MarketplaceTwilioCarrierInformationLookup,
    #[serde(rename = "marketplace-voicebase-pci")]
    #[display("marketplace-voicebase-pci")]
    MarketplaceVoicebasePci,
    #[serde(rename = "marketplace-voicebase-transcription")]
    #[display("marketplace-voicebase-transcription")]
    MarketplaceVoicebaseTranscription,
    #[serde(rename = "marketplace-voicebase-transcription-custom-vocabulary")]
    #[display("marketplace-voicebase-transcription-custom-vocabulary")]
    MarketplaceVoicebaseTranscriptionCustomVocabulary,
    #[serde(rename = "marketplace-whitepages-pro-caller-identification")]
    #[display("marketplace-whitepages-pro-caller-identification")]
    MarketplaceWhitepagesProCallerIdentification,
    #[serde(rename = "marketplace-whitepages-pro-phone-intelligence")]
    #[display("marketplace-whitepages-pro-phone-intelligence")]
    MarketplaceWhitepagesProPhoneIntelligence,
    #[serde(rename = "marketplace-whitepages-pro-phone-reputation")]
    #[display("marketplace-whitepages-pro-phone-reputation")]
    MarketplaceWhitepagesProPhoneReputation,
    #[serde(rename = "marketplace-wolfarm-spoken-results")]
    #[display("marketplace-wolfarm-spoken-results")]
    MarketplaceWolfarmSpokenResults,
    #[serde(rename = "marketplace-wolfram-short-answer")]
    #[display("marketplace-wolfram-short-answer")]
    MarketplaceWolframShortAnswer,
    #[serde(rename = "marketplace-ytica-contact-center-reporting-analytics")]
    #[display("marketplace-ytica-contact-center-reporting-analytics")]
    MarketplaceYticaContactCenterReportingAnalytics,
    #[serde(rename = "mediastorage")]
    #[display("mediastorage")]
    Mediastorage,
    #[serde(rename = "mms")]
    #[display("mms")]
    Mms,
    #[serde(rename = "mms-inbound")]
    #[display("mms-inbound")]
    MmsInbound,
    #[serde(rename = "mms-inbound-longcode")]
    #[display("mms-inbound-longcode")]
    MmsInboundLongcode,
    #[serde(rename = "mms-inbound-shortcode")]
    #[display("mms-inbound-shortcode")]
    MmsInboundShortcode,
    #[serde(rename = "mms-messages-carrierfees")]
    #[display("mms-messages-carrierfees")]
    MmsMessagesCarrierfees,
    #[serde(rename = "mms-outbound")]
    #[display("mms-outbound")]
    MmsOutbound,
    #[serde(rename = "mms-outbound-longcode")]
    #[display("mms-outbound-longcode")]
    MmsOutboundLongcode,
    #[serde(rename = "mms-outbound-shortcode")]
    #[display("mms-outbound-shortcode")]
    MmsOutboundShortcode,
    #[serde(rename = "monitor-reads")]
    #[display("monitor-reads")]
    MonitorReads,
    #[serde(rename = "monitor-storage")]
    #[display("monitor-storage")]
    MonitorStorage,
    #[serde(rename = "monitor-writes")]
    #[display("monitor-writes")]
    MonitorWrites,
    #[serde(rename = "notify")]
    #[display("notify")]
    Notify,
    #[serde(rename = "notify-actions-attempts")]
    #[display("notify-actions-attempts")]
    NotifyActionsAttempts,
    #[serde(rename = "notify-channels")]
    #[display("notify-channels")]
    NotifyChannels,
    #[serde(rename = "number-format-lookups")]
    #[display("number-format-lookups")]
    NumberFormatLookups,
    #[serde(rename = "pchat")]
    #[display("pchat")]
    Pchat,
    #[serde(rename = "pchat-users")]
    #[display("pchat-users")]
    PchatUsers,
    #[serde(rename = "peer-to-peer-rooms-participant-minutes")]
    #[display("peer-to-peer-rooms-participant-minutes")]
    PeerToPeerRoomsParticipantMinutes,
    #[serde(rename = "pfax")]
    #[display("pfax")]
    Pfax,
    #[serde(rename = "pfax-minutes")]
    #[display("pfax-minutes")]
    PfaxMinutes,
    #[serde(rename = "pfax-minutes-inbound")]
    #[display("pfax-minutes-inbound")]
    PfaxMinutesInbound,
    #[serde(rename = "pfax-minutes-outbound")]
    #[display("pfax-minutes-outbound")]
    PfaxMinutesOutbound,
    #[serde(rename = "pfax-pages")]
    #[display("pfax-pages")]
    PfaxPages,
    #[serde(rename = "phonenumbers")]
    #[display("phonenumbers")]
    Phonenumbers,
    #[serde(rename = "phonenumbers-cps")]
    #[display("phonenumbers-cps")]
    PhonenumbersCps,
    #[serde(rename = "phonenumbers-emergency")]
    #[display("phonenumbers-emergency")]
    PhonenumbersEmergency,
    #[serde(rename = "phonenumbers-local")]
    #[display("phonenumbers-local")]
    PhonenumbersLocal,
    #[serde(rename = "phonenumbers-mobile")]
    #[display("phonenumbers-mobile")]
    PhonenumbersMobile,
    #[serde(rename = "phonenumbers-setups")]
    #[display("phonenumbers-setups")]
    PhonenumbersSetups,
    #[serde(rename = "phonenumbers-tollfree")]
    #[display("phonenumbers-tollfree")]
    PhonenumbersTollfree,
    #[serde(rename = "premiumsupport")]
    #[display("premiumsupport")]
    Premiumsupport,
    #[serde(rename = "proxy")]
    #[display("proxy")]
    Proxy,
    #[serde(rename = "proxy-active-sessions")]
    #[display("proxy-active-sessions")]
    ProxyActiveSessions,
    #[serde(rename = "pstnconnectivity")]
    #[display("pstnconnectivity")]
    Pstnconnectivity,
    #[serde(rename = "pv")]
    #[display("pv")]
    Pv,
    #[serde(rename = "pv-composition-media-downloaded")]
    #[display("pv-composition-media-downloaded")]
    PvCompositionMediaDownloaded,
    #[serde(rename = "pv-composition-media-encrypted")]
    #[display("pv-composition-media-encrypted")]
    PvCompositionMediaEncrypted,
    #[serde(rename = "pv-composition-media-stored")]
    #[display("pv-composition-media-stored")]
    PvCompositionMediaStored,
    #[serde(rename = "pv-composition-minutes")]
    #[display("pv-composition-minutes")]
    PvCompositionMinutes,
    #[serde(rename = "pv-recording-compositions")]
    #[display("pv-recording-compositions")]
    PvRecordingCompositions,
    #[serde(rename = "pv-room-participants")]
    #[display("pv-room-participants")]
    PvRoomParticipants,
    #[serde(rename = "pv-room-participants-au1")]
    #[display("pv-room-participants-au1")]
    PvRoomParticipantsAu1,
    #[serde(rename = "pv-room-participants-br1")]
    #[display("pv-room-participants-br1")]
    PvRoomParticipantsBr1,
    #[serde(rename = "pv-room-participants-ie1")]
    #[display("pv-room-participants-ie1")]
    PvRoomParticipantsIe1,
    #[serde(rename = "pv-room-participants-jp1")]
    #[display("pv-room-participants-jp1")]
    PvRoomParticipantsJp1,
    #[serde(rename = "pv-room-participants-sg1")]
    #[display("pv-room-participants-sg1")]
    PvRoomParticipantsSg1,
    #[serde(rename = "pv-room-participants-us1")]
    #[display("pv-room-participants-us1")]
    PvRoomParticipantsUs1,
    #[serde(rename = "pv-room-participants-us2")]
    #[display("pv-room-participants-us2")]
    PvRoomParticipantsUs2,
    #[serde(rename = "pv-rooms")]
    #[display("pv-rooms")]
    PvRooms,
    #[serde(rename = "pv-sip-endpoint-registrations")]
    #[display("pv-sip-endpoint-registrations")]
    PvSipEndpointRegistrations,
    #[serde(rename = "recordings")]
    #[display("recordings")]
    Recordings,
    #[serde(rename = "recordingstorage")]
    #[display("recordingstorage")]
    Recordingstorage,
    #[serde(rename = "rooms-group-bandwidth")]
    #[display("rooms-group-bandwidth")]
    RoomsGroupBandwidth,
    #[serde(rename = "rooms-group-minutes")]
    #[display("rooms-group-minutes")]
    RoomsGroupMinutes,
    #[serde(rename = "rooms-peer-to-peer-minutes")]
    #[display("rooms-peer-to-peer-minutes")]
    RoomsPeerToPeerMinutes,
    #[serde(rename = "shortcodes")]
    #[display("shortcodes")]
    Shortcodes,
    #[serde(rename = "shortcodes-customerowned")]
    #[display("shortcodes-customerowned")]
    ShortcodesCustomerowned,
    #[serde(rename = "shortcodes-mms-enablement")]
    #[display("shortcodes-mms-enablement")]
    ShortcodesMmsEnablement,
    #[serde(rename = "shortcodes-mps")]
    #[display("shortcodes-mps")]
    ShortcodesMps,
    #[serde(rename = "shortcodes-random")]
    #[display("shortcodes-random")]
    ShortcodesRandom,
    #[serde(rename = "shortcodes-uk")]
    #[display("shortcodes-uk")]
    ShortcodesUk,
    #[serde(rename = "shortcodes-vanity")]
    #[display("shortcodes-vanity")]
    ShortcodesVanity,
    #[serde(rename = "small-group-rooms")]
    #[display("small-group-rooms")]
    SmallGroupRooms,
    #[serde(rename = "small-group-rooms-data-track")]
    #[display("small-group-rooms-data-track")]
    SmallGroupRoomsDataTrack,
    #[serde(rename = "small-group-rooms-participant-minutes")]
    #[display("small-group-rooms-participant-minutes")]
    SmallGroupRoomsParticipantMinutes,
    #[serde(rename = "sms")]
    #[display("sms")]
    Sms,
    #[serde(rename = "sms-inbound")]
    #[display("sms-inbound")]
    SmsInbound,
    #[serde(rename = "sms-inbound-longcode")]
    #[display("sms-inbound-longcode")]
    SmsInboundLongcode,
    #[serde(rename = "sms-inbound-shortcode")]
    #[display("sms-inbound-shortcode")]
    SmsInboundShortcode,
    #[serde(rename = "sms-messages-carrierfees")]
    #[display("sms-messages-carrierfees")]
    SmsMessagesCarrierfees,
    #[serde(rename = "sms-messages-features")]
    #[display("sms-messages-features")]
    SmsMessagesFeatures,
    #[serde(rename = "sms-messages-features-senderid")]
    #[display("sms-messages-features-senderid")]
    SmsMessagesFeaturesSenderid,
    #[serde(rename = "sms-outbound")]
    #[display("sms-outbound")]
    SmsOutbound,
    #[serde(rename = "sms-outbound-content-inspection")]
    #[display("sms-outbound-content-inspection")]
    SmsOutboundContentInspection,
    #[serde(rename = "sms-outbound-longcode")]
    #[display("sms-outbound-longcode")]
    SmsOutboundLongcode,
    #[serde(rename = "sms-outbound-shortcode")]
    #[display("sms-outbound-shortcode")]
    SmsOutboundShortcode,
    #[serde(rename = "speech-recognition")]
    #[display("speech-recognition")]
    SpeechRecognition,
    #[serde(rename = "studio-engagements")]
    #[display("studio-engagements")]
    StudioEngagements,
    #[serde(rename = "sync")]
    #[display("sync")]
    Sync,
    #[serde(rename = "sync-actions")]
    #[display("sync-actions")]
    SyncActions,
    #[serde(rename = "sync-endpoint-hours")]
    #[display("sync-endpoint-hours")]
    SyncEndpointHours,
    #[serde(rename = "sync-endpoint-hours-above-daily-cap")]
    #[display("sync-endpoint-hours-above-daily-cap")]
    SyncEndpointHoursAboveDailyCap,
    #[serde(rename = "taskrouter-tasks")]
    #[display("taskrouter-tasks")]
    TaskrouterTasks,
    #[serde(rename = "totalprice")]
    #[display("totalprice")]
    Totalprice,
    #[serde(rename = "transcriptions")]
    #[display("transcriptions")]
    Transcriptions,
    #[serde(rename = "trunking-cps")]
    #[display("trunking-cps")]
    TrunkingCps,
    #[serde(rename = "trunking-emergency-calls")]
    #[display("trunking-emergency-calls")]
    TrunkingEmergencyCalls,
    #[serde(rename = "trunking-origination")]
    #[display("trunking-origination")]
    TrunkingOrigination,
    #[serde(rename = "trunking-origination-local")]
    #[display("trunking-origination-local")]
    TrunkingOriginationLocal,
    #[serde(rename = "trunking-origination-mobile")]
    #[display("trunking-origination-mobile")]
    TrunkingOriginationMobile,
    #[serde(rename = "trunking-origination-tollfree")]
    #[display("trunking-origination-tollfree")]
    TrunkingOriginationTollfree,
    #[serde(rename = "trunking-recordings")]
    #[display("trunking-recordings")]
    TrunkingRecordings,
    #[serde(rename = "trunking-secure")]
    #[display("trunking-secure")]
    TrunkingSecure,
    #[serde(rename = "trunking-termination")]
    #[display("trunking-termination")]
    TrunkingTermination,
    #[serde(rename = "turnmegabytes")]
    #[display("turnmegabytes")]
    Turnmegabytes,
    #[serde(rename = "turnmegabytes-australia")]
    #[display("turnmegabytes-australia")]
    TurnmegabytesAustralia,
    #[serde(rename = "turnmegabytes-brasil")]
    #[display("turnmegabytes-brasil")]
    TurnmegabytesBrasil,
    #[serde(rename = "turnmegabytes-germany")]
    #[display("turnmegabytes-germany")]
    TurnmegabytesGermany,
    #[serde(rename = "turnmegabytes-india")]
    #[display("turnmegabytes-india")]
    TurnmegabytesIndia,
    #[serde(rename = "turnmegabytes-ireland")]
    #[display("turnmegabytes-ireland")]
    TurnmegabytesIreland,
    #[serde(rename = "turnmegabytes-japan")]
    #[display("turnmegabytes-japan")]
    TurnmegabytesJapan,
    #[serde(rename = "turnmegabytes-singapore")]
    #[display("turnmegabytes-singapore")]
    TurnmegabytesSingapore,
    #[serde(rename = "turnmegabytes-useast")]
    #[display("turnmegabytes-useast")]
    TurnmegabytesUseast,
    #[serde(rename = "turnmegabytes-uswest")]
    #[display("turnmegabytes-uswest")]
    TurnmegabytesUswest,
    #[serde(rename = "twilio-interconnect")]
    #[display("twilio-interconnect")]
    TwilioInterconnect,
    #[serde(rename = "verify-push")]
    #[display("verify-push")]
    VerifyPush,
    #[serde(rename = "verify-totp")]
    #[display("verify-totp")]
    VerifyTotp,
    #[serde(rename = "verify-whatsapp-conversations-business-initiated")]
    #[display("verify-whatsapp-conversations-business-initiated")]
    VerifyWhatsappConversationsBusinessInitiated,
    #[serde(rename = "video-recordings")]
    #[display("video-recordings")]
    VideoRecordings,
    #[serde(rename = "virtual-agent")]
    #[display("virtual-agent")]
    VirtualAgent,
    #[serde(rename = "voice-insights")]
    #[display("voice-insights")]
    VoiceInsights,
    #[serde(rename = "voice-insights-client-insights-on-demand-minute")]
    #[display("voice-insights-client-insights-on-demand-minute")]
    VoiceInsightsClientInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-ptsn-insights-on-demand-minute")]
    #[display("voice-insights-ptsn-insights-on-demand-minute")]
    VoiceInsightsPtsnInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-interface-insights-on-demand-minute")]
    #[display("voice-insights-sip-interface-insights-on-demand-minute")]
    VoiceInsightsSipInterfaceInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-trunking-insights-on-demand-minute")]
    #[display("voice-insights-sip-trunking-insights-on-demand-minute")]
    VoiceInsightsSipTrunkingInsightsOnDemandMinute,
    #[serde(rename = "wireless")]
    #[display("wireless")]
    Wireless,
    #[serde(rename = "wireless-orders")]
    #[display("wireless-orders")]
    WirelessOrders,
    #[serde(rename = "wireless-orders-artwork")]
    #[display("wireless-orders-artwork")]
    WirelessOrdersArtwork,
    #[serde(rename = "wireless-orders-bulk")]
    #[display("wireless-orders-bulk")]
    WirelessOrdersBulk,
    #[serde(rename = "wireless-orders-esim")]
    #[display("wireless-orders-esim")]
    WirelessOrdersEsim,
    #[serde(rename = "wireless-orders-starter")]
    #[display("wireless-orders-starter")]
    WirelessOrdersStarter,
    #[serde(rename = "wireless-usage")]
    #[display("wireless-usage")]
    WirelessUsage,
    #[serde(rename = "wireless-usage-commands")]
    #[display("wireless-usage-commands")]
    WirelessUsageCommands,
    #[serde(rename = "wireless-usage-commands-africa")]
    #[display("wireless-usage-commands-africa")]
    WirelessUsageCommandsAfrica,
    #[serde(rename = "wireless-usage-commands-asia")]
    #[display("wireless-usage-commands-asia")]
    WirelessUsageCommandsAsia,
    #[serde(rename = "wireless-usage-commands-centralandsouthamerica")]
    #[display("wireless-usage-commands-centralandsouthamerica")]
    WirelessUsageCommandsCentralandsouthamerica,
    #[serde(rename = "wireless-usage-commands-europe")]
    #[display("wireless-usage-commands-europe")]
    WirelessUsageCommandsEurope,
    #[serde(rename = "wireless-usage-commands-home")]
    #[display("wireless-usage-commands-home")]
    WirelessUsageCommandsHome,
    #[serde(rename = "wireless-usage-commands-northamerica")]
    #[display("wireless-usage-commands-northamerica")]
    WirelessUsageCommandsNorthamerica,
    #[serde(rename = "wireless-usage-commands-oceania")]
    #[display("wireless-usage-commands-oceania")]
    WirelessUsageCommandsOceania,
    #[serde(rename = "wireless-usage-commands-roaming")]
    #[display("wireless-usage-commands-roaming")]
    WirelessUsageCommandsRoaming,
    #[serde(rename = "wireless-usage-data")]
    #[display("wireless-usage-data")]
    WirelessUsageData,
    #[serde(rename = "wireless-usage-data-africa")]
    #[display("wireless-usage-data-africa")]
    WirelessUsageDataAfrica,
    #[serde(rename = "wireless-usage-data-asia")]
    #[display("wireless-usage-data-asia")]
    WirelessUsageDataAsia,
    #[serde(rename = "wireless-usage-data-centralandsouthamerica")]
    #[display("wireless-usage-data-centralandsouthamerica")]
    WirelessUsageDataCentralandsouthamerica,
    #[serde(rename = "wireless-usage-data-custom-additionalmb")]
    #[display("wireless-usage-data-custom-additionalmb")]
    WirelessUsageDataCustomAdditionalmb,
    #[serde(rename = "wireless-usage-data-custom-first5mb")]
    #[display("wireless-usage-data-custom-first5mb")]
    WirelessUsageDataCustomFirst5Mb,
    #[serde(rename = "wireless-usage-data-domestic-roaming")]
    #[display("wireless-usage-data-domestic-roaming")]
    WirelessUsageDataDomesticRoaming,
    #[serde(rename = "wireless-usage-data-europe")]
    #[display("wireless-usage-data-europe")]
    WirelessUsageDataEurope,
    #[serde(rename = "wireless-usage-data-individual-additionalgb")]
    #[display("wireless-usage-data-individual-additionalgb")]
    WirelessUsageDataIndividualAdditionalgb,
    #[serde(rename = "wireless-usage-data-individual-firstgb")]
    #[display("wireless-usage-data-individual-firstgb")]
    WirelessUsageDataIndividualFirstgb,
    #[serde(rename = "wireless-usage-data-international-roaming-canada")]
    #[display("wireless-usage-data-international-roaming-canada")]
    WirelessUsageDataInternationalRoamingCanada,
    #[serde(rename = "wireless-usage-data-international-roaming-india")]
    #[display("wireless-usage-data-international-roaming-india")]
    WirelessUsageDataInternationalRoamingIndia,
    #[serde(rename = "wireless-usage-data-international-roaming-mexico")]
    #[display("wireless-usage-data-international-roaming-mexico")]
    WirelessUsageDataInternationalRoamingMexico,
    #[serde(rename = "wireless-usage-data-northamerica")]
    #[display("wireless-usage-data-northamerica")]
    WirelessUsageDataNorthamerica,
    #[serde(rename = "wireless-usage-data-oceania")]
    #[display("wireless-usage-data-oceania")]
    WirelessUsageDataOceania,
    #[serde(rename = "wireless-usage-data-pooled")]
    #[display("wireless-usage-data-pooled")]
    WirelessUsageDataPooled,
    #[serde(rename = "wireless-usage-data-pooled-downlink")]
    #[display("wireless-usage-data-pooled-downlink")]
    WirelessUsageDataPooledDownlink,
    #[serde(rename = "wireless-usage-data-pooled-uplink")]
    #[display("wireless-usage-data-pooled-uplink")]
    WirelessUsageDataPooledUplink,
    #[serde(rename = "wireless-usage-mrc")]
    #[display("wireless-usage-mrc")]
    WirelessUsageMrc,
    #[serde(rename = "wireless-usage-mrc-custom")]
    #[display("wireless-usage-mrc-custom")]
    WirelessUsageMrcCustom,
    #[serde(rename = "wireless-usage-mrc-individual")]
    #[display("wireless-usage-mrc-individual")]
    WirelessUsageMrcIndividual,
    #[serde(rename = "wireless-usage-mrc-pooled")]
    #[display("wireless-usage-mrc-pooled")]
    WirelessUsageMrcPooled,
    #[serde(rename = "wireless-usage-mrc-suspended")]
    #[display("wireless-usage-mrc-suspended")]
    WirelessUsageMrcSuspended,
    #[serde(rename = "wireless-usage-sms")]
    #[display("wireless-usage-sms")]
    WirelessUsageSms,
    #[serde(rename = "wireless-usage-voice")]
    #[display("wireless-usage-voice")]
    WirelessUsageVoice,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountUsageUsageRecordUsageRecordDaily {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that accrued \
             the usage."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to create the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "Usage records up to date as of this timestamp, formatted as \
             YYYY-MM-DDTHH:MM:SS+00:00. All timestamps are in GMT"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub as_of: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub category: Option<UsageRecordDailyEnumCategory>,
    #[doc = "The number of usage events, such as the number of calls."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<String>,
    #[doc = "The units in which `count` is measured, such as `calls` for calls or `messages` for \
             SMS."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count_unit: Option<String>,
    #[doc = "A plain-language description of the usage category."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "The last date for which usage is included in the UsageRecord. The date is specified \
             in GMT and formatted as `YYYY-MM-DD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_date: Option<chrono::NaiveDate>,
    #[doc = "The total price of the usage in the currency specified in `price_unit` and \
             associated with the account."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<f64>,
    #[doc = "The currency in which `price` is measured, in [ISO 4127](https://www.iso.org/iso/home/standards/currency_codes.htm) format, such as `usd`, `eur`, and `jpy`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price_unit: Option<String>,
    #[doc = "The first date for which usage is included in this UsageRecord. The date is \
             specified in GMT and formatted as `YYYY-MM-DD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_date: Option<chrono::NaiveDate>,
    #[doc = "A list of related resources identified by their URIs. For more information, see [List Subresources](https://www.twilio.com/docs/usage/api/usage-record#list-subresources)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "The amount used to bill usage and measured in units described in `usage_unit`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage: Option<String>,
    #[doc = "The units in which `usage` is measured, such as `minutes` for calls or `messages` \
             for SMS."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_unit: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountUsageUsageRecordUsageRecordDaily {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountUsageUsageRecordUsageRecordDaily {
    const LENGTH: usize = 15;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(as_of) = &self.as_of {
                format!("{as_of:?}")
            } else {
                String::new()
            },
            if let Some(category) = &self.category {
                format!("{category:?}")
            } else {
                String::new()
            },
            if let Some(count) = &self.count {
                format!("{count:?}")
            } else {
                String::new()
            },
            if let Some(count_unit) = &self.count_unit {
                format!("{count_unit:?}")
            } else {
                String::new()
            },
            if let Some(description) = &self.description {
                format!("{description:?}")
            } else {
                String::new()
            },
            if let Some(end_date) = &self.end_date {
                format!("{end_date:?}")
            } else {
                String::new()
            },
            if let Some(price) = &self.price {
                format!("{price:?}")
            } else {
                String::new()
            },
            if let Some(price_unit) = &self.price_unit {
                format!("{price_unit:?}")
            } else {
                String::new()
            },
            if let Some(start_date) = &self.start_date {
                format!("{start_date:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(usage) = &self.usage {
                format!("{usage:?}")
            } else {
                String::new()
            },
            if let Some(usage_unit) = &self.usage_unit {
                format!("{usage_unit:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "as_of".to_string(),
            "category".to_string(),
            "count".to_string(),
            "count_unit".to_string(),
            "description".to_string(),
            "end_date".to_string(),
            "price".to_string(),
            "price_unit".to_string(),
            "start_date".to_string(),
            "subresource_uris".to_string(),
            "uri".to_string(),
            "usage".to_string(),
            "usage_unit".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UsageRecordDailyEnumCategory {
    #[serde(rename = "a2p-registration-fees")]
    #[display("a2p-registration-fees")]
    A2PRegistrationFees,
    #[serde(rename = "agent-conference")]
    #[display("agent-conference")]
    AgentConference,
    #[serde(rename = "amazon-polly")]
    #[display("amazon-polly")]
    AmazonPolly,
    #[serde(rename = "answering-machine-detection")]
    #[display("answering-machine-detection")]
    AnsweringMachineDetection,
    #[serde(rename = "authy-authentications")]
    #[display("authy-authentications")]
    AuthyAuthentications,
    #[serde(rename = "authy-calls-outbound")]
    #[display("authy-calls-outbound")]
    AuthyCallsOutbound,
    #[serde(rename = "authy-monthly-fees")]
    #[display("authy-monthly-fees")]
    AuthyMonthlyFees,
    #[serde(rename = "authy-phone-intelligence")]
    #[display("authy-phone-intelligence")]
    AuthyPhoneIntelligence,
    #[serde(rename = "authy-phone-verifications")]
    #[display("authy-phone-verifications")]
    AuthyPhoneVerifications,
    #[serde(rename = "authy-sms-outbound")]
    #[display("authy-sms-outbound")]
    AuthySmsOutbound,
    #[serde(rename = "call-progess-events")]
    #[display("call-progess-events")]
    CallProgessEvents,
    #[serde(rename = "calleridlookups")]
    #[display("calleridlookups")]
    Calleridlookups,
    #[serde(rename = "calls")]
    #[display("calls")]
    Calls,
    #[serde(rename = "calls-client")]
    #[display("calls-client")]
    CallsClient,
    #[serde(rename = "calls-globalconference")]
    #[display("calls-globalconference")]
    CallsGlobalconference,
    #[serde(rename = "calls-inbound")]
    #[display("calls-inbound")]
    CallsInbound,
    #[serde(rename = "calls-inbound-local")]
    #[display("calls-inbound-local")]
    CallsInboundLocal,
    #[serde(rename = "calls-inbound-mobile")]
    #[display("calls-inbound-mobile")]
    CallsInboundMobile,
    #[serde(rename = "calls-inbound-tollfree")]
    #[display("calls-inbound-tollfree")]
    CallsInboundTollfree,
    #[serde(rename = "calls-outbound")]
    #[display("calls-outbound")]
    CallsOutbound,
    #[serde(rename = "calls-pay-verb-transactions")]
    #[display("calls-pay-verb-transactions")]
    CallsPayVerbTransactions,
    #[serde(rename = "calls-recordings")]
    #[display("calls-recordings")]
    CallsRecordings,
    #[serde(rename = "calls-sip")]
    #[display("calls-sip")]
    CallsSip,
    #[serde(rename = "calls-sip-inbound")]
    #[display("calls-sip-inbound")]
    CallsSipInbound,
    #[serde(rename = "calls-sip-outbound")]
    #[display("calls-sip-outbound")]
    CallsSipOutbound,
    #[serde(rename = "calls-transfers")]
    #[display("calls-transfers")]
    CallsTransfers,
    #[serde(rename = "carrier-lookups")]
    #[display("carrier-lookups")]
    CarrierLookups,
    #[serde(rename = "conversations")]
    #[display("conversations")]
    Conversations,
    #[serde(rename = "conversations-api-requests")]
    #[display("conversations-api-requests")]
    ConversationsApiRequests,
    #[serde(rename = "conversations-conversation-events")]
    #[display("conversations-conversation-events")]
    ConversationsConversationEvents,
    #[serde(rename = "conversations-endpoint-connectivity")]
    #[display("conversations-endpoint-connectivity")]
    ConversationsEndpointConnectivity,
    #[serde(rename = "conversations-events")]
    #[display("conversations-events")]
    ConversationsEvents,
    #[serde(rename = "conversations-participant-events")]
    #[display("conversations-participant-events")]
    ConversationsParticipantEvents,
    #[serde(rename = "conversations-participants")]
    #[display("conversations-participants")]
    ConversationsParticipants,
    #[serde(rename = "cps")]
    #[display("cps")]
    Cps,
    #[serde(rename = "flex-usage")]
    #[display("flex-usage")]
    FlexUsage,
    #[serde(rename = "fraud-lookups")]
    #[display("fraud-lookups")]
    FraudLookups,
    #[serde(rename = "group-rooms")]
    #[display("group-rooms")]
    GroupRooms,
    #[serde(rename = "group-rooms-data-track")]
    #[display("group-rooms-data-track")]
    GroupRoomsDataTrack,
    #[serde(rename = "group-rooms-encrypted-media-recorded")]
    #[display("group-rooms-encrypted-media-recorded")]
    GroupRoomsEncryptedMediaRecorded,
    #[serde(rename = "group-rooms-media-downloaded")]
    #[display("group-rooms-media-downloaded")]
    GroupRoomsMediaDownloaded,
    #[serde(rename = "group-rooms-media-recorded")]
    #[display("group-rooms-media-recorded")]
    GroupRoomsMediaRecorded,
    #[serde(rename = "group-rooms-media-routed")]
    #[display("group-rooms-media-routed")]
    GroupRoomsMediaRouted,
    #[serde(rename = "group-rooms-media-stored")]
    #[display("group-rooms-media-stored")]
    GroupRoomsMediaStored,
    #[serde(rename = "group-rooms-participant-minutes")]
    #[display("group-rooms-participant-minutes")]
    GroupRoomsParticipantMinutes,
    #[serde(rename = "group-rooms-recorded-minutes")]
    #[display("group-rooms-recorded-minutes")]
    GroupRoomsRecordedMinutes,
    #[serde(rename = "imp-v1-usage")]
    #[display("imp-v1-usage")]
    ImpUsage,
    #[serde(rename = "lookups")]
    #[display("lookups")]
    Lookups,
    #[serde(rename = "marketplace")]
    #[display("marketplace")]
    Marketplace,
    #[serde(rename = "marketplace-algorithmia-named-entity-recognition")]
    #[display("marketplace-algorithmia-named-entity-recognition")]
    MarketplaceAlgorithmiaNamedEntityRecognition,
    #[serde(rename = "marketplace-cadence-transcription")]
    #[display("marketplace-cadence-transcription")]
    MarketplaceCadenceTranscription,
    #[serde(rename = "marketplace-cadence-translation")]
    #[display("marketplace-cadence-translation")]
    MarketplaceCadenceTranslation,
    #[serde(rename = "marketplace-capio-speech-to-text")]
    #[display("marketplace-capio-speech-to-text")]
    MarketplaceCapioSpeechToText,
    #[serde(rename = "marketplace-convriza-ababa")]
    #[display("marketplace-convriza-ababa")]
    MarketplaceConvrizaAbaba,
    #[serde(rename = "marketplace-deepgram-phrase-detector")]
    #[display("marketplace-deepgram-phrase-detector")]
    MarketplaceDeepgramPhraseDetector,
    #[serde(rename = "marketplace-digital-segment-business-info")]
    #[display("marketplace-digital-segment-business-info")]
    MarketplaceDigitalSegmentBusinessInfo,
    #[serde(rename = "marketplace-facebook-offline-conversions")]
    #[display("marketplace-facebook-offline-conversions")]
    MarketplaceFacebookOfflineConversions,
    #[serde(rename = "marketplace-google-speech-to-text")]
    #[display("marketplace-google-speech-to-text")]
    MarketplaceGoogleSpeechToText,
    #[serde(rename = "marketplace-ibm-watson-message-insights")]
    #[display("marketplace-ibm-watson-message-insights")]
    MarketplaceIbmWatsonMessageInsights,
    #[serde(rename = "marketplace-ibm-watson-message-sentiment")]
    #[display("marketplace-ibm-watson-message-sentiment")]
    MarketplaceIbmWatsonMessageSentiment,
    #[serde(rename = "marketplace-ibm-watson-recording-analysis")]
    #[display("marketplace-ibm-watson-recording-analysis")]
    MarketplaceIbmWatsonRecordingAnalysis,
    #[serde(rename = "marketplace-ibm-watson-tone-analyzer")]
    #[display("marketplace-ibm-watson-tone-analyzer")]
    MarketplaceIbmWatsonToneAnalyzer,
    #[serde(rename = "marketplace-icehook-systems-scout")]
    #[display("marketplace-icehook-systems-scout")]
    MarketplaceIcehookSystemsScout,
    #[serde(rename = "marketplace-infogroup-dataaxle-bizinfo")]
    #[display("marketplace-infogroup-dataaxle-bizinfo")]
    MarketplaceInfogroupDataaxleBizinfo,
    #[serde(rename = "marketplace-keen-io-contact-center-analytics")]
    #[display("marketplace-keen-io-contact-center-analytics")]
    MarketplaceKeenIoContactCenterAnalytics,
    #[serde(rename = "marketplace-marchex-cleancall")]
    #[display("marketplace-marchex-cleancall")]
    MarketplaceMarchexCleancall,
    #[serde(rename = "marketplace-marchex-sentiment-analysis-for-sms")]
    #[display("marketplace-marchex-sentiment-analysis-for-sms")]
    MarketplaceMarchexSentimentAnalysisForSms,
    #[serde(rename = "marketplace-marketplace-nextcaller-social-id")]
    #[display("marketplace-marketplace-nextcaller-social-id")]
    MarketplaceMarketplaceNextcallerSocialId,
    #[serde(rename = "marketplace-mobile-commons-opt-out-classifier")]
    #[display("marketplace-mobile-commons-opt-out-classifier")]
    MarketplaceMobileCommonsOptOutClassifier,
    #[serde(rename = "marketplace-nexiwave-voicemail-to-text")]
    #[display("marketplace-nexiwave-voicemail-to-text")]
    MarketplaceNexiwaveVoicemailToText,
    #[serde(rename = "marketplace-nextcaller-advanced-caller-identification")]
    #[display("marketplace-nextcaller-advanced-caller-identification")]
    MarketplaceNextcallerAdvancedCallerIdentification,
    #[serde(rename = "marketplace-nomorobo-spam-score")]
    #[display("marketplace-nomorobo-spam-score")]
    MarketplaceNomoroboSpamScore,
    #[serde(rename = "marketplace-payfone-tcpa-compliance")]
    #[display("marketplace-payfone-tcpa-compliance")]
    MarketplacePayfoneTcpaCompliance,
    #[serde(rename = "marketplace-remeeting-automatic-speech-recognition")]
    #[display("marketplace-remeeting-automatic-speech-recognition")]
    MarketplaceRemeetingAutomaticSpeechRecognition,
    #[serde(rename = "marketplace-tcpa-defense-solutions-blacklist-feed")]
    #[display("marketplace-tcpa-defense-solutions-blacklist-feed")]
    MarketplaceTcpaDefenseSolutionsBlacklistFeed,
    #[serde(rename = "marketplace-telo-opencnam")]
    #[display("marketplace-telo-opencnam")]
    MarketplaceTeloOpencnam,
    #[serde(rename = "marketplace-truecnam-true-spam")]
    #[display("marketplace-truecnam-true-spam")]
    MarketplaceTruecnamTrueSpam,
    #[serde(rename = "marketplace-twilio-caller-name-lookup-us")]
    #[display("marketplace-twilio-caller-name-lookup-us")]
    MarketplaceTwilioCallerNameLookupUs,
    #[serde(rename = "marketplace-twilio-carrier-information-lookup")]
    #[display("marketplace-twilio-carrier-information-lookup")]
    MarketplaceTwilioCarrierInformationLookup,
    #[serde(rename = "marketplace-voicebase-pci")]
    #[display("marketplace-voicebase-pci")]
    MarketplaceVoicebasePci,
    #[serde(rename = "marketplace-voicebase-transcription")]
    #[display("marketplace-voicebase-transcription")]
    MarketplaceVoicebaseTranscription,
    #[serde(rename = "marketplace-voicebase-transcription-custom-vocabulary")]
    #[display("marketplace-voicebase-transcription-custom-vocabulary")]
    MarketplaceVoicebaseTranscriptionCustomVocabulary,
    #[serde(rename = "marketplace-whitepages-pro-caller-identification")]
    #[display("marketplace-whitepages-pro-caller-identification")]
    MarketplaceWhitepagesProCallerIdentification,
    #[serde(rename = "marketplace-whitepages-pro-phone-intelligence")]
    #[display("marketplace-whitepages-pro-phone-intelligence")]
    MarketplaceWhitepagesProPhoneIntelligence,
    #[serde(rename = "marketplace-whitepages-pro-phone-reputation")]
    #[display("marketplace-whitepages-pro-phone-reputation")]
    MarketplaceWhitepagesProPhoneReputation,
    #[serde(rename = "marketplace-wolfarm-spoken-results")]
    #[display("marketplace-wolfarm-spoken-results")]
    MarketplaceWolfarmSpokenResults,
    #[serde(rename = "marketplace-wolfram-short-answer")]
    #[display("marketplace-wolfram-short-answer")]
    MarketplaceWolframShortAnswer,
    #[serde(rename = "marketplace-ytica-contact-center-reporting-analytics")]
    #[display("marketplace-ytica-contact-center-reporting-analytics")]
    MarketplaceYticaContactCenterReportingAnalytics,
    #[serde(rename = "mediastorage")]
    #[display("mediastorage")]
    Mediastorage,
    #[serde(rename = "mms")]
    #[display("mms")]
    Mms,
    #[serde(rename = "mms-inbound")]
    #[display("mms-inbound")]
    MmsInbound,
    #[serde(rename = "mms-inbound-longcode")]
    #[display("mms-inbound-longcode")]
    MmsInboundLongcode,
    #[serde(rename = "mms-inbound-shortcode")]
    #[display("mms-inbound-shortcode")]
    MmsInboundShortcode,
    #[serde(rename = "mms-messages-carrierfees")]
    #[display("mms-messages-carrierfees")]
    MmsMessagesCarrierfees,
    #[serde(rename = "mms-outbound")]
    #[display("mms-outbound")]
    MmsOutbound,
    #[serde(rename = "mms-outbound-longcode")]
    #[display("mms-outbound-longcode")]
    MmsOutboundLongcode,
    #[serde(rename = "mms-outbound-shortcode")]
    #[display("mms-outbound-shortcode")]
    MmsOutboundShortcode,
    #[serde(rename = "monitor-reads")]
    #[display("monitor-reads")]
    MonitorReads,
    #[serde(rename = "monitor-storage")]
    #[display("monitor-storage")]
    MonitorStorage,
    #[serde(rename = "monitor-writes")]
    #[display("monitor-writes")]
    MonitorWrites,
    #[serde(rename = "notify")]
    #[display("notify")]
    Notify,
    #[serde(rename = "notify-actions-attempts")]
    #[display("notify-actions-attempts")]
    NotifyActionsAttempts,
    #[serde(rename = "notify-channels")]
    #[display("notify-channels")]
    NotifyChannels,
    #[serde(rename = "number-format-lookups")]
    #[display("number-format-lookups")]
    NumberFormatLookups,
    #[serde(rename = "pchat")]
    #[display("pchat")]
    Pchat,
    #[serde(rename = "pchat-users")]
    #[display("pchat-users")]
    PchatUsers,
    #[serde(rename = "peer-to-peer-rooms-participant-minutes")]
    #[display("peer-to-peer-rooms-participant-minutes")]
    PeerToPeerRoomsParticipantMinutes,
    #[serde(rename = "pfax")]
    #[display("pfax")]
    Pfax,
    #[serde(rename = "pfax-minutes")]
    #[display("pfax-minutes")]
    PfaxMinutes,
    #[serde(rename = "pfax-minutes-inbound")]
    #[display("pfax-minutes-inbound")]
    PfaxMinutesInbound,
    #[serde(rename = "pfax-minutes-outbound")]
    #[display("pfax-minutes-outbound")]
    PfaxMinutesOutbound,
    #[serde(rename = "pfax-pages")]
    #[display("pfax-pages")]
    PfaxPages,
    #[serde(rename = "phonenumbers")]
    #[display("phonenumbers")]
    Phonenumbers,
    #[serde(rename = "phonenumbers-cps")]
    #[display("phonenumbers-cps")]
    PhonenumbersCps,
    #[serde(rename = "phonenumbers-emergency")]
    #[display("phonenumbers-emergency")]
    PhonenumbersEmergency,
    #[serde(rename = "phonenumbers-local")]
    #[display("phonenumbers-local")]
    PhonenumbersLocal,
    #[serde(rename = "phonenumbers-mobile")]
    #[display("phonenumbers-mobile")]
    PhonenumbersMobile,
    #[serde(rename = "phonenumbers-setups")]
    #[display("phonenumbers-setups")]
    PhonenumbersSetups,
    #[serde(rename = "phonenumbers-tollfree")]
    #[display("phonenumbers-tollfree")]
    PhonenumbersTollfree,
    #[serde(rename = "premiumsupport")]
    #[display("premiumsupport")]
    Premiumsupport,
    #[serde(rename = "proxy")]
    #[display("proxy")]
    Proxy,
    #[serde(rename = "proxy-active-sessions")]
    #[display("proxy-active-sessions")]
    ProxyActiveSessions,
    #[serde(rename = "pstnconnectivity")]
    #[display("pstnconnectivity")]
    Pstnconnectivity,
    #[serde(rename = "pv")]
    #[display("pv")]
    Pv,
    #[serde(rename = "pv-composition-media-downloaded")]
    #[display("pv-composition-media-downloaded")]
    PvCompositionMediaDownloaded,
    #[serde(rename = "pv-composition-media-encrypted")]
    #[display("pv-composition-media-encrypted")]
    PvCompositionMediaEncrypted,
    #[serde(rename = "pv-composition-media-stored")]
    #[display("pv-composition-media-stored")]
    PvCompositionMediaStored,
    #[serde(rename = "pv-composition-minutes")]
    #[display("pv-composition-minutes")]
    PvCompositionMinutes,
    #[serde(rename = "pv-recording-compositions")]
    #[display("pv-recording-compositions")]
    PvRecordingCompositions,
    #[serde(rename = "pv-room-participants")]
    #[display("pv-room-participants")]
    PvRoomParticipants,
    #[serde(rename = "pv-room-participants-au1")]
    #[display("pv-room-participants-au1")]
    PvRoomParticipantsAu1,
    #[serde(rename = "pv-room-participants-br1")]
    #[display("pv-room-participants-br1")]
    PvRoomParticipantsBr1,
    #[serde(rename = "pv-room-participants-ie1")]
    #[display("pv-room-participants-ie1")]
    PvRoomParticipantsIe1,
    #[serde(rename = "pv-room-participants-jp1")]
    #[display("pv-room-participants-jp1")]
    PvRoomParticipantsJp1,
    #[serde(rename = "pv-room-participants-sg1")]
    #[display("pv-room-participants-sg1")]
    PvRoomParticipantsSg1,
    #[serde(rename = "pv-room-participants-us1")]
    #[display("pv-room-participants-us1")]
    PvRoomParticipantsUs1,
    #[serde(rename = "pv-room-participants-us2")]
    #[display("pv-room-participants-us2")]
    PvRoomParticipantsUs2,
    #[serde(rename = "pv-rooms")]
    #[display("pv-rooms")]
    PvRooms,
    #[serde(rename = "pv-sip-endpoint-registrations")]
    #[display("pv-sip-endpoint-registrations")]
    PvSipEndpointRegistrations,
    #[serde(rename = "recordings")]
    #[display("recordings")]
    Recordings,
    #[serde(rename = "recordingstorage")]
    #[display("recordingstorage")]
    Recordingstorage,
    #[serde(rename = "rooms-group-bandwidth")]
    #[display("rooms-group-bandwidth")]
    RoomsGroupBandwidth,
    #[serde(rename = "rooms-group-minutes")]
    #[display("rooms-group-minutes")]
    RoomsGroupMinutes,
    #[serde(rename = "rooms-peer-to-peer-minutes")]
    #[display("rooms-peer-to-peer-minutes")]
    RoomsPeerToPeerMinutes,
    #[serde(rename = "shortcodes")]
    #[display("shortcodes")]
    Shortcodes,
    #[serde(rename = "shortcodes-customerowned")]
    #[display("shortcodes-customerowned")]
    ShortcodesCustomerowned,
    #[serde(rename = "shortcodes-mms-enablement")]
    #[display("shortcodes-mms-enablement")]
    ShortcodesMmsEnablement,
    #[serde(rename = "shortcodes-mps")]
    #[display("shortcodes-mps")]
    ShortcodesMps,
    #[serde(rename = "shortcodes-random")]
    #[display("shortcodes-random")]
    ShortcodesRandom,
    #[serde(rename = "shortcodes-uk")]
    #[display("shortcodes-uk")]
    ShortcodesUk,
    #[serde(rename = "shortcodes-vanity")]
    #[display("shortcodes-vanity")]
    ShortcodesVanity,
    #[serde(rename = "small-group-rooms")]
    #[display("small-group-rooms")]
    SmallGroupRooms,
    #[serde(rename = "small-group-rooms-data-track")]
    #[display("small-group-rooms-data-track")]
    SmallGroupRoomsDataTrack,
    #[serde(rename = "small-group-rooms-participant-minutes")]
    #[display("small-group-rooms-participant-minutes")]
    SmallGroupRoomsParticipantMinutes,
    #[serde(rename = "sms")]
    #[display("sms")]
    Sms,
    #[serde(rename = "sms-inbound")]
    #[display("sms-inbound")]
    SmsInbound,
    #[serde(rename = "sms-inbound-longcode")]
    #[display("sms-inbound-longcode")]
    SmsInboundLongcode,
    #[serde(rename = "sms-inbound-shortcode")]
    #[display("sms-inbound-shortcode")]
    SmsInboundShortcode,
    #[serde(rename = "sms-messages-carrierfees")]
    #[display("sms-messages-carrierfees")]
    SmsMessagesCarrierfees,
    #[serde(rename = "sms-messages-features")]
    #[display("sms-messages-features")]
    SmsMessagesFeatures,
    #[serde(rename = "sms-messages-features-senderid")]
    #[display("sms-messages-features-senderid")]
    SmsMessagesFeaturesSenderid,
    #[serde(rename = "sms-outbound")]
    #[display("sms-outbound")]
    SmsOutbound,
    #[serde(rename = "sms-outbound-content-inspection")]
    #[display("sms-outbound-content-inspection")]
    SmsOutboundContentInspection,
    #[serde(rename = "sms-outbound-longcode")]
    #[display("sms-outbound-longcode")]
    SmsOutboundLongcode,
    #[serde(rename = "sms-outbound-shortcode")]
    #[display("sms-outbound-shortcode")]
    SmsOutboundShortcode,
    #[serde(rename = "speech-recognition")]
    #[display("speech-recognition")]
    SpeechRecognition,
    #[serde(rename = "studio-engagements")]
    #[display("studio-engagements")]
    StudioEngagements,
    #[serde(rename = "sync")]
    #[display("sync")]
    Sync,
    #[serde(rename = "sync-actions")]
    #[display("sync-actions")]
    SyncActions,
    #[serde(rename = "sync-endpoint-hours")]
    #[display("sync-endpoint-hours")]
    SyncEndpointHours,
    #[serde(rename = "sync-endpoint-hours-above-daily-cap")]
    #[display("sync-endpoint-hours-above-daily-cap")]
    SyncEndpointHoursAboveDailyCap,
    #[serde(rename = "taskrouter-tasks")]
    #[display("taskrouter-tasks")]
    TaskrouterTasks,
    #[serde(rename = "totalprice")]
    #[display("totalprice")]
    Totalprice,
    #[serde(rename = "transcriptions")]
    #[display("transcriptions")]
    Transcriptions,
    #[serde(rename = "trunking-cps")]
    #[display("trunking-cps")]
    TrunkingCps,
    #[serde(rename = "trunking-emergency-calls")]
    #[display("trunking-emergency-calls")]
    TrunkingEmergencyCalls,
    #[serde(rename = "trunking-origination")]
    #[display("trunking-origination")]
    TrunkingOrigination,
    #[serde(rename = "trunking-origination-local")]
    #[display("trunking-origination-local")]
    TrunkingOriginationLocal,
    #[serde(rename = "trunking-origination-mobile")]
    #[display("trunking-origination-mobile")]
    TrunkingOriginationMobile,
    #[serde(rename = "trunking-origination-tollfree")]
    #[display("trunking-origination-tollfree")]
    TrunkingOriginationTollfree,
    #[serde(rename = "trunking-recordings")]
    #[display("trunking-recordings")]
    TrunkingRecordings,
    #[serde(rename = "trunking-secure")]
    #[display("trunking-secure")]
    TrunkingSecure,
    #[serde(rename = "trunking-termination")]
    #[display("trunking-termination")]
    TrunkingTermination,
    #[serde(rename = "turnmegabytes")]
    #[display("turnmegabytes")]
    Turnmegabytes,
    #[serde(rename = "turnmegabytes-australia")]
    #[display("turnmegabytes-australia")]
    TurnmegabytesAustralia,
    #[serde(rename = "turnmegabytes-brasil")]
    #[display("turnmegabytes-brasil")]
    TurnmegabytesBrasil,
    #[serde(rename = "turnmegabytes-germany")]
    #[display("turnmegabytes-germany")]
    TurnmegabytesGermany,
    #[serde(rename = "turnmegabytes-india")]
    #[display("turnmegabytes-india")]
    TurnmegabytesIndia,
    #[serde(rename = "turnmegabytes-ireland")]
    #[display("turnmegabytes-ireland")]
    TurnmegabytesIreland,
    #[serde(rename = "turnmegabytes-japan")]
    #[display("turnmegabytes-japan")]
    TurnmegabytesJapan,
    #[serde(rename = "turnmegabytes-singapore")]
    #[display("turnmegabytes-singapore")]
    TurnmegabytesSingapore,
    #[serde(rename = "turnmegabytes-useast")]
    #[display("turnmegabytes-useast")]
    TurnmegabytesUseast,
    #[serde(rename = "turnmegabytes-uswest")]
    #[display("turnmegabytes-uswest")]
    TurnmegabytesUswest,
    #[serde(rename = "twilio-interconnect")]
    #[display("twilio-interconnect")]
    TwilioInterconnect,
    #[serde(rename = "verify-push")]
    #[display("verify-push")]
    VerifyPush,
    #[serde(rename = "verify-totp")]
    #[display("verify-totp")]
    VerifyTotp,
    #[serde(rename = "verify-whatsapp-conversations-business-initiated")]
    #[display("verify-whatsapp-conversations-business-initiated")]
    VerifyWhatsappConversationsBusinessInitiated,
    #[serde(rename = "video-recordings")]
    #[display("video-recordings")]
    VideoRecordings,
    #[serde(rename = "virtual-agent")]
    #[display("virtual-agent")]
    VirtualAgent,
    #[serde(rename = "voice-insights")]
    #[display("voice-insights")]
    VoiceInsights,
    #[serde(rename = "voice-insights-client-insights-on-demand-minute")]
    #[display("voice-insights-client-insights-on-demand-minute")]
    VoiceInsightsClientInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-ptsn-insights-on-demand-minute")]
    #[display("voice-insights-ptsn-insights-on-demand-minute")]
    VoiceInsightsPtsnInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-interface-insights-on-demand-minute")]
    #[display("voice-insights-sip-interface-insights-on-demand-minute")]
    VoiceInsightsSipInterfaceInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-trunking-insights-on-demand-minute")]
    #[display("voice-insights-sip-trunking-insights-on-demand-minute")]
    VoiceInsightsSipTrunkingInsightsOnDemandMinute,
    #[serde(rename = "wireless")]
    #[display("wireless")]
    Wireless,
    #[serde(rename = "wireless-orders")]
    #[display("wireless-orders")]
    WirelessOrders,
    #[serde(rename = "wireless-orders-artwork")]
    #[display("wireless-orders-artwork")]
    WirelessOrdersArtwork,
    #[serde(rename = "wireless-orders-bulk")]
    #[display("wireless-orders-bulk")]
    WirelessOrdersBulk,
    #[serde(rename = "wireless-orders-esim")]
    #[display("wireless-orders-esim")]
    WirelessOrdersEsim,
    #[serde(rename = "wireless-orders-starter")]
    #[display("wireless-orders-starter")]
    WirelessOrdersStarter,
    #[serde(rename = "wireless-usage")]
    #[display("wireless-usage")]
    WirelessUsage,
    #[serde(rename = "wireless-usage-commands")]
    #[display("wireless-usage-commands")]
    WirelessUsageCommands,
    #[serde(rename = "wireless-usage-commands-africa")]
    #[display("wireless-usage-commands-africa")]
    WirelessUsageCommandsAfrica,
    #[serde(rename = "wireless-usage-commands-asia")]
    #[display("wireless-usage-commands-asia")]
    WirelessUsageCommandsAsia,
    #[serde(rename = "wireless-usage-commands-centralandsouthamerica")]
    #[display("wireless-usage-commands-centralandsouthamerica")]
    WirelessUsageCommandsCentralandsouthamerica,
    #[serde(rename = "wireless-usage-commands-europe")]
    #[display("wireless-usage-commands-europe")]
    WirelessUsageCommandsEurope,
    #[serde(rename = "wireless-usage-commands-home")]
    #[display("wireless-usage-commands-home")]
    WirelessUsageCommandsHome,
    #[serde(rename = "wireless-usage-commands-northamerica")]
    #[display("wireless-usage-commands-northamerica")]
    WirelessUsageCommandsNorthamerica,
    #[serde(rename = "wireless-usage-commands-oceania")]
    #[display("wireless-usage-commands-oceania")]
    WirelessUsageCommandsOceania,
    #[serde(rename = "wireless-usage-commands-roaming")]
    #[display("wireless-usage-commands-roaming")]
    WirelessUsageCommandsRoaming,
    #[serde(rename = "wireless-usage-data")]
    #[display("wireless-usage-data")]
    WirelessUsageData,
    #[serde(rename = "wireless-usage-data-africa")]
    #[display("wireless-usage-data-africa")]
    WirelessUsageDataAfrica,
    #[serde(rename = "wireless-usage-data-asia")]
    #[display("wireless-usage-data-asia")]
    WirelessUsageDataAsia,
    #[serde(rename = "wireless-usage-data-centralandsouthamerica")]
    #[display("wireless-usage-data-centralandsouthamerica")]
    WirelessUsageDataCentralandsouthamerica,
    #[serde(rename = "wireless-usage-data-custom-additionalmb")]
    #[display("wireless-usage-data-custom-additionalmb")]
    WirelessUsageDataCustomAdditionalmb,
    #[serde(rename = "wireless-usage-data-custom-first5mb")]
    #[display("wireless-usage-data-custom-first5mb")]
    WirelessUsageDataCustomFirst5Mb,
    #[serde(rename = "wireless-usage-data-domestic-roaming")]
    #[display("wireless-usage-data-domestic-roaming")]
    WirelessUsageDataDomesticRoaming,
    #[serde(rename = "wireless-usage-data-europe")]
    #[display("wireless-usage-data-europe")]
    WirelessUsageDataEurope,
    #[serde(rename = "wireless-usage-data-individual-additionalgb")]
    #[display("wireless-usage-data-individual-additionalgb")]
    WirelessUsageDataIndividualAdditionalgb,
    #[serde(rename = "wireless-usage-data-individual-firstgb")]
    #[display("wireless-usage-data-individual-firstgb")]
    WirelessUsageDataIndividualFirstgb,
    #[serde(rename = "wireless-usage-data-international-roaming-canada")]
    #[display("wireless-usage-data-international-roaming-canada")]
    WirelessUsageDataInternationalRoamingCanada,
    #[serde(rename = "wireless-usage-data-international-roaming-india")]
    #[display("wireless-usage-data-international-roaming-india")]
    WirelessUsageDataInternationalRoamingIndia,
    #[serde(rename = "wireless-usage-data-international-roaming-mexico")]
    #[display("wireless-usage-data-international-roaming-mexico")]
    WirelessUsageDataInternationalRoamingMexico,
    #[serde(rename = "wireless-usage-data-northamerica")]
    #[display("wireless-usage-data-northamerica")]
    WirelessUsageDataNorthamerica,
    #[serde(rename = "wireless-usage-data-oceania")]
    #[display("wireless-usage-data-oceania")]
    WirelessUsageDataOceania,
    #[serde(rename = "wireless-usage-data-pooled")]
    #[display("wireless-usage-data-pooled")]
    WirelessUsageDataPooled,
    #[serde(rename = "wireless-usage-data-pooled-downlink")]
    #[display("wireless-usage-data-pooled-downlink")]
    WirelessUsageDataPooledDownlink,
    #[serde(rename = "wireless-usage-data-pooled-uplink")]
    #[display("wireless-usage-data-pooled-uplink")]
    WirelessUsageDataPooledUplink,
    #[serde(rename = "wireless-usage-mrc")]
    #[display("wireless-usage-mrc")]
    WirelessUsageMrc,
    #[serde(rename = "wireless-usage-mrc-custom")]
    #[display("wireless-usage-mrc-custom")]
    WirelessUsageMrcCustom,
    #[serde(rename = "wireless-usage-mrc-individual")]
    #[display("wireless-usage-mrc-individual")]
    WirelessUsageMrcIndividual,
    #[serde(rename = "wireless-usage-mrc-pooled")]
    #[display("wireless-usage-mrc-pooled")]
    WirelessUsageMrcPooled,
    #[serde(rename = "wireless-usage-mrc-suspended")]
    #[display("wireless-usage-mrc-suspended")]
    WirelessUsageMrcSuspended,
    #[serde(rename = "wireless-usage-sms")]
    #[display("wireless-usage-sms")]
    WirelessUsageSms,
    #[serde(rename = "wireless-usage-voice")]
    #[display("wireless-usage-voice")]
    WirelessUsageVoice,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountUsageUsageRecordUsageRecordLastMonth {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that accrued \
             the usage."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to create the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "Usage records up to date as of this timestamp, formatted as \
             YYYY-MM-DDTHH:MM:SS+00:00. All timestamps are in GMT"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub as_of: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub category: Option<UsageRecordLastMonthEnumCategory>,
    #[doc = "The number of usage events, such as the number of calls."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<String>,
    #[doc = "The units in which `count` is measured, such as `calls` for calls or `messages` for \
             SMS."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count_unit: Option<String>,
    #[doc = "A plain-language description of the usage category."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "The last date for which usage is included in the UsageRecord. The date is specified \
             in GMT and formatted as `YYYY-MM-DD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_date: Option<chrono::NaiveDate>,
    #[doc = "The total price of the usage in the currency specified in `price_unit` and \
             associated with the account."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<f64>,
    #[doc = "The currency in which `price` is measured, in [ISO 4127](https://www.iso.org/iso/home/standards/currency_codes.htm) format, such as `usd`, `eur`, and `jpy`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price_unit: Option<String>,
    #[doc = "The first date for which usage is included in this UsageRecord. The date is \
             specified in GMT and formatted as `YYYY-MM-DD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_date: Option<chrono::NaiveDate>,
    #[doc = "A list of related resources identified by their URIs. For more information, see [List Subresources](https://www.twilio.com/docs/usage/api/usage-record#list-subresources)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "The amount used to bill usage and measured in units described in `usage_unit`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage: Option<String>,
    #[doc = "The units in which `usage` is measured, such as `minutes` for calls or `messages` \
             for SMS."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_unit: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountUsageUsageRecordUsageRecordLastMonth {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountUsageUsageRecordUsageRecordLastMonth {
    const LENGTH: usize = 15;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(as_of) = &self.as_of {
                format!("{as_of:?}")
            } else {
                String::new()
            },
            if let Some(category) = &self.category {
                format!("{category:?}")
            } else {
                String::new()
            },
            if let Some(count) = &self.count {
                format!("{count:?}")
            } else {
                String::new()
            },
            if let Some(count_unit) = &self.count_unit {
                format!("{count_unit:?}")
            } else {
                String::new()
            },
            if let Some(description) = &self.description {
                format!("{description:?}")
            } else {
                String::new()
            },
            if let Some(end_date) = &self.end_date {
                format!("{end_date:?}")
            } else {
                String::new()
            },
            if let Some(price) = &self.price {
                format!("{price:?}")
            } else {
                String::new()
            },
            if let Some(price_unit) = &self.price_unit {
                format!("{price_unit:?}")
            } else {
                String::new()
            },
            if let Some(start_date) = &self.start_date {
                format!("{start_date:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(usage) = &self.usage {
                format!("{usage:?}")
            } else {
                String::new()
            },
            if let Some(usage_unit) = &self.usage_unit {
                format!("{usage_unit:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "as_of".to_string(),
            "category".to_string(),
            "count".to_string(),
            "count_unit".to_string(),
            "description".to_string(),
            "end_date".to_string(),
            "price".to_string(),
            "price_unit".to_string(),
            "start_date".to_string(),
            "subresource_uris".to_string(),
            "uri".to_string(),
            "usage".to_string(),
            "usage_unit".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UsageRecordLastMonthEnumCategory {
    #[serde(rename = "a2p-registration-fees")]
    #[display("a2p-registration-fees")]
    A2PRegistrationFees,
    #[serde(rename = "agent-conference")]
    #[display("agent-conference")]
    AgentConference,
    #[serde(rename = "amazon-polly")]
    #[display("amazon-polly")]
    AmazonPolly,
    #[serde(rename = "answering-machine-detection")]
    #[display("answering-machine-detection")]
    AnsweringMachineDetection,
    #[serde(rename = "authy-authentications")]
    #[display("authy-authentications")]
    AuthyAuthentications,
    #[serde(rename = "authy-calls-outbound")]
    #[display("authy-calls-outbound")]
    AuthyCallsOutbound,
    #[serde(rename = "authy-monthly-fees")]
    #[display("authy-monthly-fees")]
    AuthyMonthlyFees,
    #[serde(rename = "authy-phone-intelligence")]
    #[display("authy-phone-intelligence")]
    AuthyPhoneIntelligence,
    #[serde(rename = "authy-phone-verifications")]
    #[display("authy-phone-verifications")]
    AuthyPhoneVerifications,
    #[serde(rename = "authy-sms-outbound")]
    #[display("authy-sms-outbound")]
    AuthySmsOutbound,
    #[serde(rename = "call-progess-events")]
    #[display("call-progess-events")]
    CallProgessEvents,
    #[serde(rename = "calleridlookups")]
    #[display("calleridlookups")]
    Calleridlookups,
    #[serde(rename = "calls")]
    #[display("calls")]
    Calls,
    #[serde(rename = "calls-client")]
    #[display("calls-client")]
    CallsClient,
    #[serde(rename = "calls-globalconference")]
    #[display("calls-globalconference")]
    CallsGlobalconference,
    #[serde(rename = "calls-inbound")]
    #[display("calls-inbound")]
    CallsInbound,
    #[serde(rename = "calls-inbound-local")]
    #[display("calls-inbound-local")]
    CallsInboundLocal,
    #[serde(rename = "calls-inbound-mobile")]
    #[display("calls-inbound-mobile")]
    CallsInboundMobile,
    #[serde(rename = "calls-inbound-tollfree")]
    #[display("calls-inbound-tollfree")]
    CallsInboundTollfree,
    #[serde(rename = "calls-outbound")]
    #[display("calls-outbound")]
    CallsOutbound,
    #[serde(rename = "calls-pay-verb-transactions")]
    #[display("calls-pay-verb-transactions")]
    CallsPayVerbTransactions,
    #[serde(rename = "calls-recordings")]
    #[display("calls-recordings")]
    CallsRecordings,
    #[serde(rename = "calls-sip")]
    #[display("calls-sip")]
    CallsSip,
    #[serde(rename = "calls-sip-inbound")]
    #[display("calls-sip-inbound")]
    CallsSipInbound,
    #[serde(rename = "calls-sip-outbound")]
    #[display("calls-sip-outbound")]
    CallsSipOutbound,
    #[serde(rename = "calls-transfers")]
    #[display("calls-transfers")]
    CallsTransfers,
    #[serde(rename = "carrier-lookups")]
    #[display("carrier-lookups")]
    CarrierLookups,
    #[serde(rename = "conversations")]
    #[display("conversations")]
    Conversations,
    #[serde(rename = "conversations-api-requests")]
    #[display("conversations-api-requests")]
    ConversationsApiRequests,
    #[serde(rename = "conversations-conversation-events")]
    #[display("conversations-conversation-events")]
    ConversationsConversationEvents,
    #[serde(rename = "conversations-endpoint-connectivity")]
    #[display("conversations-endpoint-connectivity")]
    ConversationsEndpointConnectivity,
    #[serde(rename = "conversations-events")]
    #[display("conversations-events")]
    ConversationsEvents,
    #[serde(rename = "conversations-participant-events")]
    #[display("conversations-participant-events")]
    ConversationsParticipantEvents,
    #[serde(rename = "conversations-participants")]
    #[display("conversations-participants")]
    ConversationsParticipants,
    #[serde(rename = "cps")]
    #[display("cps")]
    Cps,
    #[serde(rename = "flex-usage")]
    #[display("flex-usage")]
    FlexUsage,
    #[serde(rename = "fraud-lookups")]
    #[display("fraud-lookups")]
    FraudLookups,
    #[serde(rename = "group-rooms")]
    #[display("group-rooms")]
    GroupRooms,
    #[serde(rename = "group-rooms-data-track")]
    #[display("group-rooms-data-track")]
    GroupRoomsDataTrack,
    #[serde(rename = "group-rooms-encrypted-media-recorded")]
    #[display("group-rooms-encrypted-media-recorded")]
    GroupRoomsEncryptedMediaRecorded,
    #[serde(rename = "group-rooms-media-downloaded")]
    #[display("group-rooms-media-downloaded")]
    GroupRoomsMediaDownloaded,
    #[serde(rename = "group-rooms-media-recorded")]
    #[display("group-rooms-media-recorded")]
    GroupRoomsMediaRecorded,
    #[serde(rename = "group-rooms-media-routed")]
    #[display("group-rooms-media-routed")]
    GroupRoomsMediaRouted,
    #[serde(rename = "group-rooms-media-stored")]
    #[display("group-rooms-media-stored")]
    GroupRoomsMediaStored,
    #[serde(rename = "group-rooms-participant-minutes")]
    #[display("group-rooms-participant-minutes")]
    GroupRoomsParticipantMinutes,
    #[serde(rename = "group-rooms-recorded-minutes")]
    #[display("group-rooms-recorded-minutes")]
    GroupRoomsRecordedMinutes,
    #[serde(rename = "imp-v1-usage")]
    #[display("imp-v1-usage")]
    ImpUsage,
    #[serde(rename = "lookups")]
    #[display("lookups")]
    Lookups,
    #[serde(rename = "marketplace")]
    #[display("marketplace")]
    Marketplace,
    #[serde(rename = "marketplace-algorithmia-named-entity-recognition")]
    #[display("marketplace-algorithmia-named-entity-recognition")]
    MarketplaceAlgorithmiaNamedEntityRecognition,
    #[serde(rename = "marketplace-cadence-transcription")]
    #[display("marketplace-cadence-transcription")]
    MarketplaceCadenceTranscription,
    #[serde(rename = "marketplace-cadence-translation")]
    #[display("marketplace-cadence-translation")]
    MarketplaceCadenceTranslation,
    #[serde(rename = "marketplace-capio-speech-to-text")]
    #[display("marketplace-capio-speech-to-text")]
    MarketplaceCapioSpeechToText,
    #[serde(rename = "marketplace-convriza-ababa")]
    #[display("marketplace-convriza-ababa")]
    MarketplaceConvrizaAbaba,
    #[serde(rename = "marketplace-deepgram-phrase-detector")]
    #[display("marketplace-deepgram-phrase-detector")]
    MarketplaceDeepgramPhraseDetector,
    #[serde(rename = "marketplace-digital-segment-business-info")]
    #[display("marketplace-digital-segment-business-info")]
    MarketplaceDigitalSegmentBusinessInfo,
    #[serde(rename = "marketplace-facebook-offline-conversions")]
    #[display("marketplace-facebook-offline-conversions")]
    MarketplaceFacebookOfflineConversions,
    #[serde(rename = "marketplace-google-speech-to-text")]
    #[display("marketplace-google-speech-to-text")]
    MarketplaceGoogleSpeechToText,
    #[serde(rename = "marketplace-ibm-watson-message-insights")]
    #[display("marketplace-ibm-watson-message-insights")]
    MarketplaceIbmWatsonMessageInsights,
    #[serde(rename = "marketplace-ibm-watson-message-sentiment")]
    #[display("marketplace-ibm-watson-message-sentiment")]
    MarketplaceIbmWatsonMessageSentiment,
    #[serde(rename = "marketplace-ibm-watson-recording-analysis")]
    #[display("marketplace-ibm-watson-recording-analysis")]
    MarketplaceIbmWatsonRecordingAnalysis,
    #[serde(rename = "marketplace-ibm-watson-tone-analyzer")]
    #[display("marketplace-ibm-watson-tone-analyzer")]
    MarketplaceIbmWatsonToneAnalyzer,
    #[serde(rename = "marketplace-icehook-systems-scout")]
    #[display("marketplace-icehook-systems-scout")]
    MarketplaceIcehookSystemsScout,
    #[serde(rename = "marketplace-infogroup-dataaxle-bizinfo")]
    #[display("marketplace-infogroup-dataaxle-bizinfo")]
    MarketplaceInfogroupDataaxleBizinfo,
    #[serde(rename = "marketplace-keen-io-contact-center-analytics")]
    #[display("marketplace-keen-io-contact-center-analytics")]
    MarketplaceKeenIoContactCenterAnalytics,
    #[serde(rename = "marketplace-marchex-cleancall")]
    #[display("marketplace-marchex-cleancall")]
    MarketplaceMarchexCleancall,
    #[serde(rename = "marketplace-marchex-sentiment-analysis-for-sms")]
    #[display("marketplace-marchex-sentiment-analysis-for-sms")]
    MarketplaceMarchexSentimentAnalysisForSms,
    #[serde(rename = "marketplace-marketplace-nextcaller-social-id")]
    #[display("marketplace-marketplace-nextcaller-social-id")]
    MarketplaceMarketplaceNextcallerSocialId,
    #[serde(rename = "marketplace-mobile-commons-opt-out-classifier")]
    #[display("marketplace-mobile-commons-opt-out-classifier")]
    MarketplaceMobileCommonsOptOutClassifier,
    #[serde(rename = "marketplace-nexiwave-voicemail-to-text")]
    #[display("marketplace-nexiwave-voicemail-to-text")]
    MarketplaceNexiwaveVoicemailToText,
    #[serde(rename = "marketplace-nextcaller-advanced-caller-identification")]
    #[display("marketplace-nextcaller-advanced-caller-identification")]
    MarketplaceNextcallerAdvancedCallerIdentification,
    #[serde(rename = "marketplace-nomorobo-spam-score")]
    #[display("marketplace-nomorobo-spam-score")]
    MarketplaceNomoroboSpamScore,
    #[serde(rename = "marketplace-payfone-tcpa-compliance")]
    #[display("marketplace-payfone-tcpa-compliance")]
    MarketplacePayfoneTcpaCompliance,
    #[serde(rename = "marketplace-remeeting-automatic-speech-recognition")]
    #[display("marketplace-remeeting-automatic-speech-recognition")]
    MarketplaceRemeetingAutomaticSpeechRecognition,
    #[serde(rename = "marketplace-tcpa-defense-solutions-blacklist-feed")]
    #[display("marketplace-tcpa-defense-solutions-blacklist-feed")]
    MarketplaceTcpaDefenseSolutionsBlacklistFeed,
    #[serde(rename = "marketplace-telo-opencnam")]
    #[display("marketplace-telo-opencnam")]
    MarketplaceTeloOpencnam,
    #[serde(rename = "marketplace-truecnam-true-spam")]
    #[display("marketplace-truecnam-true-spam")]
    MarketplaceTruecnamTrueSpam,
    #[serde(rename = "marketplace-twilio-caller-name-lookup-us")]
    #[display("marketplace-twilio-caller-name-lookup-us")]
    MarketplaceTwilioCallerNameLookupUs,
    #[serde(rename = "marketplace-twilio-carrier-information-lookup")]
    #[display("marketplace-twilio-carrier-information-lookup")]
    MarketplaceTwilioCarrierInformationLookup,
    #[serde(rename = "marketplace-voicebase-pci")]
    #[display("marketplace-voicebase-pci")]
    MarketplaceVoicebasePci,
    #[serde(rename = "marketplace-voicebase-transcription")]
    #[display("marketplace-voicebase-transcription")]
    MarketplaceVoicebaseTranscription,
    #[serde(rename = "marketplace-voicebase-transcription-custom-vocabulary")]
    #[display("marketplace-voicebase-transcription-custom-vocabulary")]
    MarketplaceVoicebaseTranscriptionCustomVocabulary,
    #[serde(rename = "marketplace-whitepages-pro-caller-identification")]
    #[display("marketplace-whitepages-pro-caller-identification")]
    MarketplaceWhitepagesProCallerIdentification,
    #[serde(rename = "marketplace-whitepages-pro-phone-intelligence")]
    #[display("marketplace-whitepages-pro-phone-intelligence")]
    MarketplaceWhitepagesProPhoneIntelligence,
    #[serde(rename = "marketplace-whitepages-pro-phone-reputation")]
    #[display("marketplace-whitepages-pro-phone-reputation")]
    MarketplaceWhitepagesProPhoneReputation,
    #[serde(rename = "marketplace-wolfarm-spoken-results")]
    #[display("marketplace-wolfarm-spoken-results")]
    MarketplaceWolfarmSpokenResults,
    #[serde(rename = "marketplace-wolfram-short-answer")]
    #[display("marketplace-wolfram-short-answer")]
    MarketplaceWolframShortAnswer,
    #[serde(rename = "marketplace-ytica-contact-center-reporting-analytics")]
    #[display("marketplace-ytica-contact-center-reporting-analytics")]
    MarketplaceYticaContactCenterReportingAnalytics,
    #[serde(rename = "mediastorage")]
    #[display("mediastorage")]
    Mediastorage,
    #[serde(rename = "mms")]
    #[display("mms")]
    Mms,
    #[serde(rename = "mms-inbound")]
    #[display("mms-inbound")]
    MmsInbound,
    #[serde(rename = "mms-inbound-longcode")]
    #[display("mms-inbound-longcode")]
    MmsInboundLongcode,
    #[serde(rename = "mms-inbound-shortcode")]
    #[display("mms-inbound-shortcode")]
    MmsInboundShortcode,
    #[serde(rename = "mms-messages-carrierfees")]
    #[display("mms-messages-carrierfees")]
    MmsMessagesCarrierfees,
    #[serde(rename = "mms-outbound")]
    #[display("mms-outbound")]
    MmsOutbound,
    #[serde(rename = "mms-outbound-longcode")]
    #[display("mms-outbound-longcode")]
    MmsOutboundLongcode,
    #[serde(rename = "mms-outbound-shortcode")]
    #[display("mms-outbound-shortcode")]
    MmsOutboundShortcode,
    #[serde(rename = "monitor-reads")]
    #[display("monitor-reads")]
    MonitorReads,
    #[serde(rename = "monitor-storage")]
    #[display("monitor-storage")]
    MonitorStorage,
    #[serde(rename = "monitor-writes")]
    #[display("monitor-writes")]
    MonitorWrites,
    #[serde(rename = "notify")]
    #[display("notify")]
    Notify,
    #[serde(rename = "notify-actions-attempts")]
    #[display("notify-actions-attempts")]
    NotifyActionsAttempts,
    #[serde(rename = "notify-channels")]
    #[display("notify-channels")]
    NotifyChannels,
    #[serde(rename = "number-format-lookups")]
    #[display("number-format-lookups")]
    NumberFormatLookups,
    #[serde(rename = "pchat")]
    #[display("pchat")]
    Pchat,
    #[serde(rename = "pchat-users")]
    #[display("pchat-users")]
    PchatUsers,
    #[serde(rename = "peer-to-peer-rooms-participant-minutes")]
    #[display("peer-to-peer-rooms-participant-minutes")]
    PeerToPeerRoomsParticipantMinutes,
    #[serde(rename = "pfax")]
    #[display("pfax")]
    Pfax,
    #[serde(rename = "pfax-minutes")]
    #[display("pfax-minutes")]
    PfaxMinutes,
    #[serde(rename = "pfax-minutes-inbound")]
    #[display("pfax-minutes-inbound")]
    PfaxMinutesInbound,
    #[serde(rename = "pfax-minutes-outbound")]
    #[display("pfax-minutes-outbound")]
    PfaxMinutesOutbound,
    #[serde(rename = "pfax-pages")]
    #[display("pfax-pages")]
    PfaxPages,
    #[serde(rename = "phonenumbers")]
    #[display("phonenumbers")]
    Phonenumbers,
    #[serde(rename = "phonenumbers-cps")]
    #[display("phonenumbers-cps")]
    PhonenumbersCps,
    #[serde(rename = "phonenumbers-emergency")]
    #[display("phonenumbers-emergency")]
    PhonenumbersEmergency,
    #[serde(rename = "phonenumbers-local")]
    #[display("phonenumbers-local")]
    PhonenumbersLocal,
    #[serde(rename = "phonenumbers-mobile")]
    #[display("phonenumbers-mobile")]
    PhonenumbersMobile,
    #[serde(rename = "phonenumbers-setups")]
    #[display("phonenumbers-setups")]
    PhonenumbersSetups,
    #[serde(rename = "phonenumbers-tollfree")]
    #[display("phonenumbers-tollfree")]
    PhonenumbersTollfree,
    #[serde(rename = "premiumsupport")]
    #[display("premiumsupport")]
    Premiumsupport,
    #[serde(rename = "proxy")]
    #[display("proxy")]
    Proxy,
    #[serde(rename = "proxy-active-sessions")]
    #[display("proxy-active-sessions")]
    ProxyActiveSessions,
    #[serde(rename = "pstnconnectivity")]
    #[display("pstnconnectivity")]
    Pstnconnectivity,
    #[serde(rename = "pv")]
    #[display("pv")]
    Pv,
    #[serde(rename = "pv-composition-media-downloaded")]
    #[display("pv-composition-media-downloaded")]
    PvCompositionMediaDownloaded,
    #[serde(rename = "pv-composition-media-encrypted")]
    #[display("pv-composition-media-encrypted")]
    PvCompositionMediaEncrypted,
    #[serde(rename = "pv-composition-media-stored")]
    #[display("pv-composition-media-stored")]
    PvCompositionMediaStored,
    #[serde(rename = "pv-composition-minutes")]
    #[display("pv-composition-minutes")]
    PvCompositionMinutes,
    #[serde(rename = "pv-recording-compositions")]
    #[display("pv-recording-compositions")]
    PvRecordingCompositions,
    #[serde(rename = "pv-room-participants")]
    #[display("pv-room-participants")]
    PvRoomParticipants,
    #[serde(rename = "pv-room-participants-au1")]
    #[display("pv-room-participants-au1")]
    PvRoomParticipantsAu1,
    #[serde(rename = "pv-room-participants-br1")]
    #[display("pv-room-participants-br1")]
    PvRoomParticipantsBr1,
    #[serde(rename = "pv-room-participants-ie1")]
    #[display("pv-room-participants-ie1")]
    PvRoomParticipantsIe1,
    #[serde(rename = "pv-room-participants-jp1")]
    #[display("pv-room-participants-jp1")]
    PvRoomParticipantsJp1,
    #[serde(rename = "pv-room-participants-sg1")]
    #[display("pv-room-participants-sg1")]
    PvRoomParticipantsSg1,
    #[serde(rename = "pv-room-participants-us1")]
    #[display("pv-room-participants-us1")]
    PvRoomParticipantsUs1,
    #[serde(rename = "pv-room-participants-us2")]
    #[display("pv-room-participants-us2")]
    PvRoomParticipantsUs2,
    #[serde(rename = "pv-rooms")]
    #[display("pv-rooms")]
    PvRooms,
    #[serde(rename = "pv-sip-endpoint-registrations")]
    #[display("pv-sip-endpoint-registrations")]
    PvSipEndpointRegistrations,
    #[serde(rename = "recordings")]
    #[display("recordings")]
    Recordings,
    #[serde(rename = "recordingstorage")]
    #[display("recordingstorage")]
    Recordingstorage,
    #[serde(rename = "rooms-group-bandwidth")]
    #[display("rooms-group-bandwidth")]
    RoomsGroupBandwidth,
    #[serde(rename = "rooms-group-minutes")]
    #[display("rooms-group-minutes")]
    RoomsGroupMinutes,
    #[serde(rename = "rooms-peer-to-peer-minutes")]
    #[display("rooms-peer-to-peer-minutes")]
    RoomsPeerToPeerMinutes,
    #[serde(rename = "shortcodes")]
    #[display("shortcodes")]
    Shortcodes,
    #[serde(rename = "shortcodes-customerowned")]
    #[display("shortcodes-customerowned")]
    ShortcodesCustomerowned,
    #[serde(rename = "shortcodes-mms-enablement")]
    #[display("shortcodes-mms-enablement")]
    ShortcodesMmsEnablement,
    #[serde(rename = "shortcodes-mps")]
    #[display("shortcodes-mps")]
    ShortcodesMps,
    #[serde(rename = "shortcodes-random")]
    #[display("shortcodes-random")]
    ShortcodesRandom,
    #[serde(rename = "shortcodes-uk")]
    #[display("shortcodes-uk")]
    ShortcodesUk,
    #[serde(rename = "shortcodes-vanity")]
    #[display("shortcodes-vanity")]
    ShortcodesVanity,
    #[serde(rename = "small-group-rooms")]
    #[display("small-group-rooms")]
    SmallGroupRooms,
    #[serde(rename = "small-group-rooms-data-track")]
    #[display("small-group-rooms-data-track")]
    SmallGroupRoomsDataTrack,
    #[serde(rename = "small-group-rooms-participant-minutes")]
    #[display("small-group-rooms-participant-minutes")]
    SmallGroupRoomsParticipantMinutes,
    #[serde(rename = "sms")]
    #[display("sms")]
    Sms,
    #[serde(rename = "sms-inbound")]
    #[display("sms-inbound")]
    SmsInbound,
    #[serde(rename = "sms-inbound-longcode")]
    #[display("sms-inbound-longcode")]
    SmsInboundLongcode,
    #[serde(rename = "sms-inbound-shortcode")]
    #[display("sms-inbound-shortcode")]
    SmsInboundShortcode,
    #[serde(rename = "sms-messages-carrierfees")]
    #[display("sms-messages-carrierfees")]
    SmsMessagesCarrierfees,
    #[serde(rename = "sms-messages-features")]
    #[display("sms-messages-features")]
    SmsMessagesFeatures,
    #[serde(rename = "sms-messages-features-senderid")]
    #[display("sms-messages-features-senderid")]
    SmsMessagesFeaturesSenderid,
    #[serde(rename = "sms-outbound")]
    #[display("sms-outbound")]
    SmsOutbound,
    #[serde(rename = "sms-outbound-content-inspection")]
    #[display("sms-outbound-content-inspection")]
    SmsOutboundContentInspection,
    #[serde(rename = "sms-outbound-longcode")]
    #[display("sms-outbound-longcode")]
    SmsOutboundLongcode,
    #[serde(rename = "sms-outbound-shortcode")]
    #[display("sms-outbound-shortcode")]
    SmsOutboundShortcode,
    #[serde(rename = "speech-recognition")]
    #[display("speech-recognition")]
    SpeechRecognition,
    #[serde(rename = "studio-engagements")]
    #[display("studio-engagements")]
    StudioEngagements,
    #[serde(rename = "sync")]
    #[display("sync")]
    Sync,
    #[serde(rename = "sync-actions")]
    #[display("sync-actions")]
    SyncActions,
    #[serde(rename = "sync-endpoint-hours")]
    #[display("sync-endpoint-hours")]
    SyncEndpointHours,
    #[serde(rename = "sync-endpoint-hours-above-daily-cap")]
    #[display("sync-endpoint-hours-above-daily-cap")]
    SyncEndpointHoursAboveDailyCap,
    #[serde(rename = "taskrouter-tasks")]
    #[display("taskrouter-tasks")]
    TaskrouterTasks,
    #[serde(rename = "totalprice")]
    #[display("totalprice")]
    Totalprice,
    #[serde(rename = "transcriptions")]
    #[display("transcriptions")]
    Transcriptions,
    #[serde(rename = "trunking-cps")]
    #[display("trunking-cps")]
    TrunkingCps,
    #[serde(rename = "trunking-emergency-calls")]
    #[display("trunking-emergency-calls")]
    TrunkingEmergencyCalls,
    #[serde(rename = "trunking-origination")]
    #[display("trunking-origination")]
    TrunkingOrigination,
    #[serde(rename = "trunking-origination-local")]
    #[display("trunking-origination-local")]
    TrunkingOriginationLocal,
    #[serde(rename = "trunking-origination-mobile")]
    #[display("trunking-origination-mobile")]
    TrunkingOriginationMobile,
    #[serde(rename = "trunking-origination-tollfree")]
    #[display("trunking-origination-tollfree")]
    TrunkingOriginationTollfree,
    #[serde(rename = "trunking-recordings")]
    #[display("trunking-recordings")]
    TrunkingRecordings,
    #[serde(rename = "trunking-secure")]
    #[display("trunking-secure")]
    TrunkingSecure,
    #[serde(rename = "trunking-termination")]
    #[display("trunking-termination")]
    TrunkingTermination,
    #[serde(rename = "turnmegabytes")]
    #[display("turnmegabytes")]
    Turnmegabytes,
    #[serde(rename = "turnmegabytes-australia")]
    #[display("turnmegabytes-australia")]
    TurnmegabytesAustralia,
    #[serde(rename = "turnmegabytes-brasil")]
    #[display("turnmegabytes-brasil")]
    TurnmegabytesBrasil,
    #[serde(rename = "turnmegabytes-germany")]
    #[display("turnmegabytes-germany")]
    TurnmegabytesGermany,
    #[serde(rename = "turnmegabytes-india")]
    #[display("turnmegabytes-india")]
    TurnmegabytesIndia,
    #[serde(rename = "turnmegabytes-ireland")]
    #[display("turnmegabytes-ireland")]
    TurnmegabytesIreland,
    #[serde(rename = "turnmegabytes-japan")]
    #[display("turnmegabytes-japan")]
    TurnmegabytesJapan,
    #[serde(rename = "turnmegabytes-singapore")]
    #[display("turnmegabytes-singapore")]
    TurnmegabytesSingapore,
    #[serde(rename = "turnmegabytes-useast")]
    #[display("turnmegabytes-useast")]
    TurnmegabytesUseast,
    #[serde(rename = "turnmegabytes-uswest")]
    #[display("turnmegabytes-uswest")]
    TurnmegabytesUswest,
    #[serde(rename = "twilio-interconnect")]
    #[display("twilio-interconnect")]
    TwilioInterconnect,
    #[serde(rename = "verify-push")]
    #[display("verify-push")]
    VerifyPush,
    #[serde(rename = "verify-totp")]
    #[display("verify-totp")]
    VerifyTotp,
    #[serde(rename = "verify-whatsapp-conversations-business-initiated")]
    #[display("verify-whatsapp-conversations-business-initiated")]
    VerifyWhatsappConversationsBusinessInitiated,
    #[serde(rename = "video-recordings")]
    #[display("video-recordings")]
    VideoRecordings,
    #[serde(rename = "virtual-agent")]
    #[display("virtual-agent")]
    VirtualAgent,
    #[serde(rename = "voice-insights")]
    #[display("voice-insights")]
    VoiceInsights,
    #[serde(rename = "voice-insights-client-insights-on-demand-minute")]
    #[display("voice-insights-client-insights-on-demand-minute")]
    VoiceInsightsClientInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-ptsn-insights-on-demand-minute")]
    #[display("voice-insights-ptsn-insights-on-demand-minute")]
    VoiceInsightsPtsnInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-interface-insights-on-demand-minute")]
    #[display("voice-insights-sip-interface-insights-on-demand-minute")]
    VoiceInsightsSipInterfaceInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-trunking-insights-on-demand-minute")]
    #[display("voice-insights-sip-trunking-insights-on-demand-minute")]
    VoiceInsightsSipTrunkingInsightsOnDemandMinute,
    #[serde(rename = "wireless")]
    #[display("wireless")]
    Wireless,
    #[serde(rename = "wireless-orders")]
    #[display("wireless-orders")]
    WirelessOrders,
    #[serde(rename = "wireless-orders-artwork")]
    #[display("wireless-orders-artwork")]
    WirelessOrdersArtwork,
    #[serde(rename = "wireless-orders-bulk")]
    #[display("wireless-orders-bulk")]
    WirelessOrdersBulk,
    #[serde(rename = "wireless-orders-esim")]
    #[display("wireless-orders-esim")]
    WirelessOrdersEsim,
    #[serde(rename = "wireless-orders-starter")]
    #[display("wireless-orders-starter")]
    WirelessOrdersStarter,
    #[serde(rename = "wireless-usage")]
    #[display("wireless-usage")]
    WirelessUsage,
    #[serde(rename = "wireless-usage-commands")]
    #[display("wireless-usage-commands")]
    WirelessUsageCommands,
    #[serde(rename = "wireless-usage-commands-africa")]
    #[display("wireless-usage-commands-africa")]
    WirelessUsageCommandsAfrica,
    #[serde(rename = "wireless-usage-commands-asia")]
    #[display("wireless-usage-commands-asia")]
    WirelessUsageCommandsAsia,
    #[serde(rename = "wireless-usage-commands-centralandsouthamerica")]
    #[display("wireless-usage-commands-centralandsouthamerica")]
    WirelessUsageCommandsCentralandsouthamerica,
    #[serde(rename = "wireless-usage-commands-europe")]
    #[display("wireless-usage-commands-europe")]
    WirelessUsageCommandsEurope,
    #[serde(rename = "wireless-usage-commands-home")]
    #[display("wireless-usage-commands-home")]
    WirelessUsageCommandsHome,
    #[serde(rename = "wireless-usage-commands-northamerica")]
    #[display("wireless-usage-commands-northamerica")]
    WirelessUsageCommandsNorthamerica,
    #[serde(rename = "wireless-usage-commands-oceania")]
    #[display("wireless-usage-commands-oceania")]
    WirelessUsageCommandsOceania,
    #[serde(rename = "wireless-usage-commands-roaming")]
    #[display("wireless-usage-commands-roaming")]
    WirelessUsageCommandsRoaming,
    #[serde(rename = "wireless-usage-data")]
    #[display("wireless-usage-data")]
    WirelessUsageData,
    #[serde(rename = "wireless-usage-data-africa")]
    #[display("wireless-usage-data-africa")]
    WirelessUsageDataAfrica,
    #[serde(rename = "wireless-usage-data-asia")]
    #[display("wireless-usage-data-asia")]
    WirelessUsageDataAsia,
    #[serde(rename = "wireless-usage-data-centralandsouthamerica")]
    #[display("wireless-usage-data-centralandsouthamerica")]
    WirelessUsageDataCentralandsouthamerica,
    #[serde(rename = "wireless-usage-data-custom-additionalmb")]
    #[display("wireless-usage-data-custom-additionalmb")]
    WirelessUsageDataCustomAdditionalmb,
    #[serde(rename = "wireless-usage-data-custom-first5mb")]
    #[display("wireless-usage-data-custom-first5mb")]
    WirelessUsageDataCustomFirst5Mb,
    #[serde(rename = "wireless-usage-data-domestic-roaming")]
    #[display("wireless-usage-data-domestic-roaming")]
    WirelessUsageDataDomesticRoaming,
    #[serde(rename = "wireless-usage-data-europe")]
    #[display("wireless-usage-data-europe")]
    WirelessUsageDataEurope,
    #[serde(rename = "wireless-usage-data-individual-additionalgb")]
    #[display("wireless-usage-data-individual-additionalgb")]
    WirelessUsageDataIndividualAdditionalgb,
    #[serde(rename = "wireless-usage-data-individual-firstgb")]
    #[display("wireless-usage-data-individual-firstgb")]
    WirelessUsageDataIndividualFirstgb,
    #[serde(rename = "wireless-usage-data-international-roaming-canada")]
    #[display("wireless-usage-data-international-roaming-canada")]
    WirelessUsageDataInternationalRoamingCanada,
    #[serde(rename = "wireless-usage-data-international-roaming-india")]
    #[display("wireless-usage-data-international-roaming-india")]
    WirelessUsageDataInternationalRoamingIndia,
    #[serde(rename = "wireless-usage-data-international-roaming-mexico")]
    #[display("wireless-usage-data-international-roaming-mexico")]
    WirelessUsageDataInternationalRoamingMexico,
    #[serde(rename = "wireless-usage-data-northamerica")]
    #[display("wireless-usage-data-northamerica")]
    WirelessUsageDataNorthamerica,
    #[serde(rename = "wireless-usage-data-oceania")]
    #[display("wireless-usage-data-oceania")]
    WirelessUsageDataOceania,
    #[serde(rename = "wireless-usage-data-pooled")]
    #[display("wireless-usage-data-pooled")]
    WirelessUsageDataPooled,
    #[serde(rename = "wireless-usage-data-pooled-downlink")]
    #[display("wireless-usage-data-pooled-downlink")]
    WirelessUsageDataPooledDownlink,
    #[serde(rename = "wireless-usage-data-pooled-uplink")]
    #[display("wireless-usage-data-pooled-uplink")]
    WirelessUsageDataPooledUplink,
    #[serde(rename = "wireless-usage-mrc")]
    #[display("wireless-usage-mrc")]
    WirelessUsageMrc,
    #[serde(rename = "wireless-usage-mrc-custom")]
    #[display("wireless-usage-mrc-custom")]
    WirelessUsageMrcCustom,
    #[serde(rename = "wireless-usage-mrc-individual")]
    #[display("wireless-usage-mrc-individual")]
    WirelessUsageMrcIndividual,
    #[serde(rename = "wireless-usage-mrc-pooled")]
    #[display("wireless-usage-mrc-pooled")]
    WirelessUsageMrcPooled,
    #[serde(rename = "wireless-usage-mrc-suspended")]
    #[display("wireless-usage-mrc-suspended")]
    WirelessUsageMrcSuspended,
    #[serde(rename = "wireless-usage-sms")]
    #[display("wireless-usage-sms")]
    WirelessUsageSms,
    #[serde(rename = "wireless-usage-voice")]
    #[display("wireless-usage-voice")]
    WirelessUsageVoice,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountUsageUsageRecordUsageRecordMonthly {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that accrued \
             the usage."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to create the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "Usage records up to date as of this timestamp, formatted as \
             YYYY-MM-DDTHH:MM:SS+00:00. All timestamps are in GMT"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub as_of: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub category: Option<UsageRecordMonthlyEnumCategory>,
    #[doc = "The number of usage events, such as the number of calls."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<String>,
    #[doc = "The units in which `count` is measured, such as `calls` for calls or `messages` for \
             SMS."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count_unit: Option<String>,
    #[doc = "A plain-language description of the usage category."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "The last date for which usage is included in the UsageRecord. The date is specified \
             in GMT and formatted as `YYYY-MM-DD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_date: Option<chrono::NaiveDate>,
    #[doc = "The total price of the usage in the currency specified in `price_unit` and \
             associated with the account."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<f64>,
    #[doc = "The currency in which `price` is measured, in [ISO 4127](https://www.iso.org/iso/home/standards/currency_codes.htm) format, such as `usd`, `eur`, and `jpy`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price_unit: Option<String>,
    #[doc = "The first date for which usage is included in this UsageRecord. The date is \
             specified in GMT and formatted as `YYYY-MM-DD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_date: Option<chrono::NaiveDate>,
    #[doc = "A list of related resources identified by their URIs. For more information, see [List Subresources](https://www.twilio.com/docs/usage/api/usage-record#list-subresources)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "The amount used to bill usage and measured in units described in `usage_unit`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage: Option<String>,
    #[doc = "The units in which `usage` is measured, such as `minutes` for calls or `messages` \
             for SMS."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_unit: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountUsageUsageRecordUsageRecordMonthly {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountUsageUsageRecordUsageRecordMonthly {
    const LENGTH: usize = 15;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(as_of) = &self.as_of {
                format!("{as_of:?}")
            } else {
                String::new()
            },
            if let Some(category) = &self.category {
                format!("{category:?}")
            } else {
                String::new()
            },
            if let Some(count) = &self.count {
                format!("{count:?}")
            } else {
                String::new()
            },
            if let Some(count_unit) = &self.count_unit {
                format!("{count_unit:?}")
            } else {
                String::new()
            },
            if let Some(description) = &self.description {
                format!("{description:?}")
            } else {
                String::new()
            },
            if let Some(end_date) = &self.end_date {
                format!("{end_date:?}")
            } else {
                String::new()
            },
            if let Some(price) = &self.price {
                format!("{price:?}")
            } else {
                String::new()
            },
            if let Some(price_unit) = &self.price_unit {
                format!("{price_unit:?}")
            } else {
                String::new()
            },
            if let Some(start_date) = &self.start_date {
                format!("{start_date:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(usage) = &self.usage {
                format!("{usage:?}")
            } else {
                String::new()
            },
            if let Some(usage_unit) = &self.usage_unit {
                format!("{usage_unit:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "as_of".to_string(),
            "category".to_string(),
            "count".to_string(),
            "count_unit".to_string(),
            "description".to_string(),
            "end_date".to_string(),
            "price".to_string(),
            "price_unit".to_string(),
            "start_date".to_string(),
            "subresource_uris".to_string(),
            "uri".to_string(),
            "usage".to_string(),
            "usage_unit".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UsageRecordMonthlyEnumCategory {
    #[serde(rename = "a2p-registration-fees")]
    #[display("a2p-registration-fees")]
    A2PRegistrationFees,
    #[serde(rename = "agent-conference")]
    #[display("agent-conference")]
    AgentConference,
    #[serde(rename = "amazon-polly")]
    #[display("amazon-polly")]
    AmazonPolly,
    #[serde(rename = "answering-machine-detection")]
    #[display("answering-machine-detection")]
    AnsweringMachineDetection,
    #[serde(rename = "authy-authentications")]
    #[display("authy-authentications")]
    AuthyAuthentications,
    #[serde(rename = "authy-calls-outbound")]
    #[display("authy-calls-outbound")]
    AuthyCallsOutbound,
    #[serde(rename = "authy-monthly-fees")]
    #[display("authy-monthly-fees")]
    AuthyMonthlyFees,
    #[serde(rename = "authy-phone-intelligence")]
    #[display("authy-phone-intelligence")]
    AuthyPhoneIntelligence,
    #[serde(rename = "authy-phone-verifications")]
    #[display("authy-phone-verifications")]
    AuthyPhoneVerifications,
    #[serde(rename = "authy-sms-outbound")]
    #[display("authy-sms-outbound")]
    AuthySmsOutbound,
    #[serde(rename = "call-progess-events")]
    #[display("call-progess-events")]
    CallProgessEvents,
    #[serde(rename = "calleridlookups")]
    #[display("calleridlookups")]
    Calleridlookups,
    #[serde(rename = "calls")]
    #[display("calls")]
    Calls,
    #[serde(rename = "calls-client")]
    #[display("calls-client")]
    CallsClient,
    #[serde(rename = "calls-globalconference")]
    #[display("calls-globalconference")]
    CallsGlobalconference,
    #[serde(rename = "calls-inbound")]
    #[display("calls-inbound")]
    CallsInbound,
    #[serde(rename = "calls-inbound-local")]
    #[display("calls-inbound-local")]
    CallsInboundLocal,
    #[serde(rename = "calls-inbound-mobile")]
    #[display("calls-inbound-mobile")]
    CallsInboundMobile,
    #[serde(rename = "calls-inbound-tollfree")]
    #[display("calls-inbound-tollfree")]
    CallsInboundTollfree,
    #[serde(rename = "calls-outbound")]
    #[display("calls-outbound")]
    CallsOutbound,
    #[serde(rename = "calls-pay-verb-transactions")]
    #[display("calls-pay-verb-transactions")]
    CallsPayVerbTransactions,
    #[serde(rename = "calls-recordings")]
    #[display("calls-recordings")]
    CallsRecordings,
    #[serde(rename = "calls-sip")]
    #[display("calls-sip")]
    CallsSip,
    #[serde(rename = "calls-sip-inbound")]
    #[display("calls-sip-inbound")]
    CallsSipInbound,
    #[serde(rename = "calls-sip-outbound")]
    #[display("calls-sip-outbound")]
    CallsSipOutbound,
    #[serde(rename = "calls-transfers")]
    #[display("calls-transfers")]
    CallsTransfers,
    #[serde(rename = "carrier-lookups")]
    #[display("carrier-lookups")]
    CarrierLookups,
    #[serde(rename = "conversations")]
    #[display("conversations")]
    Conversations,
    #[serde(rename = "conversations-api-requests")]
    #[display("conversations-api-requests")]
    ConversationsApiRequests,
    #[serde(rename = "conversations-conversation-events")]
    #[display("conversations-conversation-events")]
    ConversationsConversationEvents,
    #[serde(rename = "conversations-endpoint-connectivity")]
    #[display("conversations-endpoint-connectivity")]
    ConversationsEndpointConnectivity,
    #[serde(rename = "conversations-events")]
    #[display("conversations-events")]
    ConversationsEvents,
    #[serde(rename = "conversations-participant-events")]
    #[display("conversations-participant-events")]
    ConversationsParticipantEvents,
    #[serde(rename = "conversations-participants")]
    #[display("conversations-participants")]
    ConversationsParticipants,
    #[serde(rename = "cps")]
    #[display("cps")]
    Cps,
    #[serde(rename = "flex-usage")]
    #[display("flex-usage")]
    FlexUsage,
    #[serde(rename = "fraud-lookups")]
    #[display("fraud-lookups")]
    FraudLookups,
    #[serde(rename = "group-rooms")]
    #[display("group-rooms")]
    GroupRooms,
    #[serde(rename = "group-rooms-data-track")]
    #[display("group-rooms-data-track")]
    GroupRoomsDataTrack,
    #[serde(rename = "group-rooms-encrypted-media-recorded")]
    #[display("group-rooms-encrypted-media-recorded")]
    GroupRoomsEncryptedMediaRecorded,
    #[serde(rename = "group-rooms-media-downloaded")]
    #[display("group-rooms-media-downloaded")]
    GroupRoomsMediaDownloaded,
    #[serde(rename = "group-rooms-media-recorded")]
    #[display("group-rooms-media-recorded")]
    GroupRoomsMediaRecorded,
    #[serde(rename = "group-rooms-media-routed")]
    #[display("group-rooms-media-routed")]
    GroupRoomsMediaRouted,
    #[serde(rename = "group-rooms-media-stored")]
    #[display("group-rooms-media-stored")]
    GroupRoomsMediaStored,
    #[serde(rename = "group-rooms-participant-minutes")]
    #[display("group-rooms-participant-minutes")]
    GroupRoomsParticipantMinutes,
    #[serde(rename = "group-rooms-recorded-minutes")]
    #[display("group-rooms-recorded-minutes")]
    GroupRoomsRecordedMinutes,
    #[serde(rename = "imp-v1-usage")]
    #[display("imp-v1-usage")]
    ImpUsage,
    #[serde(rename = "lookups")]
    #[display("lookups")]
    Lookups,
    #[serde(rename = "marketplace")]
    #[display("marketplace")]
    Marketplace,
    #[serde(rename = "marketplace-algorithmia-named-entity-recognition")]
    #[display("marketplace-algorithmia-named-entity-recognition")]
    MarketplaceAlgorithmiaNamedEntityRecognition,
    #[serde(rename = "marketplace-cadence-transcription")]
    #[display("marketplace-cadence-transcription")]
    MarketplaceCadenceTranscription,
    #[serde(rename = "marketplace-cadence-translation")]
    #[display("marketplace-cadence-translation")]
    MarketplaceCadenceTranslation,
    #[serde(rename = "marketplace-capio-speech-to-text")]
    #[display("marketplace-capio-speech-to-text")]
    MarketplaceCapioSpeechToText,
    #[serde(rename = "marketplace-convriza-ababa")]
    #[display("marketplace-convriza-ababa")]
    MarketplaceConvrizaAbaba,
    #[serde(rename = "marketplace-deepgram-phrase-detector")]
    #[display("marketplace-deepgram-phrase-detector")]
    MarketplaceDeepgramPhraseDetector,
    #[serde(rename = "marketplace-digital-segment-business-info")]
    #[display("marketplace-digital-segment-business-info")]
    MarketplaceDigitalSegmentBusinessInfo,
    #[serde(rename = "marketplace-facebook-offline-conversions")]
    #[display("marketplace-facebook-offline-conversions")]
    MarketplaceFacebookOfflineConversions,
    #[serde(rename = "marketplace-google-speech-to-text")]
    #[display("marketplace-google-speech-to-text")]
    MarketplaceGoogleSpeechToText,
    #[serde(rename = "marketplace-ibm-watson-message-insights")]
    #[display("marketplace-ibm-watson-message-insights")]
    MarketplaceIbmWatsonMessageInsights,
    #[serde(rename = "marketplace-ibm-watson-message-sentiment")]
    #[display("marketplace-ibm-watson-message-sentiment")]
    MarketplaceIbmWatsonMessageSentiment,
    #[serde(rename = "marketplace-ibm-watson-recording-analysis")]
    #[display("marketplace-ibm-watson-recording-analysis")]
    MarketplaceIbmWatsonRecordingAnalysis,
    #[serde(rename = "marketplace-ibm-watson-tone-analyzer")]
    #[display("marketplace-ibm-watson-tone-analyzer")]
    MarketplaceIbmWatsonToneAnalyzer,
    #[serde(rename = "marketplace-icehook-systems-scout")]
    #[display("marketplace-icehook-systems-scout")]
    MarketplaceIcehookSystemsScout,
    #[serde(rename = "marketplace-infogroup-dataaxle-bizinfo")]
    #[display("marketplace-infogroup-dataaxle-bizinfo")]
    MarketplaceInfogroupDataaxleBizinfo,
    #[serde(rename = "marketplace-keen-io-contact-center-analytics")]
    #[display("marketplace-keen-io-contact-center-analytics")]
    MarketplaceKeenIoContactCenterAnalytics,
    #[serde(rename = "marketplace-marchex-cleancall")]
    #[display("marketplace-marchex-cleancall")]
    MarketplaceMarchexCleancall,
    #[serde(rename = "marketplace-marchex-sentiment-analysis-for-sms")]
    #[display("marketplace-marchex-sentiment-analysis-for-sms")]
    MarketplaceMarchexSentimentAnalysisForSms,
    #[serde(rename = "marketplace-marketplace-nextcaller-social-id")]
    #[display("marketplace-marketplace-nextcaller-social-id")]
    MarketplaceMarketplaceNextcallerSocialId,
    #[serde(rename = "marketplace-mobile-commons-opt-out-classifier")]
    #[display("marketplace-mobile-commons-opt-out-classifier")]
    MarketplaceMobileCommonsOptOutClassifier,
    #[serde(rename = "marketplace-nexiwave-voicemail-to-text")]
    #[display("marketplace-nexiwave-voicemail-to-text")]
    MarketplaceNexiwaveVoicemailToText,
    #[serde(rename = "marketplace-nextcaller-advanced-caller-identification")]
    #[display("marketplace-nextcaller-advanced-caller-identification")]
    MarketplaceNextcallerAdvancedCallerIdentification,
    #[serde(rename = "marketplace-nomorobo-spam-score")]
    #[display("marketplace-nomorobo-spam-score")]
    MarketplaceNomoroboSpamScore,
    #[serde(rename = "marketplace-payfone-tcpa-compliance")]
    #[display("marketplace-payfone-tcpa-compliance")]
    MarketplacePayfoneTcpaCompliance,
    #[serde(rename = "marketplace-remeeting-automatic-speech-recognition")]
    #[display("marketplace-remeeting-automatic-speech-recognition")]
    MarketplaceRemeetingAutomaticSpeechRecognition,
    #[serde(rename = "marketplace-tcpa-defense-solutions-blacklist-feed")]
    #[display("marketplace-tcpa-defense-solutions-blacklist-feed")]
    MarketplaceTcpaDefenseSolutionsBlacklistFeed,
    #[serde(rename = "marketplace-telo-opencnam")]
    #[display("marketplace-telo-opencnam")]
    MarketplaceTeloOpencnam,
    #[serde(rename = "marketplace-truecnam-true-spam")]
    #[display("marketplace-truecnam-true-spam")]
    MarketplaceTruecnamTrueSpam,
    #[serde(rename = "marketplace-twilio-caller-name-lookup-us")]
    #[display("marketplace-twilio-caller-name-lookup-us")]
    MarketplaceTwilioCallerNameLookupUs,
    #[serde(rename = "marketplace-twilio-carrier-information-lookup")]
    #[display("marketplace-twilio-carrier-information-lookup")]
    MarketplaceTwilioCarrierInformationLookup,
    #[serde(rename = "marketplace-voicebase-pci")]
    #[display("marketplace-voicebase-pci")]
    MarketplaceVoicebasePci,
    #[serde(rename = "marketplace-voicebase-transcription")]
    #[display("marketplace-voicebase-transcription")]
    MarketplaceVoicebaseTranscription,
    #[serde(rename = "marketplace-voicebase-transcription-custom-vocabulary")]
    #[display("marketplace-voicebase-transcription-custom-vocabulary")]
    MarketplaceVoicebaseTranscriptionCustomVocabulary,
    #[serde(rename = "marketplace-whitepages-pro-caller-identification")]
    #[display("marketplace-whitepages-pro-caller-identification")]
    MarketplaceWhitepagesProCallerIdentification,
    #[serde(rename = "marketplace-whitepages-pro-phone-intelligence")]
    #[display("marketplace-whitepages-pro-phone-intelligence")]
    MarketplaceWhitepagesProPhoneIntelligence,
    #[serde(rename = "marketplace-whitepages-pro-phone-reputation")]
    #[display("marketplace-whitepages-pro-phone-reputation")]
    MarketplaceWhitepagesProPhoneReputation,
    #[serde(rename = "marketplace-wolfarm-spoken-results")]
    #[display("marketplace-wolfarm-spoken-results")]
    MarketplaceWolfarmSpokenResults,
    #[serde(rename = "marketplace-wolfram-short-answer")]
    #[display("marketplace-wolfram-short-answer")]
    MarketplaceWolframShortAnswer,
    #[serde(rename = "marketplace-ytica-contact-center-reporting-analytics")]
    #[display("marketplace-ytica-contact-center-reporting-analytics")]
    MarketplaceYticaContactCenterReportingAnalytics,
    #[serde(rename = "mediastorage")]
    #[display("mediastorage")]
    Mediastorage,
    #[serde(rename = "mms")]
    #[display("mms")]
    Mms,
    #[serde(rename = "mms-inbound")]
    #[display("mms-inbound")]
    MmsInbound,
    #[serde(rename = "mms-inbound-longcode")]
    #[display("mms-inbound-longcode")]
    MmsInboundLongcode,
    #[serde(rename = "mms-inbound-shortcode")]
    #[display("mms-inbound-shortcode")]
    MmsInboundShortcode,
    #[serde(rename = "mms-messages-carrierfees")]
    #[display("mms-messages-carrierfees")]
    MmsMessagesCarrierfees,
    #[serde(rename = "mms-outbound")]
    #[display("mms-outbound")]
    MmsOutbound,
    #[serde(rename = "mms-outbound-longcode")]
    #[display("mms-outbound-longcode")]
    MmsOutboundLongcode,
    #[serde(rename = "mms-outbound-shortcode")]
    #[display("mms-outbound-shortcode")]
    MmsOutboundShortcode,
    #[serde(rename = "monitor-reads")]
    #[display("monitor-reads")]
    MonitorReads,
    #[serde(rename = "monitor-storage")]
    #[display("monitor-storage")]
    MonitorStorage,
    #[serde(rename = "monitor-writes")]
    #[display("monitor-writes")]
    MonitorWrites,
    #[serde(rename = "notify")]
    #[display("notify")]
    Notify,
    #[serde(rename = "notify-actions-attempts")]
    #[display("notify-actions-attempts")]
    NotifyActionsAttempts,
    #[serde(rename = "notify-channels")]
    #[display("notify-channels")]
    NotifyChannels,
    #[serde(rename = "number-format-lookups")]
    #[display("number-format-lookups")]
    NumberFormatLookups,
    #[serde(rename = "pchat")]
    #[display("pchat")]
    Pchat,
    #[serde(rename = "pchat-users")]
    #[display("pchat-users")]
    PchatUsers,
    #[serde(rename = "peer-to-peer-rooms-participant-minutes")]
    #[display("peer-to-peer-rooms-participant-minutes")]
    PeerToPeerRoomsParticipantMinutes,
    #[serde(rename = "pfax")]
    #[display("pfax")]
    Pfax,
    #[serde(rename = "pfax-minutes")]
    #[display("pfax-minutes")]
    PfaxMinutes,
    #[serde(rename = "pfax-minutes-inbound")]
    #[display("pfax-minutes-inbound")]
    PfaxMinutesInbound,
    #[serde(rename = "pfax-minutes-outbound")]
    #[display("pfax-minutes-outbound")]
    PfaxMinutesOutbound,
    #[serde(rename = "pfax-pages")]
    #[display("pfax-pages")]
    PfaxPages,
    #[serde(rename = "phonenumbers")]
    #[display("phonenumbers")]
    Phonenumbers,
    #[serde(rename = "phonenumbers-cps")]
    #[display("phonenumbers-cps")]
    PhonenumbersCps,
    #[serde(rename = "phonenumbers-emergency")]
    #[display("phonenumbers-emergency")]
    PhonenumbersEmergency,
    #[serde(rename = "phonenumbers-local")]
    #[display("phonenumbers-local")]
    PhonenumbersLocal,
    #[serde(rename = "phonenumbers-mobile")]
    #[display("phonenumbers-mobile")]
    PhonenumbersMobile,
    #[serde(rename = "phonenumbers-setups")]
    #[display("phonenumbers-setups")]
    PhonenumbersSetups,
    #[serde(rename = "phonenumbers-tollfree")]
    #[display("phonenumbers-tollfree")]
    PhonenumbersTollfree,
    #[serde(rename = "premiumsupport")]
    #[display("premiumsupport")]
    Premiumsupport,
    #[serde(rename = "proxy")]
    #[display("proxy")]
    Proxy,
    #[serde(rename = "proxy-active-sessions")]
    #[display("proxy-active-sessions")]
    ProxyActiveSessions,
    #[serde(rename = "pstnconnectivity")]
    #[display("pstnconnectivity")]
    Pstnconnectivity,
    #[serde(rename = "pv")]
    #[display("pv")]
    Pv,
    #[serde(rename = "pv-composition-media-downloaded")]
    #[display("pv-composition-media-downloaded")]
    PvCompositionMediaDownloaded,
    #[serde(rename = "pv-composition-media-encrypted")]
    #[display("pv-composition-media-encrypted")]
    PvCompositionMediaEncrypted,
    #[serde(rename = "pv-composition-media-stored")]
    #[display("pv-composition-media-stored")]
    PvCompositionMediaStored,
    #[serde(rename = "pv-composition-minutes")]
    #[display("pv-composition-minutes")]
    PvCompositionMinutes,
    #[serde(rename = "pv-recording-compositions")]
    #[display("pv-recording-compositions")]
    PvRecordingCompositions,
    #[serde(rename = "pv-room-participants")]
    #[display("pv-room-participants")]
    PvRoomParticipants,
    #[serde(rename = "pv-room-participants-au1")]
    #[display("pv-room-participants-au1")]
    PvRoomParticipantsAu1,
    #[serde(rename = "pv-room-participants-br1")]
    #[display("pv-room-participants-br1")]
    PvRoomParticipantsBr1,
    #[serde(rename = "pv-room-participants-ie1")]
    #[display("pv-room-participants-ie1")]
    PvRoomParticipantsIe1,
    #[serde(rename = "pv-room-participants-jp1")]
    #[display("pv-room-participants-jp1")]
    PvRoomParticipantsJp1,
    #[serde(rename = "pv-room-participants-sg1")]
    #[display("pv-room-participants-sg1")]
    PvRoomParticipantsSg1,
    #[serde(rename = "pv-room-participants-us1")]
    #[display("pv-room-participants-us1")]
    PvRoomParticipantsUs1,
    #[serde(rename = "pv-room-participants-us2")]
    #[display("pv-room-participants-us2")]
    PvRoomParticipantsUs2,
    #[serde(rename = "pv-rooms")]
    #[display("pv-rooms")]
    PvRooms,
    #[serde(rename = "pv-sip-endpoint-registrations")]
    #[display("pv-sip-endpoint-registrations")]
    PvSipEndpointRegistrations,
    #[serde(rename = "recordings")]
    #[display("recordings")]
    Recordings,
    #[serde(rename = "recordingstorage")]
    #[display("recordingstorage")]
    Recordingstorage,
    #[serde(rename = "rooms-group-bandwidth")]
    #[display("rooms-group-bandwidth")]
    RoomsGroupBandwidth,
    #[serde(rename = "rooms-group-minutes")]
    #[display("rooms-group-minutes")]
    RoomsGroupMinutes,
    #[serde(rename = "rooms-peer-to-peer-minutes")]
    #[display("rooms-peer-to-peer-minutes")]
    RoomsPeerToPeerMinutes,
    #[serde(rename = "shortcodes")]
    #[display("shortcodes")]
    Shortcodes,
    #[serde(rename = "shortcodes-customerowned")]
    #[display("shortcodes-customerowned")]
    ShortcodesCustomerowned,
    #[serde(rename = "shortcodes-mms-enablement")]
    #[display("shortcodes-mms-enablement")]
    ShortcodesMmsEnablement,
    #[serde(rename = "shortcodes-mps")]
    #[display("shortcodes-mps")]
    ShortcodesMps,
    #[serde(rename = "shortcodes-random")]
    #[display("shortcodes-random")]
    ShortcodesRandom,
    #[serde(rename = "shortcodes-uk")]
    #[display("shortcodes-uk")]
    ShortcodesUk,
    #[serde(rename = "shortcodes-vanity")]
    #[display("shortcodes-vanity")]
    ShortcodesVanity,
    #[serde(rename = "small-group-rooms")]
    #[display("small-group-rooms")]
    SmallGroupRooms,
    #[serde(rename = "small-group-rooms-data-track")]
    #[display("small-group-rooms-data-track")]
    SmallGroupRoomsDataTrack,
    #[serde(rename = "small-group-rooms-participant-minutes")]
    #[display("small-group-rooms-participant-minutes")]
    SmallGroupRoomsParticipantMinutes,
    #[serde(rename = "sms")]
    #[display("sms")]
    Sms,
    #[serde(rename = "sms-inbound")]
    #[display("sms-inbound")]
    SmsInbound,
    #[serde(rename = "sms-inbound-longcode")]
    #[display("sms-inbound-longcode")]
    SmsInboundLongcode,
    #[serde(rename = "sms-inbound-shortcode")]
    #[display("sms-inbound-shortcode")]
    SmsInboundShortcode,
    #[serde(rename = "sms-messages-carrierfees")]
    #[display("sms-messages-carrierfees")]
    SmsMessagesCarrierfees,
    #[serde(rename = "sms-messages-features")]
    #[display("sms-messages-features")]
    SmsMessagesFeatures,
    #[serde(rename = "sms-messages-features-senderid")]
    #[display("sms-messages-features-senderid")]
    SmsMessagesFeaturesSenderid,
    #[serde(rename = "sms-outbound")]
    #[display("sms-outbound")]
    SmsOutbound,
    #[serde(rename = "sms-outbound-content-inspection")]
    #[display("sms-outbound-content-inspection")]
    SmsOutboundContentInspection,
    #[serde(rename = "sms-outbound-longcode")]
    #[display("sms-outbound-longcode")]
    SmsOutboundLongcode,
    #[serde(rename = "sms-outbound-shortcode")]
    #[display("sms-outbound-shortcode")]
    SmsOutboundShortcode,
    #[serde(rename = "speech-recognition")]
    #[display("speech-recognition")]
    SpeechRecognition,
    #[serde(rename = "studio-engagements")]
    #[display("studio-engagements")]
    StudioEngagements,
    #[serde(rename = "sync")]
    #[display("sync")]
    Sync,
    #[serde(rename = "sync-actions")]
    #[display("sync-actions")]
    SyncActions,
    #[serde(rename = "sync-endpoint-hours")]
    #[display("sync-endpoint-hours")]
    SyncEndpointHours,
    #[serde(rename = "sync-endpoint-hours-above-daily-cap")]
    #[display("sync-endpoint-hours-above-daily-cap")]
    SyncEndpointHoursAboveDailyCap,
    #[serde(rename = "taskrouter-tasks")]
    #[display("taskrouter-tasks")]
    TaskrouterTasks,
    #[serde(rename = "totalprice")]
    #[display("totalprice")]
    Totalprice,
    #[serde(rename = "transcriptions")]
    #[display("transcriptions")]
    Transcriptions,
    #[serde(rename = "trunking-cps")]
    #[display("trunking-cps")]
    TrunkingCps,
    #[serde(rename = "trunking-emergency-calls")]
    #[display("trunking-emergency-calls")]
    TrunkingEmergencyCalls,
    #[serde(rename = "trunking-origination")]
    #[display("trunking-origination")]
    TrunkingOrigination,
    #[serde(rename = "trunking-origination-local")]
    #[display("trunking-origination-local")]
    TrunkingOriginationLocal,
    #[serde(rename = "trunking-origination-mobile")]
    #[display("trunking-origination-mobile")]
    TrunkingOriginationMobile,
    #[serde(rename = "trunking-origination-tollfree")]
    #[display("trunking-origination-tollfree")]
    TrunkingOriginationTollfree,
    #[serde(rename = "trunking-recordings")]
    #[display("trunking-recordings")]
    TrunkingRecordings,
    #[serde(rename = "trunking-secure")]
    #[display("trunking-secure")]
    TrunkingSecure,
    #[serde(rename = "trunking-termination")]
    #[display("trunking-termination")]
    TrunkingTermination,
    #[serde(rename = "turnmegabytes")]
    #[display("turnmegabytes")]
    Turnmegabytes,
    #[serde(rename = "turnmegabytes-australia")]
    #[display("turnmegabytes-australia")]
    TurnmegabytesAustralia,
    #[serde(rename = "turnmegabytes-brasil")]
    #[display("turnmegabytes-brasil")]
    TurnmegabytesBrasil,
    #[serde(rename = "turnmegabytes-germany")]
    #[display("turnmegabytes-germany")]
    TurnmegabytesGermany,
    #[serde(rename = "turnmegabytes-india")]
    #[display("turnmegabytes-india")]
    TurnmegabytesIndia,
    #[serde(rename = "turnmegabytes-ireland")]
    #[display("turnmegabytes-ireland")]
    TurnmegabytesIreland,
    #[serde(rename = "turnmegabytes-japan")]
    #[display("turnmegabytes-japan")]
    TurnmegabytesJapan,
    #[serde(rename = "turnmegabytes-singapore")]
    #[display("turnmegabytes-singapore")]
    TurnmegabytesSingapore,
    #[serde(rename = "turnmegabytes-useast")]
    #[display("turnmegabytes-useast")]
    TurnmegabytesUseast,
    #[serde(rename = "turnmegabytes-uswest")]
    #[display("turnmegabytes-uswest")]
    TurnmegabytesUswest,
    #[serde(rename = "twilio-interconnect")]
    #[display("twilio-interconnect")]
    TwilioInterconnect,
    #[serde(rename = "verify-push")]
    #[display("verify-push")]
    VerifyPush,
    #[serde(rename = "verify-totp")]
    #[display("verify-totp")]
    VerifyTotp,
    #[serde(rename = "verify-whatsapp-conversations-business-initiated")]
    #[display("verify-whatsapp-conversations-business-initiated")]
    VerifyWhatsappConversationsBusinessInitiated,
    #[serde(rename = "video-recordings")]
    #[display("video-recordings")]
    VideoRecordings,
    #[serde(rename = "virtual-agent")]
    #[display("virtual-agent")]
    VirtualAgent,
    #[serde(rename = "voice-insights")]
    #[display("voice-insights")]
    VoiceInsights,
    #[serde(rename = "voice-insights-client-insights-on-demand-minute")]
    #[display("voice-insights-client-insights-on-demand-minute")]
    VoiceInsightsClientInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-ptsn-insights-on-demand-minute")]
    #[display("voice-insights-ptsn-insights-on-demand-minute")]
    VoiceInsightsPtsnInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-interface-insights-on-demand-minute")]
    #[display("voice-insights-sip-interface-insights-on-demand-minute")]
    VoiceInsightsSipInterfaceInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-trunking-insights-on-demand-minute")]
    #[display("voice-insights-sip-trunking-insights-on-demand-minute")]
    VoiceInsightsSipTrunkingInsightsOnDemandMinute,
    #[serde(rename = "wireless")]
    #[display("wireless")]
    Wireless,
    #[serde(rename = "wireless-orders")]
    #[display("wireless-orders")]
    WirelessOrders,
    #[serde(rename = "wireless-orders-artwork")]
    #[display("wireless-orders-artwork")]
    WirelessOrdersArtwork,
    #[serde(rename = "wireless-orders-bulk")]
    #[display("wireless-orders-bulk")]
    WirelessOrdersBulk,
    #[serde(rename = "wireless-orders-esim")]
    #[display("wireless-orders-esim")]
    WirelessOrdersEsim,
    #[serde(rename = "wireless-orders-starter")]
    #[display("wireless-orders-starter")]
    WirelessOrdersStarter,
    #[serde(rename = "wireless-usage")]
    #[display("wireless-usage")]
    WirelessUsage,
    #[serde(rename = "wireless-usage-commands")]
    #[display("wireless-usage-commands")]
    WirelessUsageCommands,
    #[serde(rename = "wireless-usage-commands-africa")]
    #[display("wireless-usage-commands-africa")]
    WirelessUsageCommandsAfrica,
    #[serde(rename = "wireless-usage-commands-asia")]
    #[display("wireless-usage-commands-asia")]
    WirelessUsageCommandsAsia,
    #[serde(rename = "wireless-usage-commands-centralandsouthamerica")]
    #[display("wireless-usage-commands-centralandsouthamerica")]
    WirelessUsageCommandsCentralandsouthamerica,
    #[serde(rename = "wireless-usage-commands-europe")]
    #[display("wireless-usage-commands-europe")]
    WirelessUsageCommandsEurope,
    #[serde(rename = "wireless-usage-commands-home")]
    #[display("wireless-usage-commands-home")]
    WirelessUsageCommandsHome,
    #[serde(rename = "wireless-usage-commands-northamerica")]
    #[display("wireless-usage-commands-northamerica")]
    WirelessUsageCommandsNorthamerica,
    #[serde(rename = "wireless-usage-commands-oceania")]
    #[display("wireless-usage-commands-oceania")]
    WirelessUsageCommandsOceania,
    #[serde(rename = "wireless-usage-commands-roaming")]
    #[display("wireless-usage-commands-roaming")]
    WirelessUsageCommandsRoaming,
    #[serde(rename = "wireless-usage-data")]
    #[display("wireless-usage-data")]
    WirelessUsageData,
    #[serde(rename = "wireless-usage-data-africa")]
    #[display("wireless-usage-data-africa")]
    WirelessUsageDataAfrica,
    #[serde(rename = "wireless-usage-data-asia")]
    #[display("wireless-usage-data-asia")]
    WirelessUsageDataAsia,
    #[serde(rename = "wireless-usage-data-centralandsouthamerica")]
    #[display("wireless-usage-data-centralandsouthamerica")]
    WirelessUsageDataCentralandsouthamerica,
    #[serde(rename = "wireless-usage-data-custom-additionalmb")]
    #[display("wireless-usage-data-custom-additionalmb")]
    WirelessUsageDataCustomAdditionalmb,
    #[serde(rename = "wireless-usage-data-custom-first5mb")]
    #[display("wireless-usage-data-custom-first5mb")]
    WirelessUsageDataCustomFirst5Mb,
    #[serde(rename = "wireless-usage-data-domestic-roaming")]
    #[display("wireless-usage-data-domestic-roaming")]
    WirelessUsageDataDomesticRoaming,
    #[serde(rename = "wireless-usage-data-europe")]
    #[display("wireless-usage-data-europe")]
    WirelessUsageDataEurope,
    #[serde(rename = "wireless-usage-data-individual-additionalgb")]
    #[display("wireless-usage-data-individual-additionalgb")]
    WirelessUsageDataIndividualAdditionalgb,
    #[serde(rename = "wireless-usage-data-individual-firstgb")]
    #[display("wireless-usage-data-individual-firstgb")]
    WirelessUsageDataIndividualFirstgb,
    #[serde(rename = "wireless-usage-data-international-roaming-canada")]
    #[display("wireless-usage-data-international-roaming-canada")]
    WirelessUsageDataInternationalRoamingCanada,
    #[serde(rename = "wireless-usage-data-international-roaming-india")]
    #[display("wireless-usage-data-international-roaming-india")]
    WirelessUsageDataInternationalRoamingIndia,
    #[serde(rename = "wireless-usage-data-international-roaming-mexico")]
    #[display("wireless-usage-data-international-roaming-mexico")]
    WirelessUsageDataInternationalRoamingMexico,
    #[serde(rename = "wireless-usage-data-northamerica")]
    #[display("wireless-usage-data-northamerica")]
    WirelessUsageDataNorthamerica,
    #[serde(rename = "wireless-usage-data-oceania")]
    #[display("wireless-usage-data-oceania")]
    WirelessUsageDataOceania,
    #[serde(rename = "wireless-usage-data-pooled")]
    #[display("wireless-usage-data-pooled")]
    WirelessUsageDataPooled,
    #[serde(rename = "wireless-usage-data-pooled-downlink")]
    #[display("wireless-usage-data-pooled-downlink")]
    WirelessUsageDataPooledDownlink,
    #[serde(rename = "wireless-usage-data-pooled-uplink")]
    #[display("wireless-usage-data-pooled-uplink")]
    WirelessUsageDataPooledUplink,
    #[serde(rename = "wireless-usage-mrc")]
    #[display("wireless-usage-mrc")]
    WirelessUsageMrc,
    #[serde(rename = "wireless-usage-mrc-custom")]
    #[display("wireless-usage-mrc-custom")]
    WirelessUsageMrcCustom,
    #[serde(rename = "wireless-usage-mrc-individual")]
    #[display("wireless-usage-mrc-individual")]
    WirelessUsageMrcIndividual,
    #[serde(rename = "wireless-usage-mrc-pooled")]
    #[display("wireless-usage-mrc-pooled")]
    WirelessUsageMrcPooled,
    #[serde(rename = "wireless-usage-mrc-suspended")]
    #[display("wireless-usage-mrc-suspended")]
    WirelessUsageMrcSuspended,
    #[serde(rename = "wireless-usage-sms")]
    #[display("wireless-usage-sms")]
    WirelessUsageSms,
    #[serde(rename = "wireless-usage-voice")]
    #[display("wireless-usage-voice")]
    WirelessUsageVoice,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountUsageUsageRecordUsageRecordThisMonth {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that accrued \
             the usage."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to create the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "Usage records up to date as of this timestamp, formatted as \
             YYYY-MM-DDTHH:MM:SS+00:00. All timestamps are in GMT"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub as_of: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub category: Option<UsageRecordThisMonthEnumCategory>,
    #[doc = "The number of usage events, such as the number of calls."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<String>,
    #[doc = "The units in which `count` is measured, such as `calls` for calls or `messages` for \
             SMS."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count_unit: Option<String>,
    #[doc = "A plain-language description of the usage category."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "The last date for which usage is included in the UsageRecord. The date is specified \
             in GMT and formatted as `YYYY-MM-DD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_date: Option<chrono::NaiveDate>,
    #[doc = "The total price of the usage in the currency specified in `price_unit` and \
             associated with the account."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<f64>,
    #[doc = "The currency in which `price` is measured, in [ISO 4127](https://www.iso.org/iso/home/standards/currency_codes.htm) format, such as `usd`, `eur`, and `jpy`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price_unit: Option<String>,
    #[doc = "The first date for which usage is included in this UsageRecord. The date is \
             specified in GMT and formatted as `YYYY-MM-DD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_date: Option<chrono::NaiveDate>,
    #[doc = "A list of related resources identified by their URIs. For more information, see [List Subresources](https://www.twilio.com/docs/usage/api/usage-record#list-subresources)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "The amount used to bill usage and measured in units described in `usage_unit`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage: Option<String>,
    #[doc = "The units in which `usage` is measured, such as `minutes` for calls or `messages` \
             for SMS."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_unit: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountUsageUsageRecordUsageRecordThisMonth {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountUsageUsageRecordUsageRecordThisMonth {
    const LENGTH: usize = 15;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(as_of) = &self.as_of {
                format!("{as_of:?}")
            } else {
                String::new()
            },
            if let Some(category) = &self.category {
                format!("{category:?}")
            } else {
                String::new()
            },
            if let Some(count) = &self.count {
                format!("{count:?}")
            } else {
                String::new()
            },
            if let Some(count_unit) = &self.count_unit {
                format!("{count_unit:?}")
            } else {
                String::new()
            },
            if let Some(description) = &self.description {
                format!("{description:?}")
            } else {
                String::new()
            },
            if let Some(end_date) = &self.end_date {
                format!("{end_date:?}")
            } else {
                String::new()
            },
            if let Some(price) = &self.price {
                format!("{price:?}")
            } else {
                String::new()
            },
            if let Some(price_unit) = &self.price_unit {
                format!("{price_unit:?}")
            } else {
                String::new()
            },
            if let Some(start_date) = &self.start_date {
                format!("{start_date:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(usage) = &self.usage {
                format!("{usage:?}")
            } else {
                String::new()
            },
            if let Some(usage_unit) = &self.usage_unit {
                format!("{usage_unit:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "as_of".to_string(),
            "category".to_string(),
            "count".to_string(),
            "count_unit".to_string(),
            "description".to_string(),
            "end_date".to_string(),
            "price".to_string(),
            "price_unit".to_string(),
            "start_date".to_string(),
            "subresource_uris".to_string(),
            "uri".to_string(),
            "usage".to_string(),
            "usage_unit".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UsageRecordThisMonthEnumCategory {
    #[serde(rename = "a2p-registration-fees")]
    #[display("a2p-registration-fees")]
    A2PRegistrationFees,
    #[serde(rename = "agent-conference")]
    #[display("agent-conference")]
    AgentConference,
    #[serde(rename = "amazon-polly")]
    #[display("amazon-polly")]
    AmazonPolly,
    #[serde(rename = "answering-machine-detection")]
    #[display("answering-machine-detection")]
    AnsweringMachineDetection,
    #[serde(rename = "authy-authentications")]
    #[display("authy-authentications")]
    AuthyAuthentications,
    #[serde(rename = "authy-calls-outbound")]
    #[display("authy-calls-outbound")]
    AuthyCallsOutbound,
    #[serde(rename = "authy-monthly-fees")]
    #[display("authy-monthly-fees")]
    AuthyMonthlyFees,
    #[serde(rename = "authy-phone-intelligence")]
    #[display("authy-phone-intelligence")]
    AuthyPhoneIntelligence,
    #[serde(rename = "authy-phone-verifications")]
    #[display("authy-phone-verifications")]
    AuthyPhoneVerifications,
    #[serde(rename = "authy-sms-outbound")]
    #[display("authy-sms-outbound")]
    AuthySmsOutbound,
    #[serde(rename = "call-progess-events")]
    #[display("call-progess-events")]
    CallProgessEvents,
    #[serde(rename = "calleridlookups")]
    #[display("calleridlookups")]
    Calleridlookups,
    #[serde(rename = "calls")]
    #[display("calls")]
    Calls,
    #[serde(rename = "calls-client")]
    #[display("calls-client")]
    CallsClient,
    #[serde(rename = "calls-globalconference")]
    #[display("calls-globalconference")]
    CallsGlobalconference,
    #[serde(rename = "calls-inbound")]
    #[display("calls-inbound")]
    CallsInbound,
    #[serde(rename = "calls-inbound-local")]
    #[display("calls-inbound-local")]
    CallsInboundLocal,
    #[serde(rename = "calls-inbound-mobile")]
    #[display("calls-inbound-mobile")]
    CallsInboundMobile,
    #[serde(rename = "calls-inbound-tollfree")]
    #[display("calls-inbound-tollfree")]
    CallsInboundTollfree,
    #[serde(rename = "calls-outbound")]
    #[display("calls-outbound")]
    CallsOutbound,
    #[serde(rename = "calls-pay-verb-transactions")]
    #[display("calls-pay-verb-transactions")]
    CallsPayVerbTransactions,
    #[serde(rename = "calls-recordings")]
    #[display("calls-recordings")]
    CallsRecordings,
    #[serde(rename = "calls-sip")]
    #[display("calls-sip")]
    CallsSip,
    #[serde(rename = "calls-sip-inbound")]
    #[display("calls-sip-inbound")]
    CallsSipInbound,
    #[serde(rename = "calls-sip-outbound")]
    #[display("calls-sip-outbound")]
    CallsSipOutbound,
    #[serde(rename = "calls-transfers")]
    #[display("calls-transfers")]
    CallsTransfers,
    #[serde(rename = "carrier-lookups")]
    #[display("carrier-lookups")]
    CarrierLookups,
    #[serde(rename = "conversations")]
    #[display("conversations")]
    Conversations,
    #[serde(rename = "conversations-api-requests")]
    #[display("conversations-api-requests")]
    ConversationsApiRequests,
    #[serde(rename = "conversations-conversation-events")]
    #[display("conversations-conversation-events")]
    ConversationsConversationEvents,
    #[serde(rename = "conversations-endpoint-connectivity")]
    #[display("conversations-endpoint-connectivity")]
    ConversationsEndpointConnectivity,
    #[serde(rename = "conversations-events")]
    #[display("conversations-events")]
    ConversationsEvents,
    #[serde(rename = "conversations-participant-events")]
    #[display("conversations-participant-events")]
    ConversationsParticipantEvents,
    #[serde(rename = "conversations-participants")]
    #[display("conversations-participants")]
    ConversationsParticipants,
    #[serde(rename = "cps")]
    #[display("cps")]
    Cps,
    #[serde(rename = "flex-usage")]
    #[display("flex-usage")]
    FlexUsage,
    #[serde(rename = "fraud-lookups")]
    #[display("fraud-lookups")]
    FraudLookups,
    #[serde(rename = "group-rooms")]
    #[display("group-rooms")]
    GroupRooms,
    #[serde(rename = "group-rooms-data-track")]
    #[display("group-rooms-data-track")]
    GroupRoomsDataTrack,
    #[serde(rename = "group-rooms-encrypted-media-recorded")]
    #[display("group-rooms-encrypted-media-recorded")]
    GroupRoomsEncryptedMediaRecorded,
    #[serde(rename = "group-rooms-media-downloaded")]
    #[display("group-rooms-media-downloaded")]
    GroupRoomsMediaDownloaded,
    #[serde(rename = "group-rooms-media-recorded")]
    #[display("group-rooms-media-recorded")]
    GroupRoomsMediaRecorded,
    #[serde(rename = "group-rooms-media-routed")]
    #[display("group-rooms-media-routed")]
    GroupRoomsMediaRouted,
    #[serde(rename = "group-rooms-media-stored")]
    #[display("group-rooms-media-stored")]
    GroupRoomsMediaStored,
    #[serde(rename = "group-rooms-participant-minutes")]
    #[display("group-rooms-participant-minutes")]
    GroupRoomsParticipantMinutes,
    #[serde(rename = "group-rooms-recorded-minutes")]
    #[display("group-rooms-recorded-minutes")]
    GroupRoomsRecordedMinutes,
    #[serde(rename = "imp-v1-usage")]
    #[display("imp-v1-usage")]
    ImpUsage,
    #[serde(rename = "lookups")]
    #[display("lookups")]
    Lookups,
    #[serde(rename = "marketplace")]
    #[display("marketplace")]
    Marketplace,
    #[serde(rename = "marketplace-algorithmia-named-entity-recognition")]
    #[display("marketplace-algorithmia-named-entity-recognition")]
    MarketplaceAlgorithmiaNamedEntityRecognition,
    #[serde(rename = "marketplace-cadence-transcription")]
    #[display("marketplace-cadence-transcription")]
    MarketplaceCadenceTranscription,
    #[serde(rename = "marketplace-cadence-translation")]
    #[display("marketplace-cadence-translation")]
    MarketplaceCadenceTranslation,
    #[serde(rename = "marketplace-capio-speech-to-text")]
    #[display("marketplace-capio-speech-to-text")]
    MarketplaceCapioSpeechToText,
    #[serde(rename = "marketplace-convriza-ababa")]
    #[display("marketplace-convriza-ababa")]
    MarketplaceConvrizaAbaba,
    #[serde(rename = "marketplace-deepgram-phrase-detector")]
    #[display("marketplace-deepgram-phrase-detector")]
    MarketplaceDeepgramPhraseDetector,
    #[serde(rename = "marketplace-digital-segment-business-info")]
    #[display("marketplace-digital-segment-business-info")]
    MarketplaceDigitalSegmentBusinessInfo,
    #[serde(rename = "marketplace-facebook-offline-conversions")]
    #[display("marketplace-facebook-offline-conversions")]
    MarketplaceFacebookOfflineConversions,
    #[serde(rename = "marketplace-google-speech-to-text")]
    #[display("marketplace-google-speech-to-text")]
    MarketplaceGoogleSpeechToText,
    #[serde(rename = "marketplace-ibm-watson-message-insights")]
    #[display("marketplace-ibm-watson-message-insights")]
    MarketplaceIbmWatsonMessageInsights,
    #[serde(rename = "marketplace-ibm-watson-message-sentiment")]
    #[display("marketplace-ibm-watson-message-sentiment")]
    MarketplaceIbmWatsonMessageSentiment,
    #[serde(rename = "marketplace-ibm-watson-recording-analysis")]
    #[display("marketplace-ibm-watson-recording-analysis")]
    MarketplaceIbmWatsonRecordingAnalysis,
    #[serde(rename = "marketplace-ibm-watson-tone-analyzer")]
    #[display("marketplace-ibm-watson-tone-analyzer")]
    MarketplaceIbmWatsonToneAnalyzer,
    #[serde(rename = "marketplace-icehook-systems-scout")]
    #[display("marketplace-icehook-systems-scout")]
    MarketplaceIcehookSystemsScout,
    #[serde(rename = "marketplace-infogroup-dataaxle-bizinfo")]
    #[display("marketplace-infogroup-dataaxle-bizinfo")]
    MarketplaceInfogroupDataaxleBizinfo,
    #[serde(rename = "marketplace-keen-io-contact-center-analytics")]
    #[display("marketplace-keen-io-contact-center-analytics")]
    MarketplaceKeenIoContactCenterAnalytics,
    #[serde(rename = "marketplace-marchex-cleancall")]
    #[display("marketplace-marchex-cleancall")]
    MarketplaceMarchexCleancall,
    #[serde(rename = "marketplace-marchex-sentiment-analysis-for-sms")]
    #[display("marketplace-marchex-sentiment-analysis-for-sms")]
    MarketplaceMarchexSentimentAnalysisForSms,
    #[serde(rename = "marketplace-marketplace-nextcaller-social-id")]
    #[display("marketplace-marketplace-nextcaller-social-id")]
    MarketplaceMarketplaceNextcallerSocialId,
    #[serde(rename = "marketplace-mobile-commons-opt-out-classifier")]
    #[display("marketplace-mobile-commons-opt-out-classifier")]
    MarketplaceMobileCommonsOptOutClassifier,
    #[serde(rename = "marketplace-nexiwave-voicemail-to-text")]
    #[display("marketplace-nexiwave-voicemail-to-text")]
    MarketplaceNexiwaveVoicemailToText,
    #[serde(rename = "marketplace-nextcaller-advanced-caller-identification")]
    #[display("marketplace-nextcaller-advanced-caller-identification")]
    MarketplaceNextcallerAdvancedCallerIdentification,
    #[serde(rename = "marketplace-nomorobo-spam-score")]
    #[display("marketplace-nomorobo-spam-score")]
    MarketplaceNomoroboSpamScore,
    #[serde(rename = "marketplace-payfone-tcpa-compliance")]
    #[display("marketplace-payfone-tcpa-compliance")]
    MarketplacePayfoneTcpaCompliance,
    #[serde(rename = "marketplace-remeeting-automatic-speech-recognition")]
    #[display("marketplace-remeeting-automatic-speech-recognition")]
    MarketplaceRemeetingAutomaticSpeechRecognition,
    #[serde(rename = "marketplace-tcpa-defense-solutions-blacklist-feed")]
    #[display("marketplace-tcpa-defense-solutions-blacklist-feed")]
    MarketplaceTcpaDefenseSolutionsBlacklistFeed,
    #[serde(rename = "marketplace-telo-opencnam")]
    #[display("marketplace-telo-opencnam")]
    MarketplaceTeloOpencnam,
    #[serde(rename = "marketplace-truecnam-true-spam")]
    #[display("marketplace-truecnam-true-spam")]
    MarketplaceTruecnamTrueSpam,
    #[serde(rename = "marketplace-twilio-caller-name-lookup-us")]
    #[display("marketplace-twilio-caller-name-lookup-us")]
    MarketplaceTwilioCallerNameLookupUs,
    #[serde(rename = "marketplace-twilio-carrier-information-lookup")]
    #[display("marketplace-twilio-carrier-information-lookup")]
    MarketplaceTwilioCarrierInformationLookup,
    #[serde(rename = "marketplace-voicebase-pci")]
    #[display("marketplace-voicebase-pci")]
    MarketplaceVoicebasePci,
    #[serde(rename = "marketplace-voicebase-transcription")]
    #[display("marketplace-voicebase-transcription")]
    MarketplaceVoicebaseTranscription,
    #[serde(rename = "marketplace-voicebase-transcription-custom-vocabulary")]
    #[display("marketplace-voicebase-transcription-custom-vocabulary")]
    MarketplaceVoicebaseTranscriptionCustomVocabulary,
    #[serde(rename = "marketplace-whitepages-pro-caller-identification")]
    #[display("marketplace-whitepages-pro-caller-identification")]
    MarketplaceWhitepagesProCallerIdentification,
    #[serde(rename = "marketplace-whitepages-pro-phone-intelligence")]
    #[display("marketplace-whitepages-pro-phone-intelligence")]
    MarketplaceWhitepagesProPhoneIntelligence,
    #[serde(rename = "marketplace-whitepages-pro-phone-reputation")]
    #[display("marketplace-whitepages-pro-phone-reputation")]
    MarketplaceWhitepagesProPhoneReputation,
    #[serde(rename = "marketplace-wolfarm-spoken-results")]
    #[display("marketplace-wolfarm-spoken-results")]
    MarketplaceWolfarmSpokenResults,
    #[serde(rename = "marketplace-wolfram-short-answer")]
    #[display("marketplace-wolfram-short-answer")]
    MarketplaceWolframShortAnswer,
    #[serde(rename = "marketplace-ytica-contact-center-reporting-analytics")]
    #[display("marketplace-ytica-contact-center-reporting-analytics")]
    MarketplaceYticaContactCenterReportingAnalytics,
    #[serde(rename = "mediastorage")]
    #[display("mediastorage")]
    Mediastorage,
    #[serde(rename = "mms")]
    #[display("mms")]
    Mms,
    #[serde(rename = "mms-inbound")]
    #[display("mms-inbound")]
    MmsInbound,
    #[serde(rename = "mms-inbound-longcode")]
    #[display("mms-inbound-longcode")]
    MmsInboundLongcode,
    #[serde(rename = "mms-inbound-shortcode")]
    #[display("mms-inbound-shortcode")]
    MmsInboundShortcode,
    #[serde(rename = "mms-messages-carrierfees")]
    #[display("mms-messages-carrierfees")]
    MmsMessagesCarrierfees,
    #[serde(rename = "mms-outbound")]
    #[display("mms-outbound")]
    MmsOutbound,
    #[serde(rename = "mms-outbound-longcode")]
    #[display("mms-outbound-longcode")]
    MmsOutboundLongcode,
    #[serde(rename = "mms-outbound-shortcode")]
    #[display("mms-outbound-shortcode")]
    MmsOutboundShortcode,
    #[serde(rename = "monitor-reads")]
    #[display("monitor-reads")]
    MonitorReads,
    #[serde(rename = "monitor-storage")]
    #[display("monitor-storage")]
    MonitorStorage,
    #[serde(rename = "monitor-writes")]
    #[display("monitor-writes")]
    MonitorWrites,
    #[serde(rename = "notify")]
    #[display("notify")]
    Notify,
    #[serde(rename = "notify-actions-attempts")]
    #[display("notify-actions-attempts")]
    NotifyActionsAttempts,
    #[serde(rename = "notify-channels")]
    #[display("notify-channels")]
    NotifyChannels,
    #[serde(rename = "number-format-lookups")]
    #[display("number-format-lookups")]
    NumberFormatLookups,
    #[serde(rename = "pchat")]
    #[display("pchat")]
    Pchat,
    #[serde(rename = "pchat-users")]
    #[display("pchat-users")]
    PchatUsers,
    #[serde(rename = "peer-to-peer-rooms-participant-minutes")]
    #[display("peer-to-peer-rooms-participant-minutes")]
    PeerToPeerRoomsParticipantMinutes,
    #[serde(rename = "pfax")]
    #[display("pfax")]
    Pfax,
    #[serde(rename = "pfax-minutes")]
    #[display("pfax-minutes")]
    PfaxMinutes,
    #[serde(rename = "pfax-minutes-inbound")]
    #[display("pfax-minutes-inbound")]
    PfaxMinutesInbound,
    #[serde(rename = "pfax-minutes-outbound")]
    #[display("pfax-minutes-outbound")]
    PfaxMinutesOutbound,
    #[serde(rename = "pfax-pages")]
    #[display("pfax-pages")]
    PfaxPages,
    #[serde(rename = "phonenumbers")]
    #[display("phonenumbers")]
    Phonenumbers,
    #[serde(rename = "phonenumbers-cps")]
    #[display("phonenumbers-cps")]
    PhonenumbersCps,
    #[serde(rename = "phonenumbers-emergency")]
    #[display("phonenumbers-emergency")]
    PhonenumbersEmergency,
    #[serde(rename = "phonenumbers-local")]
    #[display("phonenumbers-local")]
    PhonenumbersLocal,
    #[serde(rename = "phonenumbers-mobile")]
    #[display("phonenumbers-mobile")]
    PhonenumbersMobile,
    #[serde(rename = "phonenumbers-setups")]
    #[display("phonenumbers-setups")]
    PhonenumbersSetups,
    #[serde(rename = "phonenumbers-tollfree")]
    #[display("phonenumbers-tollfree")]
    PhonenumbersTollfree,
    #[serde(rename = "premiumsupport")]
    #[display("premiumsupport")]
    Premiumsupport,
    #[serde(rename = "proxy")]
    #[display("proxy")]
    Proxy,
    #[serde(rename = "proxy-active-sessions")]
    #[display("proxy-active-sessions")]
    ProxyActiveSessions,
    #[serde(rename = "pstnconnectivity")]
    #[display("pstnconnectivity")]
    Pstnconnectivity,
    #[serde(rename = "pv")]
    #[display("pv")]
    Pv,
    #[serde(rename = "pv-composition-media-downloaded")]
    #[display("pv-composition-media-downloaded")]
    PvCompositionMediaDownloaded,
    #[serde(rename = "pv-composition-media-encrypted")]
    #[display("pv-composition-media-encrypted")]
    PvCompositionMediaEncrypted,
    #[serde(rename = "pv-composition-media-stored")]
    #[display("pv-composition-media-stored")]
    PvCompositionMediaStored,
    #[serde(rename = "pv-composition-minutes")]
    #[display("pv-composition-minutes")]
    PvCompositionMinutes,
    #[serde(rename = "pv-recording-compositions")]
    #[display("pv-recording-compositions")]
    PvRecordingCompositions,
    #[serde(rename = "pv-room-participants")]
    #[display("pv-room-participants")]
    PvRoomParticipants,
    #[serde(rename = "pv-room-participants-au1")]
    #[display("pv-room-participants-au1")]
    PvRoomParticipantsAu1,
    #[serde(rename = "pv-room-participants-br1")]
    #[display("pv-room-participants-br1")]
    PvRoomParticipantsBr1,
    #[serde(rename = "pv-room-participants-ie1")]
    #[display("pv-room-participants-ie1")]
    PvRoomParticipantsIe1,
    #[serde(rename = "pv-room-participants-jp1")]
    #[display("pv-room-participants-jp1")]
    PvRoomParticipantsJp1,
    #[serde(rename = "pv-room-participants-sg1")]
    #[display("pv-room-participants-sg1")]
    PvRoomParticipantsSg1,
    #[serde(rename = "pv-room-participants-us1")]
    #[display("pv-room-participants-us1")]
    PvRoomParticipantsUs1,
    #[serde(rename = "pv-room-participants-us2")]
    #[display("pv-room-participants-us2")]
    PvRoomParticipantsUs2,
    #[serde(rename = "pv-rooms")]
    #[display("pv-rooms")]
    PvRooms,
    #[serde(rename = "pv-sip-endpoint-registrations")]
    #[display("pv-sip-endpoint-registrations")]
    PvSipEndpointRegistrations,
    #[serde(rename = "recordings")]
    #[display("recordings")]
    Recordings,
    #[serde(rename = "recordingstorage")]
    #[display("recordingstorage")]
    Recordingstorage,
    #[serde(rename = "rooms-group-bandwidth")]
    #[display("rooms-group-bandwidth")]
    RoomsGroupBandwidth,
    #[serde(rename = "rooms-group-minutes")]
    #[display("rooms-group-minutes")]
    RoomsGroupMinutes,
    #[serde(rename = "rooms-peer-to-peer-minutes")]
    #[display("rooms-peer-to-peer-minutes")]
    RoomsPeerToPeerMinutes,
    #[serde(rename = "shortcodes")]
    #[display("shortcodes")]
    Shortcodes,
    #[serde(rename = "shortcodes-customerowned")]
    #[display("shortcodes-customerowned")]
    ShortcodesCustomerowned,
    #[serde(rename = "shortcodes-mms-enablement")]
    #[display("shortcodes-mms-enablement")]
    ShortcodesMmsEnablement,
    #[serde(rename = "shortcodes-mps")]
    #[display("shortcodes-mps")]
    ShortcodesMps,
    #[serde(rename = "shortcodes-random")]
    #[display("shortcodes-random")]
    ShortcodesRandom,
    #[serde(rename = "shortcodes-uk")]
    #[display("shortcodes-uk")]
    ShortcodesUk,
    #[serde(rename = "shortcodes-vanity")]
    #[display("shortcodes-vanity")]
    ShortcodesVanity,
    #[serde(rename = "small-group-rooms")]
    #[display("small-group-rooms")]
    SmallGroupRooms,
    #[serde(rename = "small-group-rooms-data-track")]
    #[display("small-group-rooms-data-track")]
    SmallGroupRoomsDataTrack,
    #[serde(rename = "small-group-rooms-participant-minutes")]
    #[display("small-group-rooms-participant-minutes")]
    SmallGroupRoomsParticipantMinutes,
    #[serde(rename = "sms")]
    #[display("sms")]
    Sms,
    #[serde(rename = "sms-inbound")]
    #[display("sms-inbound")]
    SmsInbound,
    #[serde(rename = "sms-inbound-longcode")]
    #[display("sms-inbound-longcode")]
    SmsInboundLongcode,
    #[serde(rename = "sms-inbound-shortcode")]
    #[display("sms-inbound-shortcode")]
    SmsInboundShortcode,
    #[serde(rename = "sms-messages-carrierfees")]
    #[display("sms-messages-carrierfees")]
    SmsMessagesCarrierfees,
    #[serde(rename = "sms-messages-features")]
    #[display("sms-messages-features")]
    SmsMessagesFeatures,
    #[serde(rename = "sms-messages-features-senderid")]
    #[display("sms-messages-features-senderid")]
    SmsMessagesFeaturesSenderid,
    #[serde(rename = "sms-outbound")]
    #[display("sms-outbound")]
    SmsOutbound,
    #[serde(rename = "sms-outbound-content-inspection")]
    #[display("sms-outbound-content-inspection")]
    SmsOutboundContentInspection,
    #[serde(rename = "sms-outbound-longcode")]
    #[display("sms-outbound-longcode")]
    SmsOutboundLongcode,
    #[serde(rename = "sms-outbound-shortcode")]
    #[display("sms-outbound-shortcode")]
    SmsOutboundShortcode,
    #[serde(rename = "speech-recognition")]
    #[display("speech-recognition")]
    SpeechRecognition,
    #[serde(rename = "studio-engagements")]
    #[display("studio-engagements")]
    StudioEngagements,
    #[serde(rename = "sync")]
    #[display("sync")]
    Sync,
    #[serde(rename = "sync-actions")]
    #[display("sync-actions")]
    SyncActions,
    #[serde(rename = "sync-endpoint-hours")]
    #[display("sync-endpoint-hours")]
    SyncEndpointHours,
    #[serde(rename = "sync-endpoint-hours-above-daily-cap")]
    #[display("sync-endpoint-hours-above-daily-cap")]
    SyncEndpointHoursAboveDailyCap,
    #[serde(rename = "taskrouter-tasks")]
    #[display("taskrouter-tasks")]
    TaskrouterTasks,
    #[serde(rename = "totalprice")]
    #[display("totalprice")]
    Totalprice,
    #[serde(rename = "transcriptions")]
    #[display("transcriptions")]
    Transcriptions,
    #[serde(rename = "trunking-cps")]
    #[display("trunking-cps")]
    TrunkingCps,
    #[serde(rename = "trunking-emergency-calls")]
    #[display("trunking-emergency-calls")]
    TrunkingEmergencyCalls,
    #[serde(rename = "trunking-origination")]
    #[display("trunking-origination")]
    TrunkingOrigination,
    #[serde(rename = "trunking-origination-local")]
    #[display("trunking-origination-local")]
    TrunkingOriginationLocal,
    #[serde(rename = "trunking-origination-mobile")]
    #[display("trunking-origination-mobile")]
    TrunkingOriginationMobile,
    #[serde(rename = "trunking-origination-tollfree")]
    #[display("trunking-origination-tollfree")]
    TrunkingOriginationTollfree,
    #[serde(rename = "trunking-recordings")]
    #[display("trunking-recordings")]
    TrunkingRecordings,
    #[serde(rename = "trunking-secure")]
    #[display("trunking-secure")]
    TrunkingSecure,
    #[serde(rename = "trunking-termination")]
    #[display("trunking-termination")]
    TrunkingTermination,
    #[serde(rename = "turnmegabytes")]
    #[display("turnmegabytes")]
    Turnmegabytes,
    #[serde(rename = "turnmegabytes-australia")]
    #[display("turnmegabytes-australia")]
    TurnmegabytesAustralia,
    #[serde(rename = "turnmegabytes-brasil")]
    #[display("turnmegabytes-brasil")]
    TurnmegabytesBrasil,
    #[serde(rename = "turnmegabytes-germany")]
    #[display("turnmegabytes-germany")]
    TurnmegabytesGermany,
    #[serde(rename = "turnmegabytes-india")]
    #[display("turnmegabytes-india")]
    TurnmegabytesIndia,
    #[serde(rename = "turnmegabytes-ireland")]
    #[display("turnmegabytes-ireland")]
    TurnmegabytesIreland,
    #[serde(rename = "turnmegabytes-japan")]
    #[display("turnmegabytes-japan")]
    TurnmegabytesJapan,
    #[serde(rename = "turnmegabytes-singapore")]
    #[display("turnmegabytes-singapore")]
    TurnmegabytesSingapore,
    #[serde(rename = "turnmegabytes-useast")]
    #[display("turnmegabytes-useast")]
    TurnmegabytesUseast,
    #[serde(rename = "turnmegabytes-uswest")]
    #[display("turnmegabytes-uswest")]
    TurnmegabytesUswest,
    #[serde(rename = "twilio-interconnect")]
    #[display("twilio-interconnect")]
    TwilioInterconnect,
    #[serde(rename = "verify-push")]
    #[display("verify-push")]
    VerifyPush,
    #[serde(rename = "verify-totp")]
    #[display("verify-totp")]
    VerifyTotp,
    #[serde(rename = "verify-whatsapp-conversations-business-initiated")]
    #[display("verify-whatsapp-conversations-business-initiated")]
    VerifyWhatsappConversationsBusinessInitiated,
    #[serde(rename = "video-recordings")]
    #[display("video-recordings")]
    VideoRecordings,
    #[serde(rename = "virtual-agent")]
    #[display("virtual-agent")]
    VirtualAgent,
    #[serde(rename = "voice-insights")]
    #[display("voice-insights")]
    VoiceInsights,
    #[serde(rename = "voice-insights-client-insights-on-demand-minute")]
    #[display("voice-insights-client-insights-on-demand-minute")]
    VoiceInsightsClientInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-ptsn-insights-on-demand-minute")]
    #[display("voice-insights-ptsn-insights-on-demand-minute")]
    VoiceInsightsPtsnInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-interface-insights-on-demand-minute")]
    #[display("voice-insights-sip-interface-insights-on-demand-minute")]
    VoiceInsightsSipInterfaceInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-trunking-insights-on-demand-minute")]
    #[display("voice-insights-sip-trunking-insights-on-demand-minute")]
    VoiceInsightsSipTrunkingInsightsOnDemandMinute,
    #[serde(rename = "wireless")]
    #[display("wireless")]
    Wireless,
    #[serde(rename = "wireless-orders")]
    #[display("wireless-orders")]
    WirelessOrders,
    #[serde(rename = "wireless-orders-artwork")]
    #[display("wireless-orders-artwork")]
    WirelessOrdersArtwork,
    #[serde(rename = "wireless-orders-bulk")]
    #[display("wireless-orders-bulk")]
    WirelessOrdersBulk,
    #[serde(rename = "wireless-orders-esim")]
    #[display("wireless-orders-esim")]
    WirelessOrdersEsim,
    #[serde(rename = "wireless-orders-starter")]
    #[display("wireless-orders-starter")]
    WirelessOrdersStarter,
    #[serde(rename = "wireless-usage")]
    #[display("wireless-usage")]
    WirelessUsage,
    #[serde(rename = "wireless-usage-commands")]
    #[display("wireless-usage-commands")]
    WirelessUsageCommands,
    #[serde(rename = "wireless-usage-commands-africa")]
    #[display("wireless-usage-commands-africa")]
    WirelessUsageCommandsAfrica,
    #[serde(rename = "wireless-usage-commands-asia")]
    #[display("wireless-usage-commands-asia")]
    WirelessUsageCommandsAsia,
    #[serde(rename = "wireless-usage-commands-centralandsouthamerica")]
    #[display("wireless-usage-commands-centralandsouthamerica")]
    WirelessUsageCommandsCentralandsouthamerica,
    #[serde(rename = "wireless-usage-commands-europe")]
    #[display("wireless-usage-commands-europe")]
    WirelessUsageCommandsEurope,
    #[serde(rename = "wireless-usage-commands-home")]
    #[display("wireless-usage-commands-home")]
    WirelessUsageCommandsHome,
    #[serde(rename = "wireless-usage-commands-northamerica")]
    #[display("wireless-usage-commands-northamerica")]
    WirelessUsageCommandsNorthamerica,
    #[serde(rename = "wireless-usage-commands-oceania")]
    #[display("wireless-usage-commands-oceania")]
    WirelessUsageCommandsOceania,
    #[serde(rename = "wireless-usage-commands-roaming")]
    #[display("wireless-usage-commands-roaming")]
    WirelessUsageCommandsRoaming,
    #[serde(rename = "wireless-usage-data")]
    #[display("wireless-usage-data")]
    WirelessUsageData,
    #[serde(rename = "wireless-usage-data-africa")]
    #[display("wireless-usage-data-africa")]
    WirelessUsageDataAfrica,
    #[serde(rename = "wireless-usage-data-asia")]
    #[display("wireless-usage-data-asia")]
    WirelessUsageDataAsia,
    #[serde(rename = "wireless-usage-data-centralandsouthamerica")]
    #[display("wireless-usage-data-centralandsouthamerica")]
    WirelessUsageDataCentralandsouthamerica,
    #[serde(rename = "wireless-usage-data-custom-additionalmb")]
    #[display("wireless-usage-data-custom-additionalmb")]
    WirelessUsageDataCustomAdditionalmb,
    #[serde(rename = "wireless-usage-data-custom-first5mb")]
    #[display("wireless-usage-data-custom-first5mb")]
    WirelessUsageDataCustomFirst5Mb,
    #[serde(rename = "wireless-usage-data-domestic-roaming")]
    #[display("wireless-usage-data-domestic-roaming")]
    WirelessUsageDataDomesticRoaming,
    #[serde(rename = "wireless-usage-data-europe")]
    #[display("wireless-usage-data-europe")]
    WirelessUsageDataEurope,
    #[serde(rename = "wireless-usage-data-individual-additionalgb")]
    #[display("wireless-usage-data-individual-additionalgb")]
    WirelessUsageDataIndividualAdditionalgb,
    #[serde(rename = "wireless-usage-data-individual-firstgb")]
    #[display("wireless-usage-data-individual-firstgb")]
    WirelessUsageDataIndividualFirstgb,
    #[serde(rename = "wireless-usage-data-international-roaming-canada")]
    #[display("wireless-usage-data-international-roaming-canada")]
    WirelessUsageDataInternationalRoamingCanada,
    #[serde(rename = "wireless-usage-data-international-roaming-india")]
    #[display("wireless-usage-data-international-roaming-india")]
    WirelessUsageDataInternationalRoamingIndia,
    #[serde(rename = "wireless-usage-data-international-roaming-mexico")]
    #[display("wireless-usage-data-international-roaming-mexico")]
    WirelessUsageDataInternationalRoamingMexico,
    #[serde(rename = "wireless-usage-data-northamerica")]
    #[display("wireless-usage-data-northamerica")]
    WirelessUsageDataNorthamerica,
    #[serde(rename = "wireless-usage-data-oceania")]
    #[display("wireless-usage-data-oceania")]
    WirelessUsageDataOceania,
    #[serde(rename = "wireless-usage-data-pooled")]
    #[display("wireless-usage-data-pooled")]
    WirelessUsageDataPooled,
    #[serde(rename = "wireless-usage-data-pooled-downlink")]
    #[display("wireless-usage-data-pooled-downlink")]
    WirelessUsageDataPooledDownlink,
    #[serde(rename = "wireless-usage-data-pooled-uplink")]
    #[display("wireless-usage-data-pooled-uplink")]
    WirelessUsageDataPooledUplink,
    #[serde(rename = "wireless-usage-mrc")]
    #[display("wireless-usage-mrc")]
    WirelessUsageMrc,
    #[serde(rename = "wireless-usage-mrc-custom")]
    #[display("wireless-usage-mrc-custom")]
    WirelessUsageMrcCustom,
    #[serde(rename = "wireless-usage-mrc-individual")]
    #[display("wireless-usage-mrc-individual")]
    WirelessUsageMrcIndividual,
    #[serde(rename = "wireless-usage-mrc-pooled")]
    #[display("wireless-usage-mrc-pooled")]
    WirelessUsageMrcPooled,
    #[serde(rename = "wireless-usage-mrc-suspended")]
    #[display("wireless-usage-mrc-suspended")]
    WirelessUsageMrcSuspended,
    #[serde(rename = "wireless-usage-sms")]
    #[display("wireless-usage-sms")]
    WirelessUsageSms,
    #[serde(rename = "wireless-usage-voice")]
    #[display("wireless-usage-voice")]
    WirelessUsageVoice,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountUsageUsageRecordUsageRecordToday {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that accrued \
             the usage."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to create the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "Usage records up to date as of this timestamp, formatted as \
             YYYY-MM-DDTHH:MM:SS+00:00. All timestamps are in GMT"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub as_of: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub category: Option<UsageRecordTodayEnumCategory>,
    #[doc = "The number of usage events, such as the number of calls."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<String>,
    #[doc = "The units in which `count` is measured, such as `calls` for calls or `messages` for \
             SMS."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count_unit: Option<String>,
    #[doc = "A plain-language description of the usage category."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "The last date for which usage is included in the UsageRecord. The date is specified \
             in GMT and formatted as `YYYY-MM-DD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_date: Option<chrono::NaiveDate>,
    #[doc = "The total price of the usage in the currency specified in `price_unit` and \
             associated with the account."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<f64>,
    #[doc = "The currency in which `price` is measured, in [ISO 4127](https://www.iso.org/iso/home/standards/currency_codes.htm) format, such as `usd`, `eur`, and `jpy`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price_unit: Option<String>,
    #[doc = "The first date for which usage is included in this UsageRecord. The date is \
             specified in GMT and formatted as `YYYY-MM-DD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_date: Option<chrono::NaiveDate>,
    #[doc = "A list of related resources identified by their URIs. For more information, see [List Subresources](https://www.twilio.com/docs/usage/api/usage-record#list-subresources)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "The amount used to bill usage and measured in units described in `usage_unit`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage: Option<String>,
    #[doc = "The units in which `usage` is measured, such as `minutes` for calls or `messages` \
             for SMS."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_unit: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountUsageUsageRecordUsageRecordToday {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountUsageUsageRecordUsageRecordToday {
    const LENGTH: usize = 15;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(as_of) = &self.as_of {
                format!("{as_of:?}")
            } else {
                String::new()
            },
            if let Some(category) = &self.category {
                format!("{category:?}")
            } else {
                String::new()
            },
            if let Some(count) = &self.count {
                format!("{count:?}")
            } else {
                String::new()
            },
            if let Some(count_unit) = &self.count_unit {
                format!("{count_unit:?}")
            } else {
                String::new()
            },
            if let Some(description) = &self.description {
                format!("{description:?}")
            } else {
                String::new()
            },
            if let Some(end_date) = &self.end_date {
                format!("{end_date:?}")
            } else {
                String::new()
            },
            if let Some(price) = &self.price {
                format!("{price:?}")
            } else {
                String::new()
            },
            if let Some(price_unit) = &self.price_unit {
                format!("{price_unit:?}")
            } else {
                String::new()
            },
            if let Some(start_date) = &self.start_date {
                format!("{start_date:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(usage) = &self.usage {
                format!("{usage:?}")
            } else {
                String::new()
            },
            if let Some(usage_unit) = &self.usage_unit {
                format!("{usage_unit:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "as_of".to_string(),
            "category".to_string(),
            "count".to_string(),
            "count_unit".to_string(),
            "description".to_string(),
            "end_date".to_string(),
            "price".to_string(),
            "price_unit".to_string(),
            "start_date".to_string(),
            "subresource_uris".to_string(),
            "uri".to_string(),
            "usage".to_string(),
            "usage_unit".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UsageRecordTodayEnumCategory {
    #[serde(rename = "a2p-registration-fees")]
    #[display("a2p-registration-fees")]
    A2PRegistrationFees,
    #[serde(rename = "agent-conference")]
    #[display("agent-conference")]
    AgentConference,
    #[serde(rename = "amazon-polly")]
    #[display("amazon-polly")]
    AmazonPolly,
    #[serde(rename = "answering-machine-detection")]
    #[display("answering-machine-detection")]
    AnsweringMachineDetection,
    #[serde(rename = "authy-authentications")]
    #[display("authy-authentications")]
    AuthyAuthentications,
    #[serde(rename = "authy-calls-outbound")]
    #[display("authy-calls-outbound")]
    AuthyCallsOutbound,
    #[serde(rename = "authy-monthly-fees")]
    #[display("authy-monthly-fees")]
    AuthyMonthlyFees,
    #[serde(rename = "authy-phone-intelligence")]
    #[display("authy-phone-intelligence")]
    AuthyPhoneIntelligence,
    #[serde(rename = "authy-phone-verifications")]
    #[display("authy-phone-verifications")]
    AuthyPhoneVerifications,
    #[serde(rename = "authy-sms-outbound")]
    #[display("authy-sms-outbound")]
    AuthySmsOutbound,
    #[serde(rename = "call-progess-events")]
    #[display("call-progess-events")]
    CallProgessEvents,
    #[serde(rename = "calleridlookups")]
    #[display("calleridlookups")]
    Calleridlookups,
    #[serde(rename = "calls")]
    #[display("calls")]
    Calls,
    #[serde(rename = "calls-client")]
    #[display("calls-client")]
    CallsClient,
    #[serde(rename = "calls-globalconference")]
    #[display("calls-globalconference")]
    CallsGlobalconference,
    #[serde(rename = "calls-inbound")]
    #[display("calls-inbound")]
    CallsInbound,
    #[serde(rename = "calls-inbound-local")]
    #[display("calls-inbound-local")]
    CallsInboundLocal,
    #[serde(rename = "calls-inbound-mobile")]
    #[display("calls-inbound-mobile")]
    CallsInboundMobile,
    #[serde(rename = "calls-inbound-tollfree")]
    #[display("calls-inbound-tollfree")]
    CallsInboundTollfree,
    #[serde(rename = "calls-outbound")]
    #[display("calls-outbound")]
    CallsOutbound,
    #[serde(rename = "calls-pay-verb-transactions")]
    #[display("calls-pay-verb-transactions")]
    CallsPayVerbTransactions,
    #[serde(rename = "calls-recordings")]
    #[display("calls-recordings")]
    CallsRecordings,
    #[serde(rename = "calls-sip")]
    #[display("calls-sip")]
    CallsSip,
    #[serde(rename = "calls-sip-inbound")]
    #[display("calls-sip-inbound")]
    CallsSipInbound,
    #[serde(rename = "calls-sip-outbound")]
    #[display("calls-sip-outbound")]
    CallsSipOutbound,
    #[serde(rename = "calls-transfers")]
    #[display("calls-transfers")]
    CallsTransfers,
    #[serde(rename = "carrier-lookups")]
    #[display("carrier-lookups")]
    CarrierLookups,
    #[serde(rename = "conversations")]
    #[display("conversations")]
    Conversations,
    #[serde(rename = "conversations-api-requests")]
    #[display("conversations-api-requests")]
    ConversationsApiRequests,
    #[serde(rename = "conversations-conversation-events")]
    #[display("conversations-conversation-events")]
    ConversationsConversationEvents,
    #[serde(rename = "conversations-endpoint-connectivity")]
    #[display("conversations-endpoint-connectivity")]
    ConversationsEndpointConnectivity,
    #[serde(rename = "conversations-events")]
    #[display("conversations-events")]
    ConversationsEvents,
    #[serde(rename = "conversations-participant-events")]
    #[display("conversations-participant-events")]
    ConversationsParticipantEvents,
    #[serde(rename = "conversations-participants")]
    #[display("conversations-participants")]
    ConversationsParticipants,
    #[serde(rename = "cps")]
    #[display("cps")]
    Cps,
    #[serde(rename = "flex-usage")]
    #[display("flex-usage")]
    FlexUsage,
    #[serde(rename = "fraud-lookups")]
    #[display("fraud-lookups")]
    FraudLookups,
    #[serde(rename = "group-rooms")]
    #[display("group-rooms")]
    GroupRooms,
    #[serde(rename = "group-rooms-data-track")]
    #[display("group-rooms-data-track")]
    GroupRoomsDataTrack,
    #[serde(rename = "group-rooms-encrypted-media-recorded")]
    #[display("group-rooms-encrypted-media-recorded")]
    GroupRoomsEncryptedMediaRecorded,
    #[serde(rename = "group-rooms-media-downloaded")]
    #[display("group-rooms-media-downloaded")]
    GroupRoomsMediaDownloaded,
    #[serde(rename = "group-rooms-media-recorded")]
    #[display("group-rooms-media-recorded")]
    GroupRoomsMediaRecorded,
    #[serde(rename = "group-rooms-media-routed")]
    #[display("group-rooms-media-routed")]
    GroupRoomsMediaRouted,
    #[serde(rename = "group-rooms-media-stored")]
    #[display("group-rooms-media-stored")]
    GroupRoomsMediaStored,
    #[serde(rename = "group-rooms-participant-minutes")]
    #[display("group-rooms-participant-minutes")]
    GroupRoomsParticipantMinutes,
    #[serde(rename = "group-rooms-recorded-minutes")]
    #[display("group-rooms-recorded-minutes")]
    GroupRoomsRecordedMinutes,
    #[serde(rename = "imp-v1-usage")]
    #[display("imp-v1-usage")]
    ImpUsage,
    #[serde(rename = "lookups")]
    #[display("lookups")]
    Lookups,
    #[serde(rename = "marketplace")]
    #[display("marketplace")]
    Marketplace,
    #[serde(rename = "marketplace-algorithmia-named-entity-recognition")]
    #[display("marketplace-algorithmia-named-entity-recognition")]
    MarketplaceAlgorithmiaNamedEntityRecognition,
    #[serde(rename = "marketplace-cadence-transcription")]
    #[display("marketplace-cadence-transcription")]
    MarketplaceCadenceTranscription,
    #[serde(rename = "marketplace-cadence-translation")]
    #[display("marketplace-cadence-translation")]
    MarketplaceCadenceTranslation,
    #[serde(rename = "marketplace-capio-speech-to-text")]
    #[display("marketplace-capio-speech-to-text")]
    MarketplaceCapioSpeechToText,
    #[serde(rename = "marketplace-convriza-ababa")]
    #[display("marketplace-convriza-ababa")]
    MarketplaceConvrizaAbaba,
    #[serde(rename = "marketplace-deepgram-phrase-detector")]
    #[display("marketplace-deepgram-phrase-detector")]
    MarketplaceDeepgramPhraseDetector,
    #[serde(rename = "marketplace-digital-segment-business-info")]
    #[display("marketplace-digital-segment-business-info")]
    MarketplaceDigitalSegmentBusinessInfo,
    #[serde(rename = "marketplace-facebook-offline-conversions")]
    #[display("marketplace-facebook-offline-conversions")]
    MarketplaceFacebookOfflineConversions,
    #[serde(rename = "marketplace-google-speech-to-text")]
    #[display("marketplace-google-speech-to-text")]
    MarketplaceGoogleSpeechToText,
    #[serde(rename = "marketplace-ibm-watson-message-insights")]
    #[display("marketplace-ibm-watson-message-insights")]
    MarketplaceIbmWatsonMessageInsights,
    #[serde(rename = "marketplace-ibm-watson-message-sentiment")]
    #[display("marketplace-ibm-watson-message-sentiment")]
    MarketplaceIbmWatsonMessageSentiment,
    #[serde(rename = "marketplace-ibm-watson-recording-analysis")]
    #[display("marketplace-ibm-watson-recording-analysis")]
    MarketplaceIbmWatsonRecordingAnalysis,
    #[serde(rename = "marketplace-ibm-watson-tone-analyzer")]
    #[display("marketplace-ibm-watson-tone-analyzer")]
    MarketplaceIbmWatsonToneAnalyzer,
    #[serde(rename = "marketplace-icehook-systems-scout")]
    #[display("marketplace-icehook-systems-scout")]
    MarketplaceIcehookSystemsScout,
    #[serde(rename = "marketplace-infogroup-dataaxle-bizinfo")]
    #[display("marketplace-infogroup-dataaxle-bizinfo")]
    MarketplaceInfogroupDataaxleBizinfo,
    #[serde(rename = "marketplace-keen-io-contact-center-analytics")]
    #[display("marketplace-keen-io-contact-center-analytics")]
    MarketplaceKeenIoContactCenterAnalytics,
    #[serde(rename = "marketplace-marchex-cleancall")]
    #[display("marketplace-marchex-cleancall")]
    MarketplaceMarchexCleancall,
    #[serde(rename = "marketplace-marchex-sentiment-analysis-for-sms")]
    #[display("marketplace-marchex-sentiment-analysis-for-sms")]
    MarketplaceMarchexSentimentAnalysisForSms,
    #[serde(rename = "marketplace-marketplace-nextcaller-social-id")]
    #[display("marketplace-marketplace-nextcaller-social-id")]
    MarketplaceMarketplaceNextcallerSocialId,
    #[serde(rename = "marketplace-mobile-commons-opt-out-classifier")]
    #[display("marketplace-mobile-commons-opt-out-classifier")]
    MarketplaceMobileCommonsOptOutClassifier,
    #[serde(rename = "marketplace-nexiwave-voicemail-to-text")]
    #[display("marketplace-nexiwave-voicemail-to-text")]
    MarketplaceNexiwaveVoicemailToText,
    #[serde(rename = "marketplace-nextcaller-advanced-caller-identification")]
    #[display("marketplace-nextcaller-advanced-caller-identification")]
    MarketplaceNextcallerAdvancedCallerIdentification,
    #[serde(rename = "marketplace-nomorobo-spam-score")]
    #[display("marketplace-nomorobo-spam-score")]
    MarketplaceNomoroboSpamScore,
    #[serde(rename = "marketplace-payfone-tcpa-compliance")]
    #[display("marketplace-payfone-tcpa-compliance")]
    MarketplacePayfoneTcpaCompliance,
    #[serde(rename = "marketplace-remeeting-automatic-speech-recognition")]
    #[display("marketplace-remeeting-automatic-speech-recognition")]
    MarketplaceRemeetingAutomaticSpeechRecognition,
    #[serde(rename = "marketplace-tcpa-defense-solutions-blacklist-feed")]
    #[display("marketplace-tcpa-defense-solutions-blacklist-feed")]
    MarketplaceTcpaDefenseSolutionsBlacklistFeed,
    #[serde(rename = "marketplace-telo-opencnam")]
    #[display("marketplace-telo-opencnam")]
    MarketplaceTeloOpencnam,
    #[serde(rename = "marketplace-truecnam-true-spam")]
    #[display("marketplace-truecnam-true-spam")]
    MarketplaceTruecnamTrueSpam,
    #[serde(rename = "marketplace-twilio-caller-name-lookup-us")]
    #[display("marketplace-twilio-caller-name-lookup-us")]
    MarketplaceTwilioCallerNameLookupUs,
    #[serde(rename = "marketplace-twilio-carrier-information-lookup")]
    #[display("marketplace-twilio-carrier-information-lookup")]
    MarketplaceTwilioCarrierInformationLookup,
    #[serde(rename = "marketplace-voicebase-pci")]
    #[display("marketplace-voicebase-pci")]
    MarketplaceVoicebasePci,
    #[serde(rename = "marketplace-voicebase-transcription")]
    #[display("marketplace-voicebase-transcription")]
    MarketplaceVoicebaseTranscription,
    #[serde(rename = "marketplace-voicebase-transcription-custom-vocabulary")]
    #[display("marketplace-voicebase-transcription-custom-vocabulary")]
    MarketplaceVoicebaseTranscriptionCustomVocabulary,
    #[serde(rename = "marketplace-whitepages-pro-caller-identification")]
    #[display("marketplace-whitepages-pro-caller-identification")]
    MarketplaceWhitepagesProCallerIdentification,
    #[serde(rename = "marketplace-whitepages-pro-phone-intelligence")]
    #[display("marketplace-whitepages-pro-phone-intelligence")]
    MarketplaceWhitepagesProPhoneIntelligence,
    #[serde(rename = "marketplace-whitepages-pro-phone-reputation")]
    #[display("marketplace-whitepages-pro-phone-reputation")]
    MarketplaceWhitepagesProPhoneReputation,
    #[serde(rename = "marketplace-wolfarm-spoken-results")]
    #[display("marketplace-wolfarm-spoken-results")]
    MarketplaceWolfarmSpokenResults,
    #[serde(rename = "marketplace-wolfram-short-answer")]
    #[display("marketplace-wolfram-short-answer")]
    MarketplaceWolframShortAnswer,
    #[serde(rename = "marketplace-ytica-contact-center-reporting-analytics")]
    #[display("marketplace-ytica-contact-center-reporting-analytics")]
    MarketplaceYticaContactCenterReportingAnalytics,
    #[serde(rename = "mediastorage")]
    #[display("mediastorage")]
    Mediastorage,
    #[serde(rename = "mms")]
    #[display("mms")]
    Mms,
    #[serde(rename = "mms-inbound")]
    #[display("mms-inbound")]
    MmsInbound,
    #[serde(rename = "mms-inbound-longcode")]
    #[display("mms-inbound-longcode")]
    MmsInboundLongcode,
    #[serde(rename = "mms-inbound-shortcode")]
    #[display("mms-inbound-shortcode")]
    MmsInboundShortcode,
    #[serde(rename = "mms-messages-carrierfees")]
    #[display("mms-messages-carrierfees")]
    MmsMessagesCarrierfees,
    #[serde(rename = "mms-outbound")]
    #[display("mms-outbound")]
    MmsOutbound,
    #[serde(rename = "mms-outbound-longcode")]
    #[display("mms-outbound-longcode")]
    MmsOutboundLongcode,
    #[serde(rename = "mms-outbound-shortcode")]
    #[display("mms-outbound-shortcode")]
    MmsOutboundShortcode,
    #[serde(rename = "monitor-reads")]
    #[display("monitor-reads")]
    MonitorReads,
    #[serde(rename = "monitor-storage")]
    #[display("monitor-storage")]
    MonitorStorage,
    #[serde(rename = "monitor-writes")]
    #[display("monitor-writes")]
    MonitorWrites,
    #[serde(rename = "notify")]
    #[display("notify")]
    Notify,
    #[serde(rename = "notify-actions-attempts")]
    #[display("notify-actions-attempts")]
    NotifyActionsAttempts,
    #[serde(rename = "notify-channels")]
    #[display("notify-channels")]
    NotifyChannels,
    #[serde(rename = "number-format-lookups")]
    #[display("number-format-lookups")]
    NumberFormatLookups,
    #[serde(rename = "pchat")]
    #[display("pchat")]
    Pchat,
    #[serde(rename = "pchat-users")]
    #[display("pchat-users")]
    PchatUsers,
    #[serde(rename = "peer-to-peer-rooms-participant-minutes")]
    #[display("peer-to-peer-rooms-participant-minutes")]
    PeerToPeerRoomsParticipantMinutes,
    #[serde(rename = "pfax")]
    #[display("pfax")]
    Pfax,
    #[serde(rename = "pfax-minutes")]
    #[display("pfax-minutes")]
    PfaxMinutes,
    #[serde(rename = "pfax-minutes-inbound")]
    #[display("pfax-minutes-inbound")]
    PfaxMinutesInbound,
    #[serde(rename = "pfax-minutes-outbound")]
    #[display("pfax-minutes-outbound")]
    PfaxMinutesOutbound,
    #[serde(rename = "pfax-pages")]
    #[display("pfax-pages")]
    PfaxPages,
    #[serde(rename = "phonenumbers")]
    #[display("phonenumbers")]
    Phonenumbers,
    #[serde(rename = "phonenumbers-cps")]
    #[display("phonenumbers-cps")]
    PhonenumbersCps,
    #[serde(rename = "phonenumbers-emergency")]
    #[display("phonenumbers-emergency")]
    PhonenumbersEmergency,
    #[serde(rename = "phonenumbers-local")]
    #[display("phonenumbers-local")]
    PhonenumbersLocal,
    #[serde(rename = "phonenumbers-mobile")]
    #[display("phonenumbers-mobile")]
    PhonenumbersMobile,
    #[serde(rename = "phonenumbers-setups")]
    #[display("phonenumbers-setups")]
    PhonenumbersSetups,
    #[serde(rename = "phonenumbers-tollfree")]
    #[display("phonenumbers-tollfree")]
    PhonenumbersTollfree,
    #[serde(rename = "premiumsupport")]
    #[display("premiumsupport")]
    Premiumsupport,
    #[serde(rename = "proxy")]
    #[display("proxy")]
    Proxy,
    #[serde(rename = "proxy-active-sessions")]
    #[display("proxy-active-sessions")]
    ProxyActiveSessions,
    #[serde(rename = "pstnconnectivity")]
    #[display("pstnconnectivity")]
    Pstnconnectivity,
    #[serde(rename = "pv")]
    #[display("pv")]
    Pv,
    #[serde(rename = "pv-composition-media-downloaded")]
    #[display("pv-composition-media-downloaded")]
    PvCompositionMediaDownloaded,
    #[serde(rename = "pv-composition-media-encrypted")]
    #[display("pv-composition-media-encrypted")]
    PvCompositionMediaEncrypted,
    #[serde(rename = "pv-composition-media-stored")]
    #[display("pv-composition-media-stored")]
    PvCompositionMediaStored,
    #[serde(rename = "pv-composition-minutes")]
    #[display("pv-composition-minutes")]
    PvCompositionMinutes,
    #[serde(rename = "pv-recording-compositions")]
    #[display("pv-recording-compositions")]
    PvRecordingCompositions,
    #[serde(rename = "pv-room-participants")]
    #[display("pv-room-participants")]
    PvRoomParticipants,
    #[serde(rename = "pv-room-participants-au1")]
    #[display("pv-room-participants-au1")]
    PvRoomParticipantsAu1,
    #[serde(rename = "pv-room-participants-br1")]
    #[display("pv-room-participants-br1")]
    PvRoomParticipantsBr1,
    #[serde(rename = "pv-room-participants-ie1")]
    #[display("pv-room-participants-ie1")]
    PvRoomParticipantsIe1,
    #[serde(rename = "pv-room-participants-jp1")]
    #[display("pv-room-participants-jp1")]
    PvRoomParticipantsJp1,
    #[serde(rename = "pv-room-participants-sg1")]
    #[display("pv-room-participants-sg1")]
    PvRoomParticipantsSg1,
    #[serde(rename = "pv-room-participants-us1")]
    #[display("pv-room-participants-us1")]
    PvRoomParticipantsUs1,
    #[serde(rename = "pv-room-participants-us2")]
    #[display("pv-room-participants-us2")]
    PvRoomParticipantsUs2,
    #[serde(rename = "pv-rooms")]
    #[display("pv-rooms")]
    PvRooms,
    #[serde(rename = "pv-sip-endpoint-registrations")]
    #[display("pv-sip-endpoint-registrations")]
    PvSipEndpointRegistrations,
    #[serde(rename = "recordings")]
    #[display("recordings")]
    Recordings,
    #[serde(rename = "recordingstorage")]
    #[display("recordingstorage")]
    Recordingstorage,
    #[serde(rename = "rooms-group-bandwidth")]
    #[display("rooms-group-bandwidth")]
    RoomsGroupBandwidth,
    #[serde(rename = "rooms-group-minutes")]
    #[display("rooms-group-minutes")]
    RoomsGroupMinutes,
    #[serde(rename = "rooms-peer-to-peer-minutes")]
    #[display("rooms-peer-to-peer-minutes")]
    RoomsPeerToPeerMinutes,
    #[serde(rename = "shortcodes")]
    #[display("shortcodes")]
    Shortcodes,
    #[serde(rename = "shortcodes-customerowned")]
    #[display("shortcodes-customerowned")]
    ShortcodesCustomerowned,
    #[serde(rename = "shortcodes-mms-enablement")]
    #[display("shortcodes-mms-enablement")]
    ShortcodesMmsEnablement,
    #[serde(rename = "shortcodes-mps")]
    #[display("shortcodes-mps")]
    ShortcodesMps,
    #[serde(rename = "shortcodes-random")]
    #[display("shortcodes-random")]
    ShortcodesRandom,
    #[serde(rename = "shortcodes-uk")]
    #[display("shortcodes-uk")]
    ShortcodesUk,
    #[serde(rename = "shortcodes-vanity")]
    #[display("shortcodes-vanity")]
    ShortcodesVanity,
    #[serde(rename = "small-group-rooms")]
    #[display("small-group-rooms")]
    SmallGroupRooms,
    #[serde(rename = "small-group-rooms-data-track")]
    #[display("small-group-rooms-data-track")]
    SmallGroupRoomsDataTrack,
    #[serde(rename = "small-group-rooms-participant-minutes")]
    #[display("small-group-rooms-participant-minutes")]
    SmallGroupRoomsParticipantMinutes,
    #[serde(rename = "sms")]
    #[display("sms")]
    Sms,
    #[serde(rename = "sms-inbound")]
    #[display("sms-inbound")]
    SmsInbound,
    #[serde(rename = "sms-inbound-longcode")]
    #[display("sms-inbound-longcode")]
    SmsInboundLongcode,
    #[serde(rename = "sms-inbound-shortcode")]
    #[display("sms-inbound-shortcode")]
    SmsInboundShortcode,
    #[serde(rename = "sms-messages-carrierfees")]
    #[display("sms-messages-carrierfees")]
    SmsMessagesCarrierfees,
    #[serde(rename = "sms-messages-features")]
    #[display("sms-messages-features")]
    SmsMessagesFeatures,
    #[serde(rename = "sms-messages-features-senderid")]
    #[display("sms-messages-features-senderid")]
    SmsMessagesFeaturesSenderid,
    #[serde(rename = "sms-outbound")]
    #[display("sms-outbound")]
    SmsOutbound,
    #[serde(rename = "sms-outbound-content-inspection")]
    #[display("sms-outbound-content-inspection")]
    SmsOutboundContentInspection,
    #[serde(rename = "sms-outbound-longcode")]
    #[display("sms-outbound-longcode")]
    SmsOutboundLongcode,
    #[serde(rename = "sms-outbound-shortcode")]
    #[display("sms-outbound-shortcode")]
    SmsOutboundShortcode,
    #[serde(rename = "speech-recognition")]
    #[display("speech-recognition")]
    SpeechRecognition,
    #[serde(rename = "studio-engagements")]
    #[display("studio-engagements")]
    StudioEngagements,
    #[serde(rename = "sync")]
    #[display("sync")]
    Sync,
    #[serde(rename = "sync-actions")]
    #[display("sync-actions")]
    SyncActions,
    #[serde(rename = "sync-endpoint-hours")]
    #[display("sync-endpoint-hours")]
    SyncEndpointHours,
    #[serde(rename = "sync-endpoint-hours-above-daily-cap")]
    #[display("sync-endpoint-hours-above-daily-cap")]
    SyncEndpointHoursAboveDailyCap,
    #[serde(rename = "taskrouter-tasks")]
    #[display("taskrouter-tasks")]
    TaskrouterTasks,
    #[serde(rename = "totalprice")]
    #[display("totalprice")]
    Totalprice,
    #[serde(rename = "transcriptions")]
    #[display("transcriptions")]
    Transcriptions,
    #[serde(rename = "trunking-cps")]
    #[display("trunking-cps")]
    TrunkingCps,
    #[serde(rename = "trunking-emergency-calls")]
    #[display("trunking-emergency-calls")]
    TrunkingEmergencyCalls,
    #[serde(rename = "trunking-origination")]
    #[display("trunking-origination")]
    TrunkingOrigination,
    #[serde(rename = "trunking-origination-local")]
    #[display("trunking-origination-local")]
    TrunkingOriginationLocal,
    #[serde(rename = "trunking-origination-mobile")]
    #[display("trunking-origination-mobile")]
    TrunkingOriginationMobile,
    #[serde(rename = "trunking-origination-tollfree")]
    #[display("trunking-origination-tollfree")]
    TrunkingOriginationTollfree,
    #[serde(rename = "trunking-recordings")]
    #[display("trunking-recordings")]
    TrunkingRecordings,
    #[serde(rename = "trunking-secure")]
    #[display("trunking-secure")]
    TrunkingSecure,
    #[serde(rename = "trunking-termination")]
    #[display("trunking-termination")]
    TrunkingTermination,
    #[serde(rename = "turnmegabytes")]
    #[display("turnmegabytes")]
    Turnmegabytes,
    #[serde(rename = "turnmegabytes-australia")]
    #[display("turnmegabytes-australia")]
    TurnmegabytesAustralia,
    #[serde(rename = "turnmegabytes-brasil")]
    #[display("turnmegabytes-brasil")]
    TurnmegabytesBrasil,
    #[serde(rename = "turnmegabytes-germany")]
    #[display("turnmegabytes-germany")]
    TurnmegabytesGermany,
    #[serde(rename = "turnmegabytes-india")]
    #[display("turnmegabytes-india")]
    TurnmegabytesIndia,
    #[serde(rename = "turnmegabytes-ireland")]
    #[display("turnmegabytes-ireland")]
    TurnmegabytesIreland,
    #[serde(rename = "turnmegabytes-japan")]
    #[display("turnmegabytes-japan")]
    TurnmegabytesJapan,
    #[serde(rename = "turnmegabytes-singapore")]
    #[display("turnmegabytes-singapore")]
    TurnmegabytesSingapore,
    #[serde(rename = "turnmegabytes-useast")]
    #[display("turnmegabytes-useast")]
    TurnmegabytesUseast,
    #[serde(rename = "turnmegabytes-uswest")]
    #[display("turnmegabytes-uswest")]
    TurnmegabytesUswest,
    #[serde(rename = "twilio-interconnect")]
    #[display("twilio-interconnect")]
    TwilioInterconnect,
    #[serde(rename = "verify-push")]
    #[display("verify-push")]
    VerifyPush,
    #[serde(rename = "verify-totp")]
    #[display("verify-totp")]
    VerifyTotp,
    #[serde(rename = "verify-whatsapp-conversations-business-initiated")]
    #[display("verify-whatsapp-conversations-business-initiated")]
    VerifyWhatsappConversationsBusinessInitiated,
    #[serde(rename = "video-recordings")]
    #[display("video-recordings")]
    VideoRecordings,
    #[serde(rename = "virtual-agent")]
    #[display("virtual-agent")]
    VirtualAgent,
    #[serde(rename = "voice-insights")]
    #[display("voice-insights")]
    VoiceInsights,
    #[serde(rename = "voice-insights-client-insights-on-demand-minute")]
    #[display("voice-insights-client-insights-on-demand-minute")]
    VoiceInsightsClientInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-ptsn-insights-on-demand-minute")]
    #[display("voice-insights-ptsn-insights-on-demand-minute")]
    VoiceInsightsPtsnInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-interface-insights-on-demand-minute")]
    #[display("voice-insights-sip-interface-insights-on-demand-minute")]
    VoiceInsightsSipInterfaceInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-trunking-insights-on-demand-minute")]
    #[display("voice-insights-sip-trunking-insights-on-demand-minute")]
    VoiceInsightsSipTrunkingInsightsOnDemandMinute,
    #[serde(rename = "wireless")]
    #[display("wireless")]
    Wireless,
    #[serde(rename = "wireless-orders")]
    #[display("wireless-orders")]
    WirelessOrders,
    #[serde(rename = "wireless-orders-artwork")]
    #[display("wireless-orders-artwork")]
    WirelessOrdersArtwork,
    #[serde(rename = "wireless-orders-bulk")]
    #[display("wireless-orders-bulk")]
    WirelessOrdersBulk,
    #[serde(rename = "wireless-orders-esim")]
    #[display("wireless-orders-esim")]
    WirelessOrdersEsim,
    #[serde(rename = "wireless-orders-starter")]
    #[display("wireless-orders-starter")]
    WirelessOrdersStarter,
    #[serde(rename = "wireless-usage")]
    #[display("wireless-usage")]
    WirelessUsage,
    #[serde(rename = "wireless-usage-commands")]
    #[display("wireless-usage-commands")]
    WirelessUsageCommands,
    #[serde(rename = "wireless-usage-commands-africa")]
    #[display("wireless-usage-commands-africa")]
    WirelessUsageCommandsAfrica,
    #[serde(rename = "wireless-usage-commands-asia")]
    #[display("wireless-usage-commands-asia")]
    WirelessUsageCommandsAsia,
    #[serde(rename = "wireless-usage-commands-centralandsouthamerica")]
    #[display("wireless-usage-commands-centralandsouthamerica")]
    WirelessUsageCommandsCentralandsouthamerica,
    #[serde(rename = "wireless-usage-commands-europe")]
    #[display("wireless-usage-commands-europe")]
    WirelessUsageCommandsEurope,
    #[serde(rename = "wireless-usage-commands-home")]
    #[display("wireless-usage-commands-home")]
    WirelessUsageCommandsHome,
    #[serde(rename = "wireless-usage-commands-northamerica")]
    #[display("wireless-usage-commands-northamerica")]
    WirelessUsageCommandsNorthamerica,
    #[serde(rename = "wireless-usage-commands-oceania")]
    #[display("wireless-usage-commands-oceania")]
    WirelessUsageCommandsOceania,
    #[serde(rename = "wireless-usage-commands-roaming")]
    #[display("wireless-usage-commands-roaming")]
    WirelessUsageCommandsRoaming,
    #[serde(rename = "wireless-usage-data")]
    #[display("wireless-usage-data")]
    WirelessUsageData,
    #[serde(rename = "wireless-usage-data-africa")]
    #[display("wireless-usage-data-africa")]
    WirelessUsageDataAfrica,
    #[serde(rename = "wireless-usage-data-asia")]
    #[display("wireless-usage-data-asia")]
    WirelessUsageDataAsia,
    #[serde(rename = "wireless-usage-data-centralandsouthamerica")]
    #[display("wireless-usage-data-centralandsouthamerica")]
    WirelessUsageDataCentralandsouthamerica,
    #[serde(rename = "wireless-usage-data-custom-additionalmb")]
    #[display("wireless-usage-data-custom-additionalmb")]
    WirelessUsageDataCustomAdditionalmb,
    #[serde(rename = "wireless-usage-data-custom-first5mb")]
    #[display("wireless-usage-data-custom-first5mb")]
    WirelessUsageDataCustomFirst5Mb,
    #[serde(rename = "wireless-usage-data-domestic-roaming")]
    #[display("wireless-usage-data-domestic-roaming")]
    WirelessUsageDataDomesticRoaming,
    #[serde(rename = "wireless-usage-data-europe")]
    #[display("wireless-usage-data-europe")]
    WirelessUsageDataEurope,
    #[serde(rename = "wireless-usage-data-individual-additionalgb")]
    #[display("wireless-usage-data-individual-additionalgb")]
    WirelessUsageDataIndividualAdditionalgb,
    #[serde(rename = "wireless-usage-data-individual-firstgb")]
    #[display("wireless-usage-data-individual-firstgb")]
    WirelessUsageDataIndividualFirstgb,
    #[serde(rename = "wireless-usage-data-international-roaming-canada")]
    #[display("wireless-usage-data-international-roaming-canada")]
    WirelessUsageDataInternationalRoamingCanada,
    #[serde(rename = "wireless-usage-data-international-roaming-india")]
    #[display("wireless-usage-data-international-roaming-india")]
    WirelessUsageDataInternationalRoamingIndia,
    #[serde(rename = "wireless-usage-data-international-roaming-mexico")]
    #[display("wireless-usage-data-international-roaming-mexico")]
    WirelessUsageDataInternationalRoamingMexico,
    #[serde(rename = "wireless-usage-data-northamerica")]
    #[display("wireless-usage-data-northamerica")]
    WirelessUsageDataNorthamerica,
    #[serde(rename = "wireless-usage-data-oceania")]
    #[display("wireless-usage-data-oceania")]
    WirelessUsageDataOceania,
    #[serde(rename = "wireless-usage-data-pooled")]
    #[display("wireless-usage-data-pooled")]
    WirelessUsageDataPooled,
    #[serde(rename = "wireless-usage-data-pooled-downlink")]
    #[display("wireless-usage-data-pooled-downlink")]
    WirelessUsageDataPooledDownlink,
    #[serde(rename = "wireless-usage-data-pooled-uplink")]
    #[display("wireless-usage-data-pooled-uplink")]
    WirelessUsageDataPooledUplink,
    #[serde(rename = "wireless-usage-mrc")]
    #[display("wireless-usage-mrc")]
    WirelessUsageMrc,
    #[serde(rename = "wireless-usage-mrc-custom")]
    #[display("wireless-usage-mrc-custom")]
    WirelessUsageMrcCustom,
    #[serde(rename = "wireless-usage-mrc-individual")]
    #[display("wireless-usage-mrc-individual")]
    WirelessUsageMrcIndividual,
    #[serde(rename = "wireless-usage-mrc-pooled")]
    #[display("wireless-usage-mrc-pooled")]
    WirelessUsageMrcPooled,
    #[serde(rename = "wireless-usage-mrc-suspended")]
    #[display("wireless-usage-mrc-suspended")]
    WirelessUsageMrcSuspended,
    #[serde(rename = "wireless-usage-sms")]
    #[display("wireless-usage-sms")]
    WirelessUsageSms,
    #[serde(rename = "wireless-usage-voice")]
    #[display("wireless-usage-voice")]
    WirelessUsageVoice,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountUsageUsageRecordUsageRecordYearly {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that accrued \
             the usage."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to create the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "Usage records up to date as of this timestamp, formatted as \
             YYYY-MM-DDTHH:MM:SS+00:00. All timestamps are in GMT"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub as_of: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub category: Option<UsageRecordYearlyEnumCategory>,
    #[doc = "The number of usage events, such as the number of calls."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<String>,
    #[doc = "The units in which `count` is measured, such as `calls` for calls or `messages` for \
             SMS."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count_unit: Option<String>,
    #[doc = "A plain-language description of the usage category."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "The last date for which usage is included in the UsageRecord. The date is specified \
             in GMT and formatted as `YYYY-MM-DD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_date: Option<chrono::NaiveDate>,
    #[doc = "The total price of the usage in the currency specified in `price_unit` and \
             associated with the account."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<f64>,
    #[doc = "The currency in which `price` is measured, in [ISO 4127](https://www.iso.org/iso/home/standards/currency_codes.htm) format, such as `usd`, `eur`, and `jpy`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price_unit: Option<String>,
    #[doc = "The first date for which usage is included in this UsageRecord. The date is \
             specified in GMT and formatted as `YYYY-MM-DD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_date: Option<chrono::NaiveDate>,
    #[doc = "A list of related resources identified by their URIs. For more information, see [List Subresources](https://www.twilio.com/docs/usage/api/usage-record#list-subresources)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "The amount used to bill usage and measured in units described in `usage_unit`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage: Option<String>,
    #[doc = "The units in which `usage` is measured, such as `minutes` for calls or `messages` \
             for SMS."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_unit: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountUsageUsageRecordUsageRecordYearly {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountUsageUsageRecordUsageRecordYearly {
    const LENGTH: usize = 15;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(as_of) = &self.as_of {
                format!("{as_of:?}")
            } else {
                String::new()
            },
            if let Some(category) = &self.category {
                format!("{category:?}")
            } else {
                String::new()
            },
            if let Some(count) = &self.count {
                format!("{count:?}")
            } else {
                String::new()
            },
            if let Some(count_unit) = &self.count_unit {
                format!("{count_unit:?}")
            } else {
                String::new()
            },
            if let Some(description) = &self.description {
                format!("{description:?}")
            } else {
                String::new()
            },
            if let Some(end_date) = &self.end_date {
                format!("{end_date:?}")
            } else {
                String::new()
            },
            if let Some(price) = &self.price {
                format!("{price:?}")
            } else {
                String::new()
            },
            if let Some(price_unit) = &self.price_unit {
                format!("{price_unit:?}")
            } else {
                String::new()
            },
            if let Some(start_date) = &self.start_date {
                format!("{start_date:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(usage) = &self.usage {
                format!("{usage:?}")
            } else {
                String::new()
            },
            if let Some(usage_unit) = &self.usage_unit {
                format!("{usage_unit:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "as_of".to_string(),
            "category".to_string(),
            "count".to_string(),
            "count_unit".to_string(),
            "description".to_string(),
            "end_date".to_string(),
            "price".to_string(),
            "price_unit".to_string(),
            "start_date".to_string(),
            "subresource_uris".to_string(),
            "uri".to_string(),
            "usage".to_string(),
            "usage_unit".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UsageRecordYearlyEnumCategory {
    #[serde(rename = "a2p-registration-fees")]
    #[display("a2p-registration-fees")]
    A2PRegistrationFees,
    #[serde(rename = "agent-conference")]
    #[display("agent-conference")]
    AgentConference,
    #[serde(rename = "amazon-polly")]
    #[display("amazon-polly")]
    AmazonPolly,
    #[serde(rename = "answering-machine-detection")]
    #[display("answering-machine-detection")]
    AnsweringMachineDetection,
    #[serde(rename = "authy-authentications")]
    #[display("authy-authentications")]
    AuthyAuthentications,
    #[serde(rename = "authy-calls-outbound")]
    #[display("authy-calls-outbound")]
    AuthyCallsOutbound,
    #[serde(rename = "authy-monthly-fees")]
    #[display("authy-monthly-fees")]
    AuthyMonthlyFees,
    #[serde(rename = "authy-phone-intelligence")]
    #[display("authy-phone-intelligence")]
    AuthyPhoneIntelligence,
    #[serde(rename = "authy-phone-verifications")]
    #[display("authy-phone-verifications")]
    AuthyPhoneVerifications,
    #[serde(rename = "authy-sms-outbound")]
    #[display("authy-sms-outbound")]
    AuthySmsOutbound,
    #[serde(rename = "call-progess-events")]
    #[display("call-progess-events")]
    CallProgessEvents,
    #[serde(rename = "calleridlookups")]
    #[display("calleridlookups")]
    Calleridlookups,
    #[serde(rename = "calls")]
    #[display("calls")]
    Calls,
    #[serde(rename = "calls-client")]
    #[display("calls-client")]
    CallsClient,
    #[serde(rename = "calls-globalconference")]
    #[display("calls-globalconference")]
    CallsGlobalconference,
    #[serde(rename = "calls-inbound")]
    #[display("calls-inbound")]
    CallsInbound,
    #[serde(rename = "calls-inbound-local")]
    #[display("calls-inbound-local")]
    CallsInboundLocal,
    #[serde(rename = "calls-inbound-mobile")]
    #[display("calls-inbound-mobile")]
    CallsInboundMobile,
    #[serde(rename = "calls-inbound-tollfree")]
    #[display("calls-inbound-tollfree")]
    CallsInboundTollfree,
    #[serde(rename = "calls-outbound")]
    #[display("calls-outbound")]
    CallsOutbound,
    #[serde(rename = "calls-pay-verb-transactions")]
    #[display("calls-pay-verb-transactions")]
    CallsPayVerbTransactions,
    #[serde(rename = "calls-recordings")]
    #[display("calls-recordings")]
    CallsRecordings,
    #[serde(rename = "calls-sip")]
    #[display("calls-sip")]
    CallsSip,
    #[serde(rename = "calls-sip-inbound")]
    #[display("calls-sip-inbound")]
    CallsSipInbound,
    #[serde(rename = "calls-sip-outbound")]
    #[display("calls-sip-outbound")]
    CallsSipOutbound,
    #[serde(rename = "calls-transfers")]
    #[display("calls-transfers")]
    CallsTransfers,
    #[serde(rename = "carrier-lookups")]
    #[display("carrier-lookups")]
    CarrierLookups,
    #[serde(rename = "conversations")]
    #[display("conversations")]
    Conversations,
    #[serde(rename = "conversations-api-requests")]
    #[display("conversations-api-requests")]
    ConversationsApiRequests,
    #[serde(rename = "conversations-conversation-events")]
    #[display("conversations-conversation-events")]
    ConversationsConversationEvents,
    #[serde(rename = "conversations-endpoint-connectivity")]
    #[display("conversations-endpoint-connectivity")]
    ConversationsEndpointConnectivity,
    #[serde(rename = "conversations-events")]
    #[display("conversations-events")]
    ConversationsEvents,
    #[serde(rename = "conversations-participant-events")]
    #[display("conversations-participant-events")]
    ConversationsParticipantEvents,
    #[serde(rename = "conversations-participants")]
    #[display("conversations-participants")]
    ConversationsParticipants,
    #[serde(rename = "cps")]
    #[display("cps")]
    Cps,
    #[serde(rename = "flex-usage")]
    #[display("flex-usage")]
    FlexUsage,
    #[serde(rename = "fraud-lookups")]
    #[display("fraud-lookups")]
    FraudLookups,
    #[serde(rename = "group-rooms")]
    #[display("group-rooms")]
    GroupRooms,
    #[serde(rename = "group-rooms-data-track")]
    #[display("group-rooms-data-track")]
    GroupRoomsDataTrack,
    #[serde(rename = "group-rooms-encrypted-media-recorded")]
    #[display("group-rooms-encrypted-media-recorded")]
    GroupRoomsEncryptedMediaRecorded,
    #[serde(rename = "group-rooms-media-downloaded")]
    #[display("group-rooms-media-downloaded")]
    GroupRoomsMediaDownloaded,
    #[serde(rename = "group-rooms-media-recorded")]
    #[display("group-rooms-media-recorded")]
    GroupRoomsMediaRecorded,
    #[serde(rename = "group-rooms-media-routed")]
    #[display("group-rooms-media-routed")]
    GroupRoomsMediaRouted,
    #[serde(rename = "group-rooms-media-stored")]
    #[display("group-rooms-media-stored")]
    GroupRoomsMediaStored,
    #[serde(rename = "group-rooms-participant-minutes")]
    #[display("group-rooms-participant-minutes")]
    GroupRoomsParticipantMinutes,
    #[serde(rename = "group-rooms-recorded-minutes")]
    #[display("group-rooms-recorded-minutes")]
    GroupRoomsRecordedMinutes,
    #[serde(rename = "imp-v1-usage")]
    #[display("imp-v1-usage")]
    ImpUsage,
    #[serde(rename = "lookups")]
    #[display("lookups")]
    Lookups,
    #[serde(rename = "marketplace")]
    #[display("marketplace")]
    Marketplace,
    #[serde(rename = "marketplace-algorithmia-named-entity-recognition")]
    #[display("marketplace-algorithmia-named-entity-recognition")]
    MarketplaceAlgorithmiaNamedEntityRecognition,
    #[serde(rename = "marketplace-cadence-transcription")]
    #[display("marketplace-cadence-transcription")]
    MarketplaceCadenceTranscription,
    #[serde(rename = "marketplace-cadence-translation")]
    #[display("marketplace-cadence-translation")]
    MarketplaceCadenceTranslation,
    #[serde(rename = "marketplace-capio-speech-to-text")]
    #[display("marketplace-capio-speech-to-text")]
    MarketplaceCapioSpeechToText,
    #[serde(rename = "marketplace-convriza-ababa")]
    #[display("marketplace-convriza-ababa")]
    MarketplaceConvrizaAbaba,
    #[serde(rename = "marketplace-deepgram-phrase-detector")]
    #[display("marketplace-deepgram-phrase-detector")]
    MarketplaceDeepgramPhraseDetector,
    #[serde(rename = "marketplace-digital-segment-business-info")]
    #[display("marketplace-digital-segment-business-info")]
    MarketplaceDigitalSegmentBusinessInfo,
    #[serde(rename = "marketplace-facebook-offline-conversions")]
    #[display("marketplace-facebook-offline-conversions")]
    MarketplaceFacebookOfflineConversions,
    #[serde(rename = "marketplace-google-speech-to-text")]
    #[display("marketplace-google-speech-to-text")]
    MarketplaceGoogleSpeechToText,
    #[serde(rename = "marketplace-ibm-watson-message-insights")]
    #[display("marketplace-ibm-watson-message-insights")]
    MarketplaceIbmWatsonMessageInsights,
    #[serde(rename = "marketplace-ibm-watson-message-sentiment")]
    #[display("marketplace-ibm-watson-message-sentiment")]
    MarketplaceIbmWatsonMessageSentiment,
    #[serde(rename = "marketplace-ibm-watson-recording-analysis")]
    #[display("marketplace-ibm-watson-recording-analysis")]
    MarketplaceIbmWatsonRecordingAnalysis,
    #[serde(rename = "marketplace-ibm-watson-tone-analyzer")]
    #[display("marketplace-ibm-watson-tone-analyzer")]
    MarketplaceIbmWatsonToneAnalyzer,
    #[serde(rename = "marketplace-icehook-systems-scout")]
    #[display("marketplace-icehook-systems-scout")]
    MarketplaceIcehookSystemsScout,
    #[serde(rename = "marketplace-infogroup-dataaxle-bizinfo")]
    #[display("marketplace-infogroup-dataaxle-bizinfo")]
    MarketplaceInfogroupDataaxleBizinfo,
    #[serde(rename = "marketplace-keen-io-contact-center-analytics")]
    #[display("marketplace-keen-io-contact-center-analytics")]
    MarketplaceKeenIoContactCenterAnalytics,
    #[serde(rename = "marketplace-marchex-cleancall")]
    #[display("marketplace-marchex-cleancall")]
    MarketplaceMarchexCleancall,
    #[serde(rename = "marketplace-marchex-sentiment-analysis-for-sms")]
    #[display("marketplace-marchex-sentiment-analysis-for-sms")]
    MarketplaceMarchexSentimentAnalysisForSms,
    #[serde(rename = "marketplace-marketplace-nextcaller-social-id")]
    #[display("marketplace-marketplace-nextcaller-social-id")]
    MarketplaceMarketplaceNextcallerSocialId,
    #[serde(rename = "marketplace-mobile-commons-opt-out-classifier")]
    #[display("marketplace-mobile-commons-opt-out-classifier")]
    MarketplaceMobileCommonsOptOutClassifier,
    #[serde(rename = "marketplace-nexiwave-voicemail-to-text")]
    #[display("marketplace-nexiwave-voicemail-to-text")]
    MarketplaceNexiwaveVoicemailToText,
    #[serde(rename = "marketplace-nextcaller-advanced-caller-identification")]
    #[display("marketplace-nextcaller-advanced-caller-identification")]
    MarketplaceNextcallerAdvancedCallerIdentification,
    #[serde(rename = "marketplace-nomorobo-spam-score")]
    #[display("marketplace-nomorobo-spam-score")]
    MarketplaceNomoroboSpamScore,
    #[serde(rename = "marketplace-payfone-tcpa-compliance")]
    #[display("marketplace-payfone-tcpa-compliance")]
    MarketplacePayfoneTcpaCompliance,
    #[serde(rename = "marketplace-remeeting-automatic-speech-recognition")]
    #[display("marketplace-remeeting-automatic-speech-recognition")]
    MarketplaceRemeetingAutomaticSpeechRecognition,
    #[serde(rename = "marketplace-tcpa-defense-solutions-blacklist-feed")]
    #[display("marketplace-tcpa-defense-solutions-blacklist-feed")]
    MarketplaceTcpaDefenseSolutionsBlacklistFeed,
    #[serde(rename = "marketplace-telo-opencnam")]
    #[display("marketplace-telo-opencnam")]
    MarketplaceTeloOpencnam,
    #[serde(rename = "marketplace-truecnam-true-spam")]
    #[display("marketplace-truecnam-true-spam")]
    MarketplaceTruecnamTrueSpam,
    #[serde(rename = "marketplace-twilio-caller-name-lookup-us")]
    #[display("marketplace-twilio-caller-name-lookup-us")]
    MarketplaceTwilioCallerNameLookupUs,
    #[serde(rename = "marketplace-twilio-carrier-information-lookup")]
    #[display("marketplace-twilio-carrier-information-lookup")]
    MarketplaceTwilioCarrierInformationLookup,
    #[serde(rename = "marketplace-voicebase-pci")]
    #[display("marketplace-voicebase-pci")]
    MarketplaceVoicebasePci,
    #[serde(rename = "marketplace-voicebase-transcription")]
    #[display("marketplace-voicebase-transcription")]
    MarketplaceVoicebaseTranscription,
    #[serde(rename = "marketplace-voicebase-transcription-custom-vocabulary")]
    #[display("marketplace-voicebase-transcription-custom-vocabulary")]
    MarketplaceVoicebaseTranscriptionCustomVocabulary,
    #[serde(rename = "marketplace-whitepages-pro-caller-identification")]
    #[display("marketplace-whitepages-pro-caller-identification")]
    MarketplaceWhitepagesProCallerIdentification,
    #[serde(rename = "marketplace-whitepages-pro-phone-intelligence")]
    #[display("marketplace-whitepages-pro-phone-intelligence")]
    MarketplaceWhitepagesProPhoneIntelligence,
    #[serde(rename = "marketplace-whitepages-pro-phone-reputation")]
    #[display("marketplace-whitepages-pro-phone-reputation")]
    MarketplaceWhitepagesProPhoneReputation,
    #[serde(rename = "marketplace-wolfarm-spoken-results")]
    #[display("marketplace-wolfarm-spoken-results")]
    MarketplaceWolfarmSpokenResults,
    #[serde(rename = "marketplace-wolfram-short-answer")]
    #[display("marketplace-wolfram-short-answer")]
    MarketplaceWolframShortAnswer,
    #[serde(rename = "marketplace-ytica-contact-center-reporting-analytics")]
    #[display("marketplace-ytica-contact-center-reporting-analytics")]
    MarketplaceYticaContactCenterReportingAnalytics,
    #[serde(rename = "mediastorage")]
    #[display("mediastorage")]
    Mediastorage,
    #[serde(rename = "mms")]
    #[display("mms")]
    Mms,
    #[serde(rename = "mms-inbound")]
    #[display("mms-inbound")]
    MmsInbound,
    #[serde(rename = "mms-inbound-longcode")]
    #[display("mms-inbound-longcode")]
    MmsInboundLongcode,
    #[serde(rename = "mms-inbound-shortcode")]
    #[display("mms-inbound-shortcode")]
    MmsInboundShortcode,
    #[serde(rename = "mms-messages-carrierfees")]
    #[display("mms-messages-carrierfees")]
    MmsMessagesCarrierfees,
    #[serde(rename = "mms-outbound")]
    #[display("mms-outbound")]
    MmsOutbound,
    #[serde(rename = "mms-outbound-longcode")]
    #[display("mms-outbound-longcode")]
    MmsOutboundLongcode,
    #[serde(rename = "mms-outbound-shortcode")]
    #[display("mms-outbound-shortcode")]
    MmsOutboundShortcode,
    #[serde(rename = "monitor-reads")]
    #[display("monitor-reads")]
    MonitorReads,
    #[serde(rename = "monitor-storage")]
    #[display("monitor-storage")]
    MonitorStorage,
    #[serde(rename = "monitor-writes")]
    #[display("monitor-writes")]
    MonitorWrites,
    #[serde(rename = "notify")]
    #[display("notify")]
    Notify,
    #[serde(rename = "notify-actions-attempts")]
    #[display("notify-actions-attempts")]
    NotifyActionsAttempts,
    #[serde(rename = "notify-channels")]
    #[display("notify-channels")]
    NotifyChannels,
    #[serde(rename = "number-format-lookups")]
    #[display("number-format-lookups")]
    NumberFormatLookups,
    #[serde(rename = "pchat")]
    #[display("pchat")]
    Pchat,
    #[serde(rename = "pchat-users")]
    #[display("pchat-users")]
    PchatUsers,
    #[serde(rename = "peer-to-peer-rooms-participant-minutes")]
    #[display("peer-to-peer-rooms-participant-minutes")]
    PeerToPeerRoomsParticipantMinutes,
    #[serde(rename = "pfax")]
    #[display("pfax")]
    Pfax,
    #[serde(rename = "pfax-minutes")]
    #[display("pfax-minutes")]
    PfaxMinutes,
    #[serde(rename = "pfax-minutes-inbound")]
    #[display("pfax-minutes-inbound")]
    PfaxMinutesInbound,
    #[serde(rename = "pfax-minutes-outbound")]
    #[display("pfax-minutes-outbound")]
    PfaxMinutesOutbound,
    #[serde(rename = "pfax-pages")]
    #[display("pfax-pages")]
    PfaxPages,
    #[serde(rename = "phonenumbers")]
    #[display("phonenumbers")]
    Phonenumbers,
    #[serde(rename = "phonenumbers-cps")]
    #[display("phonenumbers-cps")]
    PhonenumbersCps,
    #[serde(rename = "phonenumbers-emergency")]
    #[display("phonenumbers-emergency")]
    PhonenumbersEmergency,
    #[serde(rename = "phonenumbers-local")]
    #[display("phonenumbers-local")]
    PhonenumbersLocal,
    #[serde(rename = "phonenumbers-mobile")]
    #[display("phonenumbers-mobile")]
    PhonenumbersMobile,
    #[serde(rename = "phonenumbers-setups")]
    #[display("phonenumbers-setups")]
    PhonenumbersSetups,
    #[serde(rename = "phonenumbers-tollfree")]
    #[display("phonenumbers-tollfree")]
    PhonenumbersTollfree,
    #[serde(rename = "premiumsupport")]
    #[display("premiumsupport")]
    Premiumsupport,
    #[serde(rename = "proxy")]
    #[display("proxy")]
    Proxy,
    #[serde(rename = "proxy-active-sessions")]
    #[display("proxy-active-sessions")]
    ProxyActiveSessions,
    #[serde(rename = "pstnconnectivity")]
    #[display("pstnconnectivity")]
    Pstnconnectivity,
    #[serde(rename = "pv")]
    #[display("pv")]
    Pv,
    #[serde(rename = "pv-composition-media-downloaded")]
    #[display("pv-composition-media-downloaded")]
    PvCompositionMediaDownloaded,
    #[serde(rename = "pv-composition-media-encrypted")]
    #[display("pv-composition-media-encrypted")]
    PvCompositionMediaEncrypted,
    #[serde(rename = "pv-composition-media-stored")]
    #[display("pv-composition-media-stored")]
    PvCompositionMediaStored,
    #[serde(rename = "pv-composition-minutes")]
    #[display("pv-composition-minutes")]
    PvCompositionMinutes,
    #[serde(rename = "pv-recording-compositions")]
    #[display("pv-recording-compositions")]
    PvRecordingCompositions,
    #[serde(rename = "pv-room-participants")]
    #[display("pv-room-participants")]
    PvRoomParticipants,
    #[serde(rename = "pv-room-participants-au1")]
    #[display("pv-room-participants-au1")]
    PvRoomParticipantsAu1,
    #[serde(rename = "pv-room-participants-br1")]
    #[display("pv-room-participants-br1")]
    PvRoomParticipantsBr1,
    #[serde(rename = "pv-room-participants-ie1")]
    #[display("pv-room-participants-ie1")]
    PvRoomParticipantsIe1,
    #[serde(rename = "pv-room-participants-jp1")]
    #[display("pv-room-participants-jp1")]
    PvRoomParticipantsJp1,
    #[serde(rename = "pv-room-participants-sg1")]
    #[display("pv-room-participants-sg1")]
    PvRoomParticipantsSg1,
    #[serde(rename = "pv-room-participants-us1")]
    #[display("pv-room-participants-us1")]
    PvRoomParticipantsUs1,
    #[serde(rename = "pv-room-participants-us2")]
    #[display("pv-room-participants-us2")]
    PvRoomParticipantsUs2,
    #[serde(rename = "pv-rooms")]
    #[display("pv-rooms")]
    PvRooms,
    #[serde(rename = "pv-sip-endpoint-registrations")]
    #[display("pv-sip-endpoint-registrations")]
    PvSipEndpointRegistrations,
    #[serde(rename = "recordings")]
    #[display("recordings")]
    Recordings,
    #[serde(rename = "recordingstorage")]
    #[display("recordingstorage")]
    Recordingstorage,
    #[serde(rename = "rooms-group-bandwidth")]
    #[display("rooms-group-bandwidth")]
    RoomsGroupBandwidth,
    #[serde(rename = "rooms-group-minutes")]
    #[display("rooms-group-minutes")]
    RoomsGroupMinutes,
    #[serde(rename = "rooms-peer-to-peer-minutes")]
    #[display("rooms-peer-to-peer-minutes")]
    RoomsPeerToPeerMinutes,
    #[serde(rename = "shortcodes")]
    #[display("shortcodes")]
    Shortcodes,
    #[serde(rename = "shortcodes-customerowned")]
    #[display("shortcodes-customerowned")]
    ShortcodesCustomerowned,
    #[serde(rename = "shortcodes-mms-enablement")]
    #[display("shortcodes-mms-enablement")]
    ShortcodesMmsEnablement,
    #[serde(rename = "shortcodes-mps")]
    #[display("shortcodes-mps")]
    ShortcodesMps,
    #[serde(rename = "shortcodes-random")]
    #[display("shortcodes-random")]
    ShortcodesRandom,
    #[serde(rename = "shortcodes-uk")]
    #[display("shortcodes-uk")]
    ShortcodesUk,
    #[serde(rename = "shortcodes-vanity")]
    #[display("shortcodes-vanity")]
    ShortcodesVanity,
    #[serde(rename = "small-group-rooms")]
    #[display("small-group-rooms")]
    SmallGroupRooms,
    #[serde(rename = "small-group-rooms-data-track")]
    #[display("small-group-rooms-data-track")]
    SmallGroupRoomsDataTrack,
    #[serde(rename = "small-group-rooms-participant-minutes")]
    #[display("small-group-rooms-participant-minutes")]
    SmallGroupRoomsParticipantMinutes,
    #[serde(rename = "sms")]
    #[display("sms")]
    Sms,
    #[serde(rename = "sms-inbound")]
    #[display("sms-inbound")]
    SmsInbound,
    #[serde(rename = "sms-inbound-longcode")]
    #[display("sms-inbound-longcode")]
    SmsInboundLongcode,
    #[serde(rename = "sms-inbound-shortcode")]
    #[display("sms-inbound-shortcode")]
    SmsInboundShortcode,
    #[serde(rename = "sms-messages-carrierfees")]
    #[display("sms-messages-carrierfees")]
    SmsMessagesCarrierfees,
    #[serde(rename = "sms-messages-features")]
    #[display("sms-messages-features")]
    SmsMessagesFeatures,
    #[serde(rename = "sms-messages-features-senderid")]
    #[display("sms-messages-features-senderid")]
    SmsMessagesFeaturesSenderid,
    #[serde(rename = "sms-outbound")]
    #[display("sms-outbound")]
    SmsOutbound,
    #[serde(rename = "sms-outbound-content-inspection")]
    #[display("sms-outbound-content-inspection")]
    SmsOutboundContentInspection,
    #[serde(rename = "sms-outbound-longcode")]
    #[display("sms-outbound-longcode")]
    SmsOutboundLongcode,
    #[serde(rename = "sms-outbound-shortcode")]
    #[display("sms-outbound-shortcode")]
    SmsOutboundShortcode,
    #[serde(rename = "speech-recognition")]
    #[display("speech-recognition")]
    SpeechRecognition,
    #[serde(rename = "studio-engagements")]
    #[display("studio-engagements")]
    StudioEngagements,
    #[serde(rename = "sync")]
    #[display("sync")]
    Sync,
    #[serde(rename = "sync-actions")]
    #[display("sync-actions")]
    SyncActions,
    #[serde(rename = "sync-endpoint-hours")]
    #[display("sync-endpoint-hours")]
    SyncEndpointHours,
    #[serde(rename = "sync-endpoint-hours-above-daily-cap")]
    #[display("sync-endpoint-hours-above-daily-cap")]
    SyncEndpointHoursAboveDailyCap,
    #[serde(rename = "taskrouter-tasks")]
    #[display("taskrouter-tasks")]
    TaskrouterTasks,
    #[serde(rename = "totalprice")]
    #[display("totalprice")]
    Totalprice,
    #[serde(rename = "transcriptions")]
    #[display("transcriptions")]
    Transcriptions,
    #[serde(rename = "trunking-cps")]
    #[display("trunking-cps")]
    TrunkingCps,
    #[serde(rename = "trunking-emergency-calls")]
    #[display("trunking-emergency-calls")]
    TrunkingEmergencyCalls,
    #[serde(rename = "trunking-origination")]
    #[display("trunking-origination")]
    TrunkingOrigination,
    #[serde(rename = "trunking-origination-local")]
    #[display("trunking-origination-local")]
    TrunkingOriginationLocal,
    #[serde(rename = "trunking-origination-mobile")]
    #[display("trunking-origination-mobile")]
    TrunkingOriginationMobile,
    #[serde(rename = "trunking-origination-tollfree")]
    #[display("trunking-origination-tollfree")]
    TrunkingOriginationTollfree,
    #[serde(rename = "trunking-recordings")]
    #[display("trunking-recordings")]
    TrunkingRecordings,
    #[serde(rename = "trunking-secure")]
    #[display("trunking-secure")]
    TrunkingSecure,
    #[serde(rename = "trunking-termination")]
    #[display("trunking-termination")]
    TrunkingTermination,
    #[serde(rename = "turnmegabytes")]
    #[display("turnmegabytes")]
    Turnmegabytes,
    #[serde(rename = "turnmegabytes-australia")]
    #[display("turnmegabytes-australia")]
    TurnmegabytesAustralia,
    #[serde(rename = "turnmegabytes-brasil")]
    #[display("turnmegabytes-brasil")]
    TurnmegabytesBrasil,
    #[serde(rename = "turnmegabytes-germany")]
    #[display("turnmegabytes-germany")]
    TurnmegabytesGermany,
    #[serde(rename = "turnmegabytes-india")]
    #[display("turnmegabytes-india")]
    TurnmegabytesIndia,
    #[serde(rename = "turnmegabytes-ireland")]
    #[display("turnmegabytes-ireland")]
    TurnmegabytesIreland,
    #[serde(rename = "turnmegabytes-japan")]
    #[display("turnmegabytes-japan")]
    TurnmegabytesJapan,
    #[serde(rename = "turnmegabytes-singapore")]
    #[display("turnmegabytes-singapore")]
    TurnmegabytesSingapore,
    #[serde(rename = "turnmegabytes-useast")]
    #[display("turnmegabytes-useast")]
    TurnmegabytesUseast,
    #[serde(rename = "turnmegabytes-uswest")]
    #[display("turnmegabytes-uswest")]
    TurnmegabytesUswest,
    #[serde(rename = "twilio-interconnect")]
    #[display("twilio-interconnect")]
    TwilioInterconnect,
    #[serde(rename = "verify-push")]
    #[display("verify-push")]
    VerifyPush,
    #[serde(rename = "verify-totp")]
    #[display("verify-totp")]
    VerifyTotp,
    #[serde(rename = "verify-whatsapp-conversations-business-initiated")]
    #[display("verify-whatsapp-conversations-business-initiated")]
    VerifyWhatsappConversationsBusinessInitiated,
    #[serde(rename = "video-recordings")]
    #[display("video-recordings")]
    VideoRecordings,
    #[serde(rename = "virtual-agent")]
    #[display("virtual-agent")]
    VirtualAgent,
    #[serde(rename = "voice-insights")]
    #[display("voice-insights")]
    VoiceInsights,
    #[serde(rename = "voice-insights-client-insights-on-demand-minute")]
    #[display("voice-insights-client-insights-on-demand-minute")]
    VoiceInsightsClientInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-ptsn-insights-on-demand-minute")]
    #[display("voice-insights-ptsn-insights-on-demand-minute")]
    VoiceInsightsPtsnInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-interface-insights-on-demand-minute")]
    #[display("voice-insights-sip-interface-insights-on-demand-minute")]
    VoiceInsightsSipInterfaceInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-trunking-insights-on-demand-minute")]
    #[display("voice-insights-sip-trunking-insights-on-demand-minute")]
    VoiceInsightsSipTrunkingInsightsOnDemandMinute,
    #[serde(rename = "wireless")]
    #[display("wireless")]
    Wireless,
    #[serde(rename = "wireless-orders")]
    #[display("wireless-orders")]
    WirelessOrders,
    #[serde(rename = "wireless-orders-artwork")]
    #[display("wireless-orders-artwork")]
    WirelessOrdersArtwork,
    #[serde(rename = "wireless-orders-bulk")]
    #[display("wireless-orders-bulk")]
    WirelessOrdersBulk,
    #[serde(rename = "wireless-orders-esim")]
    #[display("wireless-orders-esim")]
    WirelessOrdersEsim,
    #[serde(rename = "wireless-orders-starter")]
    #[display("wireless-orders-starter")]
    WirelessOrdersStarter,
    #[serde(rename = "wireless-usage")]
    #[display("wireless-usage")]
    WirelessUsage,
    #[serde(rename = "wireless-usage-commands")]
    #[display("wireless-usage-commands")]
    WirelessUsageCommands,
    #[serde(rename = "wireless-usage-commands-africa")]
    #[display("wireless-usage-commands-africa")]
    WirelessUsageCommandsAfrica,
    #[serde(rename = "wireless-usage-commands-asia")]
    #[display("wireless-usage-commands-asia")]
    WirelessUsageCommandsAsia,
    #[serde(rename = "wireless-usage-commands-centralandsouthamerica")]
    #[display("wireless-usage-commands-centralandsouthamerica")]
    WirelessUsageCommandsCentralandsouthamerica,
    #[serde(rename = "wireless-usage-commands-europe")]
    #[display("wireless-usage-commands-europe")]
    WirelessUsageCommandsEurope,
    #[serde(rename = "wireless-usage-commands-home")]
    #[display("wireless-usage-commands-home")]
    WirelessUsageCommandsHome,
    #[serde(rename = "wireless-usage-commands-northamerica")]
    #[display("wireless-usage-commands-northamerica")]
    WirelessUsageCommandsNorthamerica,
    #[serde(rename = "wireless-usage-commands-oceania")]
    #[display("wireless-usage-commands-oceania")]
    WirelessUsageCommandsOceania,
    #[serde(rename = "wireless-usage-commands-roaming")]
    #[display("wireless-usage-commands-roaming")]
    WirelessUsageCommandsRoaming,
    #[serde(rename = "wireless-usage-data")]
    #[display("wireless-usage-data")]
    WirelessUsageData,
    #[serde(rename = "wireless-usage-data-africa")]
    #[display("wireless-usage-data-africa")]
    WirelessUsageDataAfrica,
    #[serde(rename = "wireless-usage-data-asia")]
    #[display("wireless-usage-data-asia")]
    WirelessUsageDataAsia,
    #[serde(rename = "wireless-usage-data-centralandsouthamerica")]
    #[display("wireless-usage-data-centralandsouthamerica")]
    WirelessUsageDataCentralandsouthamerica,
    #[serde(rename = "wireless-usage-data-custom-additionalmb")]
    #[display("wireless-usage-data-custom-additionalmb")]
    WirelessUsageDataCustomAdditionalmb,
    #[serde(rename = "wireless-usage-data-custom-first5mb")]
    #[display("wireless-usage-data-custom-first5mb")]
    WirelessUsageDataCustomFirst5Mb,
    #[serde(rename = "wireless-usage-data-domestic-roaming")]
    #[display("wireless-usage-data-domestic-roaming")]
    WirelessUsageDataDomesticRoaming,
    #[serde(rename = "wireless-usage-data-europe")]
    #[display("wireless-usage-data-europe")]
    WirelessUsageDataEurope,
    #[serde(rename = "wireless-usage-data-individual-additionalgb")]
    #[display("wireless-usage-data-individual-additionalgb")]
    WirelessUsageDataIndividualAdditionalgb,
    #[serde(rename = "wireless-usage-data-individual-firstgb")]
    #[display("wireless-usage-data-individual-firstgb")]
    WirelessUsageDataIndividualFirstgb,
    #[serde(rename = "wireless-usage-data-international-roaming-canada")]
    #[display("wireless-usage-data-international-roaming-canada")]
    WirelessUsageDataInternationalRoamingCanada,
    #[serde(rename = "wireless-usage-data-international-roaming-india")]
    #[display("wireless-usage-data-international-roaming-india")]
    WirelessUsageDataInternationalRoamingIndia,
    #[serde(rename = "wireless-usage-data-international-roaming-mexico")]
    #[display("wireless-usage-data-international-roaming-mexico")]
    WirelessUsageDataInternationalRoamingMexico,
    #[serde(rename = "wireless-usage-data-northamerica")]
    #[display("wireless-usage-data-northamerica")]
    WirelessUsageDataNorthamerica,
    #[serde(rename = "wireless-usage-data-oceania")]
    #[display("wireless-usage-data-oceania")]
    WirelessUsageDataOceania,
    #[serde(rename = "wireless-usage-data-pooled")]
    #[display("wireless-usage-data-pooled")]
    WirelessUsageDataPooled,
    #[serde(rename = "wireless-usage-data-pooled-downlink")]
    #[display("wireless-usage-data-pooled-downlink")]
    WirelessUsageDataPooledDownlink,
    #[serde(rename = "wireless-usage-data-pooled-uplink")]
    #[display("wireless-usage-data-pooled-uplink")]
    WirelessUsageDataPooledUplink,
    #[serde(rename = "wireless-usage-mrc")]
    #[display("wireless-usage-mrc")]
    WirelessUsageMrc,
    #[serde(rename = "wireless-usage-mrc-custom")]
    #[display("wireless-usage-mrc-custom")]
    WirelessUsageMrcCustom,
    #[serde(rename = "wireless-usage-mrc-individual")]
    #[display("wireless-usage-mrc-individual")]
    WirelessUsageMrcIndividual,
    #[serde(rename = "wireless-usage-mrc-pooled")]
    #[display("wireless-usage-mrc-pooled")]
    WirelessUsageMrcPooled,
    #[serde(rename = "wireless-usage-mrc-suspended")]
    #[display("wireless-usage-mrc-suspended")]
    WirelessUsageMrcSuspended,
    #[serde(rename = "wireless-usage-sms")]
    #[display("wireless-usage-sms")]
    WirelessUsageSms,
    #[serde(rename = "wireless-usage-voice")]
    #[display("wireless-usage-voice")]
    WirelessUsageVoice,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountUsageUsageRecordUsageRecordYesterday {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that accrued \
             the usage."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to create the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "Usage records up to date as of this timestamp, formatted as \
             YYYY-MM-DDTHH:MM:SS+00:00. All timestamps are in GMT"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub as_of: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub category: Option<UsageRecordYesterdayEnumCategory>,
    #[doc = "The number of usage events, such as the number of calls."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<String>,
    #[doc = "The units in which `count` is measured, such as `calls` for calls or `messages` for \
             SMS."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count_unit: Option<String>,
    #[doc = "A plain-language description of the usage category."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "The last date for which usage is included in the UsageRecord. The date is specified \
             in GMT and formatted as `YYYY-MM-DD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_date: Option<chrono::NaiveDate>,
    #[doc = "The total price of the usage in the currency specified in `price_unit` and \
             associated with the account."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<f64>,
    #[doc = "The currency in which `price` is measured, in [ISO 4127](https://www.iso.org/iso/home/standards/currency_codes.htm) format, such as `usd`, `eur`, and `jpy`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price_unit: Option<String>,
    #[doc = "The first date for which usage is included in this UsageRecord. The date is \
             specified in GMT and formatted as `YYYY-MM-DD`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_date: Option<chrono::NaiveDate>,
    #[doc = "A list of related resources identified by their URIs. For more information, see [List Subresources](https://www.twilio.com/docs/usage/api/usage-record#list-subresources)."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource_uris: Option<SubresourceUris>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[doc = "The amount used to bill usage and measured in units described in `usage_unit`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage: Option<String>,
    #[doc = "The units in which `usage` is measured, such as `minutes` for calls or `messages` \
             for SMS."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_unit: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountUsageUsageRecordUsageRecordYesterday {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountUsageUsageRecordUsageRecordYesterday {
    const LENGTH: usize = 15;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(as_of) = &self.as_of {
                format!("{as_of:?}")
            } else {
                String::new()
            },
            if let Some(category) = &self.category {
                format!("{category:?}")
            } else {
                String::new()
            },
            if let Some(count) = &self.count {
                format!("{count:?}")
            } else {
                String::new()
            },
            if let Some(count_unit) = &self.count_unit {
                format!("{count_unit:?}")
            } else {
                String::new()
            },
            if let Some(description) = &self.description {
                format!("{description:?}")
            } else {
                String::new()
            },
            if let Some(end_date) = &self.end_date {
                format!("{end_date:?}")
            } else {
                String::new()
            },
            if let Some(price) = &self.price {
                format!("{price:?}")
            } else {
                String::new()
            },
            if let Some(price_unit) = &self.price_unit {
                format!("{price_unit:?}")
            } else {
                String::new()
            },
            if let Some(start_date) = &self.start_date {
                format!("{start_date:?}")
            } else {
                String::new()
            },
            if let Some(subresource_uris) = &self.subresource_uris {
                format!("{subresource_uris:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(usage) = &self.usage {
                format!("{usage:?}")
            } else {
                String::new()
            },
            if let Some(usage_unit) = &self.usage_unit {
                format!("{usage_unit:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "as_of".to_string(),
            "category".to_string(),
            "count".to_string(),
            "count_unit".to_string(),
            "description".to_string(),
            "end_date".to_string(),
            "price".to_string(),
            "price_unit".to_string(),
            "start_date".to_string(),
            "subresource_uris".to_string(),
            "uri".to_string(),
            "usage".to_string(),
            "usage_unit".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UsageRecordYesterdayEnumCategory {
    #[serde(rename = "a2p-registration-fees")]
    #[display("a2p-registration-fees")]
    A2PRegistrationFees,
    #[serde(rename = "agent-conference")]
    #[display("agent-conference")]
    AgentConference,
    #[serde(rename = "amazon-polly")]
    #[display("amazon-polly")]
    AmazonPolly,
    #[serde(rename = "answering-machine-detection")]
    #[display("answering-machine-detection")]
    AnsweringMachineDetection,
    #[serde(rename = "authy-authentications")]
    #[display("authy-authentications")]
    AuthyAuthentications,
    #[serde(rename = "authy-calls-outbound")]
    #[display("authy-calls-outbound")]
    AuthyCallsOutbound,
    #[serde(rename = "authy-monthly-fees")]
    #[display("authy-monthly-fees")]
    AuthyMonthlyFees,
    #[serde(rename = "authy-phone-intelligence")]
    #[display("authy-phone-intelligence")]
    AuthyPhoneIntelligence,
    #[serde(rename = "authy-phone-verifications")]
    #[display("authy-phone-verifications")]
    AuthyPhoneVerifications,
    #[serde(rename = "authy-sms-outbound")]
    #[display("authy-sms-outbound")]
    AuthySmsOutbound,
    #[serde(rename = "call-progess-events")]
    #[display("call-progess-events")]
    CallProgessEvents,
    #[serde(rename = "calleridlookups")]
    #[display("calleridlookups")]
    Calleridlookups,
    #[serde(rename = "calls")]
    #[display("calls")]
    Calls,
    #[serde(rename = "calls-client")]
    #[display("calls-client")]
    CallsClient,
    #[serde(rename = "calls-globalconference")]
    #[display("calls-globalconference")]
    CallsGlobalconference,
    #[serde(rename = "calls-inbound")]
    #[display("calls-inbound")]
    CallsInbound,
    #[serde(rename = "calls-inbound-local")]
    #[display("calls-inbound-local")]
    CallsInboundLocal,
    #[serde(rename = "calls-inbound-mobile")]
    #[display("calls-inbound-mobile")]
    CallsInboundMobile,
    #[serde(rename = "calls-inbound-tollfree")]
    #[display("calls-inbound-tollfree")]
    CallsInboundTollfree,
    #[serde(rename = "calls-outbound")]
    #[display("calls-outbound")]
    CallsOutbound,
    #[serde(rename = "calls-pay-verb-transactions")]
    #[display("calls-pay-verb-transactions")]
    CallsPayVerbTransactions,
    #[serde(rename = "calls-recordings")]
    #[display("calls-recordings")]
    CallsRecordings,
    #[serde(rename = "calls-sip")]
    #[display("calls-sip")]
    CallsSip,
    #[serde(rename = "calls-sip-inbound")]
    #[display("calls-sip-inbound")]
    CallsSipInbound,
    #[serde(rename = "calls-sip-outbound")]
    #[display("calls-sip-outbound")]
    CallsSipOutbound,
    #[serde(rename = "calls-transfers")]
    #[display("calls-transfers")]
    CallsTransfers,
    #[serde(rename = "carrier-lookups")]
    #[display("carrier-lookups")]
    CarrierLookups,
    #[serde(rename = "conversations")]
    #[display("conversations")]
    Conversations,
    #[serde(rename = "conversations-api-requests")]
    #[display("conversations-api-requests")]
    ConversationsApiRequests,
    #[serde(rename = "conversations-conversation-events")]
    #[display("conversations-conversation-events")]
    ConversationsConversationEvents,
    #[serde(rename = "conversations-endpoint-connectivity")]
    #[display("conversations-endpoint-connectivity")]
    ConversationsEndpointConnectivity,
    #[serde(rename = "conversations-events")]
    #[display("conversations-events")]
    ConversationsEvents,
    #[serde(rename = "conversations-participant-events")]
    #[display("conversations-participant-events")]
    ConversationsParticipantEvents,
    #[serde(rename = "conversations-participants")]
    #[display("conversations-participants")]
    ConversationsParticipants,
    #[serde(rename = "cps")]
    #[display("cps")]
    Cps,
    #[serde(rename = "flex-usage")]
    #[display("flex-usage")]
    FlexUsage,
    #[serde(rename = "fraud-lookups")]
    #[display("fraud-lookups")]
    FraudLookups,
    #[serde(rename = "group-rooms")]
    #[display("group-rooms")]
    GroupRooms,
    #[serde(rename = "group-rooms-data-track")]
    #[display("group-rooms-data-track")]
    GroupRoomsDataTrack,
    #[serde(rename = "group-rooms-encrypted-media-recorded")]
    #[display("group-rooms-encrypted-media-recorded")]
    GroupRoomsEncryptedMediaRecorded,
    #[serde(rename = "group-rooms-media-downloaded")]
    #[display("group-rooms-media-downloaded")]
    GroupRoomsMediaDownloaded,
    #[serde(rename = "group-rooms-media-recorded")]
    #[display("group-rooms-media-recorded")]
    GroupRoomsMediaRecorded,
    #[serde(rename = "group-rooms-media-routed")]
    #[display("group-rooms-media-routed")]
    GroupRoomsMediaRouted,
    #[serde(rename = "group-rooms-media-stored")]
    #[display("group-rooms-media-stored")]
    GroupRoomsMediaStored,
    #[serde(rename = "group-rooms-participant-minutes")]
    #[display("group-rooms-participant-minutes")]
    GroupRoomsParticipantMinutes,
    #[serde(rename = "group-rooms-recorded-minutes")]
    #[display("group-rooms-recorded-minutes")]
    GroupRoomsRecordedMinutes,
    #[serde(rename = "imp-v1-usage")]
    #[display("imp-v1-usage")]
    ImpUsage,
    #[serde(rename = "lookups")]
    #[display("lookups")]
    Lookups,
    #[serde(rename = "marketplace")]
    #[display("marketplace")]
    Marketplace,
    #[serde(rename = "marketplace-algorithmia-named-entity-recognition")]
    #[display("marketplace-algorithmia-named-entity-recognition")]
    MarketplaceAlgorithmiaNamedEntityRecognition,
    #[serde(rename = "marketplace-cadence-transcription")]
    #[display("marketplace-cadence-transcription")]
    MarketplaceCadenceTranscription,
    #[serde(rename = "marketplace-cadence-translation")]
    #[display("marketplace-cadence-translation")]
    MarketplaceCadenceTranslation,
    #[serde(rename = "marketplace-capio-speech-to-text")]
    #[display("marketplace-capio-speech-to-text")]
    MarketplaceCapioSpeechToText,
    #[serde(rename = "marketplace-convriza-ababa")]
    #[display("marketplace-convriza-ababa")]
    MarketplaceConvrizaAbaba,
    #[serde(rename = "marketplace-deepgram-phrase-detector")]
    #[display("marketplace-deepgram-phrase-detector")]
    MarketplaceDeepgramPhraseDetector,
    #[serde(rename = "marketplace-digital-segment-business-info")]
    #[display("marketplace-digital-segment-business-info")]
    MarketplaceDigitalSegmentBusinessInfo,
    #[serde(rename = "marketplace-facebook-offline-conversions")]
    #[display("marketplace-facebook-offline-conversions")]
    MarketplaceFacebookOfflineConversions,
    #[serde(rename = "marketplace-google-speech-to-text")]
    #[display("marketplace-google-speech-to-text")]
    MarketplaceGoogleSpeechToText,
    #[serde(rename = "marketplace-ibm-watson-message-insights")]
    #[display("marketplace-ibm-watson-message-insights")]
    MarketplaceIbmWatsonMessageInsights,
    #[serde(rename = "marketplace-ibm-watson-message-sentiment")]
    #[display("marketplace-ibm-watson-message-sentiment")]
    MarketplaceIbmWatsonMessageSentiment,
    #[serde(rename = "marketplace-ibm-watson-recording-analysis")]
    #[display("marketplace-ibm-watson-recording-analysis")]
    MarketplaceIbmWatsonRecordingAnalysis,
    #[serde(rename = "marketplace-ibm-watson-tone-analyzer")]
    #[display("marketplace-ibm-watson-tone-analyzer")]
    MarketplaceIbmWatsonToneAnalyzer,
    #[serde(rename = "marketplace-icehook-systems-scout")]
    #[display("marketplace-icehook-systems-scout")]
    MarketplaceIcehookSystemsScout,
    #[serde(rename = "marketplace-infogroup-dataaxle-bizinfo")]
    #[display("marketplace-infogroup-dataaxle-bizinfo")]
    MarketplaceInfogroupDataaxleBizinfo,
    #[serde(rename = "marketplace-keen-io-contact-center-analytics")]
    #[display("marketplace-keen-io-contact-center-analytics")]
    MarketplaceKeenIoContactCenterAnalytics,
    #[serde(rename = "marketplace-marchex-cleancall")]
    #[display("marketplace-marchex-cleancall")]
    MarketplaceMarchexCleancall,
    #[serde(rename = "marketplace-marchex-sentiment-analysis-for-sms")]
    #[display("marketplace-marchex-sentiment-analysis-for-sms")]
    MarketplaceMarchexSentimentAnalysisForSms,
    #[serde(rename = "marketplace-marketplace-nextcaller-social-id")]
    #[display("marketplace-marketplace-nextcaller-social-id")]
    MarketplaceMarketplaceNextcallerSocialId,
    #[serde(rename = "marketplace-mobile-commons-opt-out-classifier")]
    #[display("marketplace-mobile-commons-opt-out-classifier")]
    MarketplaceMobileCommonsOptOutClassifier,
    #[serde(rename = "marketplace-nexiwave-voicemail-to-text")]
    #[display("marketplace-nexiwave-voicemail-to-text")]
    MarketplaceNexiwaveVoicemailToText,
    #[serde(rename = "marketplace-nextcaller-advanced-caller-identification")]
    #[display("marketplace-nextcaller-advanced-caller-identification")]
    MarketplaceNextcallerAdvancedCallerIdentification,
    #[serde(rename = "marketplace-nomorobo-spam-score")]
    #[display("marketplace-nomorobo-spam-score")]
    MarketplaceNomoroboSpamScore,
    #[serde(rename = "marketplace-payfone-tcpa-compliance")]
    #[display("marketplace-payfone-tcpa-compliance")]
    MarketplacePayfoneTcpaCompliance,
    #[serde(rename = "marketplace-remeeting-automatic-speech-recognition")]
    #[display("marketplace-remeeting-automatic-speech-recognition")]
    MarketplaceRemeetingAutomaticSpeechRecognition,
    #[serde(rename = "marketplace-tcpa-defense-solutions-blacklist-feed")]
    #[display("marketplace-tcpa-defense-solutions-blacklist-feed")]
    MarketplaceTcpaDefenseSolutionsBlacklistFeed,
    #[serde(rename = "marketplace-telo-opencnam")]
    #[display("marketplace-telo-opencnam")]
    MarketplaceTeloOpencnam,
    #[serde(rename = "marketplace-truecnam-true-spam")]
    #[display("marketplace-truecnam-true-spam")]
    MarketplaceTruecnamTrueSpam,
    #[serde(rename = "marketplace-twilio-caller-name-lookup-us")]
    #[display("marketplace-twilio-caller-name-lookup-us")]
    MarketplaceTwilioCallerNameLookupUs,
    #[serde(rename = "marketplace-twilio-carrier-information-lookup")]
    #[display("marketplace-twilio-carrier-information-lookup")]
    MarketplaceTwilioCarrierInformationLookup,
    #[serde(rename = "marketplace-voicebase-pci")]
    #[display("marketplace-voicebase-pci")]
    MarketplaceVoicebasePci,
    #[serde(rename = "marketplace-voicebase-transcription")]
    #[display("marketplace-voicebase-transcription")]
    MarketplaceVoicebaseTranscription,
    #[serde(rename = "marketplace-voicebase-transcription-custom-vocabulary")]
    #[display("marketplace-voicebase-transcription-custom-vocabulary")]
    MarketplaceVoicebaseTranscriptionCustomVocabulary,
    #[serde(rename = "marketplace-whitepages-pro-caller-identification")]
    #[display("marketplace-whitepages-pro-caller-identification")]
    MarketplaceWhitepagesProCallerIdentification,
    #[serde(rename = "marketplace-whitepages-pro-phone-intelligence")]
    #[display("marketplace-whitepages-pro-phone-intelligence")]
    MarketplaceWhitepagesProPhoneIntelligence,
    #[serde(rename = "marketplace-whitepages-pro-phone-reputation")]
    #[display("marketplace-whitepages-pro-phone-reputation")]
    MarketplaceWhitepagesProPhoneReputation,
    #[serde(rename = "marketplace-wolfarm-spoken-results")]
    #[display("marketplace-wolfarm-spoken-results")]
    MarketplaceWolfarmSpokenResults,
    #[serde(rename = "marketplace-wolfram-short-answer")]
    #[display("marketplace-wolfram-short-answer")]
    MarketplaceWolframShortAnswer,
    #[serde(rename = "marketplace-ytica-contact-center-reporting-analytics")]
    #[display("marketplace-ytica-contact-center-reporting-analytics")]
    MarketplaceYticaContactCenterReportingAnalytics,
    #[serde(rename = "mediastorage")]
    #[display("mediastorage")]
    Mediastorage,
    #[serde(rename = "mms")]
    #[display("mms")]
    Mms,
    #[serde(rename = "mms-inbound")]
    #[display("mms-inbound")]
    MmsInbound,
    #[serde(rename = "mms-inbound-longcode")]
    #[display("mms-inbound-longcode")]
    MmsInboundLongcode,
    #[serde(rename = "mms-inbound-shortcode")]
    #[display("mms-inbound-shortcode")]
    MmsInboundShortcode,
    #[serde(rename = "mms-messages-carrierfees")]
    #[display("mms-messages-carrierfees")]
    MmsMessagesCarrierfees,
    #[serde(rename = "mms-outbound")]
    #[display("mms-outbound")]
    MmsOutbound,
    #[serde(rename = "mms-outbound-longcode")]
    #[display("mms-outbound-longcode")]
    MmsOutboundLongcode,
    #[serde(rename = "mms-outbound-shortcode")]
    #[display("mms-outbound-shortcode")]
    MmsOutboundShortcode,
    #[serde(rename = "monitor-reads")]
    #[display("monitor-reads")]
    MonitorReads,
    #[serde(rename = "monitor-storage")]
    #[display("monitor-storage")]
    MonitorStorage,
    #[serde(rename = "monitor-writes")]
    #[display("monitor-writes")]
    MonitorWrites,
    #[serde(rename = "notify")]
    #[display("notify")]
    Notify,
    #[serde(rename = "notify-actions-attempts")]
    #[display("notify-actions-attempts")]
    NotifyActionsAttempts,
    #[serde(rename = "notify-channels")]
    #[display("notify-channels")]
    NotifyChannels,
    #[serde(rename = "number-format-lookups")]
    #[display("number-format-lookups")]
    NumberFormatLookups,
    #[serde(rename = "pchat")]
    #[display("pchat")]
    Pchat,
    #[serde(rename = "pchat-users")]
    #[display("pchat-users")]
    PchatUsers,
    #[serde(rename = "peer-to-peer-rooms-participant-minutes")]
    #[display("peer-to-peer-rooms-participant-minutes")]
    PeerToPeerRoomsParticipantMinutes,
    #[serde(rename = "pfax")]
    #[display("pfax")]
    Pfax,
    #[serde(rename = "pfax-minutes")]
    #[display("pfax-minutes")]
    PfaxMinutes,
    #[serde(rename = "pfax-minutes-inbound")]
    #[display("pfax-minutes-inbound")]
    PfaxMinutesInbound,
    #[serde(rename = "pfax-minutes-outbound")]
    #[display("pfax-minutes-outbound")]
    PfaxMinutesOutbound,
    #[serde(rename = "pfax-pages")]
    #[display("pfax-pages")]
    PfaxPages,
    #[serde(rename = "phonenumbers")]
    #[display("phonenumbers")]
    Phonenumbers,
    #[serde(rename = "phonenumbers-cps")]
    #[display("phonenumbers-cps")]
    PhonenumbersCps,
    #[serde(rename = "phonenumbers-emergency")]
    #[display("phonenumbers-emergency")]
    PhonenumbersEmergency,
    #[serde(rename = "phonenumbers-local")]
    #[display("phonenumbers-local")]
    PhonenumbersLocal,
    #[serde(rename = "phonenumbers-mobile")]
    #[display("phonenumbers-mobile")]
    PhonenumbersMobile,
    #[serde(rename = "phonenumbers-setups")]
    #[display("phonenumbers-setups")]
    PhonenumbersSetups,
    #[serde(rename = "phonenumbers-tollfree")]
    #[display("phonenumbers-tollfree")]
    PhonenumbersTollfree,
    #[serde(rename = "premiumsupport")]
    #[display("premiumsupport")]
    Premiumsupport,
    #[serde(rename = "proxy")]
    #[display("proxy")]
    Proxy,
    #[serde(rename = "proxy-active-sessions")]
    #[display("proxy-active-sessions")]
    ProxyActiveSessions,
    #[serde(rename = "pstnconnectivity")]
    #[display("pstnconnectivity")]
    Pstnconnectivity,
    #[serde(rename = "pv")]
    #[display("pv")]
    Pv,
    #[serde(rename = "pv-composition-media-downloaded")]
    #[display("pv-composition-media-downloaded")]
    PvCompositionMediaDownloaded,
    #[serde(rename = "pv-composition-media-encrypted")]
    #[display("pv-composition-media-encrypted")]
    PvCompositionMediaEncrypted,
    #[serde(rename = "pv-composition-media-stored")]
    #[display("pv-composition-media-stored")]
    PvCompositionMediaStored,
    #[serde(rename = "pv-composition-minutes")]
    #[display("pv-composition-minutes")]
    PvCompositionMinutes,
    #[serde(rename = "pv-recording-compositions")]
    #[display("pv-recording-compositions")]
    PvRecordingCompositions,
    #[serde(rename = "pv-room-participants")]
    #[display("pv-room-participants")]
    PvRoomParticipants,
    #[serde(rename = "pv-room-participants-au1")]
    #[display("pv-room-participants-au1")]
    PvRoomParticipantsAu1,
    #[serde(rename = "pv-room-participants-br1")]
    #[display("pv-room-participants-br1")]
    PvRoomParticipantsBr1,
    #[serde(rename = "pv-room-participants-ie1")]
    #[display("pv-room-participants-ie1")]
    PvRoomParticipantsIe1,
    #[serde(rename = "pv-room-participants-jp1")]
    #[display("pv-room-participants-jp1")]
    PvRoomParticipantsJp1,
    #[serde(rename = "pv-room-participants-sg1")]
    #[display("pv-room-participants-sg1")]
    PvRoomParticipantsSg1,
    #[serde(rename = "pv-room-participants-us1")]
    #[display("pv-room-participants-us1")]
    PvRoomParticipantsUs1,
    #[serde(rename = "pv-room-participants-us2")]
    #[display("pv-room-participants-us2")]
    PvRoomParticipantsUs2,
    #[serde(rename = "pv-rooms")]
    #[display("pv-rooms")]
    PvRooms,
    #[serde(rename = "pv-sip-endpoint-registrations")]
    #[display("pv-sip-endpoint-registrations")]
    PvSipEndpointRegistrations,
    #[serde(rename = "recordings")]
    #[display("recordings")]
    Recordings,
    #[serde(rename = "recordingstorage")]
    #[display("recordingstorage")]
    Recordingstorage,
    #[serde(rename = "rooms-group-bandwidth")]
    #[display("rooms-group-bandwidth")]
    RoomsGroupBandwidth,
    #[serde(rename = "rooms-group-minutes")]
    #[display("rooms-group-minutes")]
    RoomsGroupMinutes,
    #[serde(rename = "rooms-peer-to-peer-minutes")]
    #[display("rooms-peer-to-peer-minutes")]
    RoomsPeerToPeerMinutes,
    #[serde(rename = "shortcodes")]
    #[display("shortcodes")]
    Shortcodes,
    #[serde(rename = "shortcodes-customerowned")]
    #[display("shortcodes-customerowned")]
    ShortcodesCustomerowned,
    #[serde(rename = "shortcodes-mms-enablement")]
    #[display("shortcodes-mms-enablement")]
    ShortcodesMmsEnablement,
    #[serde(rename = "shortcodes-mps")]
    #[display("shortcodes-mps")]
    ShortcodesMps,
    #[serde(rename = "shortcodes-random")]
    #[display("shortcodes-random")]
    ShortcodesRandom,
    #[serde(rename = "shortcodes-uk")]
    #[display("shortcodes-uk")]
    ShortcodesUk,
    #[serde(rename = "shortcodes-vanity")]
    #[display("shortcodes-vanity")]
    ShortcodesVanity,
    #[serde(rename = "small-group-rooms")]
    #[display("small-group-rooms")]
    SmallGroupRooms,
    #[serde(rename = "small-group-rooms-data-track")]
    #[display("small-group-rooms-data-track")]
    SmallGroupRoomsDataTrack,
    #[serde(rename = "small-group-rooms-participant-minutes")]
    #[display("small-group-rooms-participant-minutes")]
    SmallGroupRoomsParticipantMinutes,
    #[serde(rename = "sms")]
    #[display("sms")]
    Sms,
    #[serde(rename = "sms-inbound")]
    #[display("sms-inbound")]
    SmsInbound,
    #[serde(rename = "sms-inbound-longcode")]
    #[display("sms-inbound-longcode")]
    SmsInboundLongcode,
    #[serde(rename = "sms-inbound-shortcode")]
    #[display("sms-inbound-shortcode")]
    SmsInboundShortcode,
    #[serde(rename = "sms-messages-carrierfees")]
    #[display("sms-messages-carrierfees")]
    SmsMessagesCarrierfees,
    #[serde(rename = "sms-messages-features")]
    #[display("sms-messages-features")]
    SmsMessagesFeatures,
    #[serde(rename = "sms-messages-features-senderid")]
    #[display("sms-messages-features-senderid")]
    SmsMessagesFeaturesSenderid,
    #[serde(rename = "sms-outbound")]
    #[display("sms-outbound")]
    SmsOutbound,
    #[serde(rename = "sms-outbound-content-inspection")]
    #[display("sms-outbound-content-inspection")]
    SmsOutboundContentInspection,
    #[serde(rename = "sms-outbound-longcode")]
    #[display("sms-outbound-longcode")]
    SmsOutboundLongcode,
    #[serde(rename = "sms-outbound-shortcode")]
    #[display("sms-outbound-shortcode")]
    SmsOutboundShortcode,
    #[serde(rename = "speech-recognition")]
    #[display("speech-recognition")]
    SpeechRecognition,
    #[serde(rename = "studio-engagements")]
    #[display("studio-engagements")]
    StudioEngagements,
    #[serde(rename = "sync")]
    #[display("sync")]
    Sync,
    #[serde(rename = "sync-actions")]
    #[display("sync-actions")]
    SyncActions,
    #[serde(rename = "sync-endpoint-hours")]
    #[display("sync-endpoint-hours")]
    SyncEndpointHours,
    #[serde(rename = "sync-endpoint-hours-above-daily-cap")]
    #[display("sync-endpoint-hours-above-daily-cap")]
    SyncEndpointHoursAboveDailyCap,
    #[serde(rename = "taskrouter-tasks")]
    #[display("taskrouter-tasks")]
    TaskrouterTasks,
    #[serde(rename = "totalprice")]
    #[display("totalprice")]
    Totalprice,
    #[serde(rename = "transcriptions")]
    #[display("transcriptions")]
    Transcriptions,
    #[serde(rename = "trunking-cps")]
    #[display("trunking-cps")]
    TrunkingCps,
    #[serde(rename = "trunking-emergency-calls")]
    #[display("trunking-emergency-calls")]
    TrunkingEmergencyCalls,
    #[serde(rename = "trunking-origination")]
    #[display("trunking-origination")]
    TrunkingOrigination,
    #[serde(rename = "trunking-origination-local")]
    #[display("trunking-origination-local")]
    TrunkingOriginationLocal,
    #[serde(rename = "trunking-origination-mobile")]
    #[display("trunking-origination-mobile")]
    TrunkingOriginationMobile,
    #[serde(rename = "trunking-origination-tollfree")]
    #[display("trunking-origination-tollfree")]
    TrunkingOriginationTollfree,
    #[serde(rename = "trunking-recordings")]
    #[display("trunking-recordings")]
    TrunkingRecordings,
    #[serde(rename = "trunking-secure")]
    #[display("trunking-secure")]
    TrunkingSecure,
    #[serde(rename = "trunking-termination")]
    #[display("trunking-termination")]
    TrunkingTermination,
    #[serde(rename = "turnmegabytes")]
    #[display("turnmegabytes")]
    Turnmegabytes,
    #[serde(rename = "turnmegabytes-australia")]
    #[display("turnmegabytes-australia")]
    TurnmegabytesAustralia,
    #[serde(rename = "turnmegabytes-brasil")]
    #[display("turnmegabytes-brasil")]
    TurnmegabytesBrasil,
    #[serde(rename = "turnmegabytes-germany")]
    #[display("turnmegabytes-germany")]
    TurnmegabytesGermany,
    #[serde(rename = "turnmegabytes-india")]
    #[display("turnmegabytes-india")]
    TurnmegabytesIndia,
    #[serde(rename = "turnmegabytes-ireland")]
    #[display("turnmegabytes-ireland")]
    TurnmegabytesIreland,
    #[serde(rename = "turnmegabytes-japan")]
    #[display("turnmegabytes-japan")]
    TurnmegabytesJapan,
    #[serde(rename = "turnmegabytes-singapore")]
    #[display("turnmegabytes-singapore")]
    TurnmegabytesSingapore,
    #[serde(rename = "turnmegabytes-useast")]
    #[display("turnmegabytes-useast")]
    TurnmegabytesUseast,
    #[serde(rename = "turnmegabytes-uswest")]
    #[display("turnmegabytes-uswest")]
    TurnmegabytesUswest,
    #[serde(rename = "twilio-interconnect")]
    #[display("twilio-interconnect")]
    TwilioInterconnect,
    #[serde(rename = "verify-push")]
    #[display("verify-push")]
    VerifyPush,
    #[serde(rename = "verify-totp")]
    #[display("verify-totp")]
    VerifyTotp,
    #[serde(rename = "verify-whatsapp-conversations-business-initiated")]
    #[display("verify-whatsapp-conversations-business-initiated")]
    VerifyWhatsappConversationsBusinessInitiated,
    #[serde(rename = "video-recordings")]
    #[display("video-recordings")]
    VideoRecordings,
    #[serde(rename = "virtual-agent")]
    #[display("virtual-agent")]
    VirtualAgent,
    #[serde(rename = "voice-insights")]
    #[display("voice-insights")]
    VoiceInsights,
    #[serde(rename = "voice-insights-client-insights-on-demand-minute")]
    #[display("voice-insights-client-insights-on-demand-minute")]
    VoiceInsightsClientInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-ptsn-insights-on-demand-minute")]
    #[display("voice-insights-ptsn-insights-on-demand-minute")]
    VoiceInsightsPtsnInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-interface-insights-on-demand-minute")]
    #[display("voice-insights-sip-interface-insights-on-demand-minute")]
    VoiceInsightsSipInterfaceInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-trunking-insights-on-demand-minute")]
    #[display("voice-insights-sip-trunking-insights-on-demand-minute")]
    VoiceInsightsSipTrunkingInsightsOnDemandMinute,
    #[serde(rename = "wireless")]
    #[display("wireless")]
    Wireless,
    #[serde(rename = "wireless-orders")]
    #[display("wireless-orders")]
    WirelessOrders,
    #[serde(rename = "wireless-orders-artwork")]
    #[display("wireless-orders-artwork")]
    WirelessOrdersArtwork,
    #[serde(rename = "wireless-orders-bulk")]
    #[display("wireless-orders-bulk")]
    WirelessOrdersBulk,
    #[serde(rename = "wireless-orders-esim")]
    #[display("wireless-orders-esim")]
    WirelessOrdersEsim,
    #[serde(rename = "wireless-orders-starter")]
    #[display("wireless-orders-starter")]
    WirelessOrdersStarter,
    #[serde(rename = "wireless-usage")]
    #[display("wireless-usage")]
    WirelessUsage,
    #[serde(rename = "wireless-usage-commands")]
    #[display("wireless-usage-commands")]
    WirelessUsageCommands,
    #[serde(rename = "wireless-usage-commands-africa")]
    #[display("wireless-usage-commands-africa")]
    WirelessUsageCommandsAfrica,
    #[serde(rename = "wireless-usage-commands-asia")]
    #[display("wireless-usage-commands-asia")]
    WirelessUsageCommandsAsia,
    #[serde(rename = "wireless-usage-commands-centralandsouthamerica")]
    #[display("wireless-usage-commands-centralandsouthamerica")]
    WirelessUsageCommandsCentralandsouthamerica,
    #[serde(rename = "wireless-usage-commands-europe")]
    #[display("wireless-usage-commands-europe")]
    WirelessUsageCommandsEurope,
    #[serde(rename = "wireless-usage-commands-home")]
    #[display("wireless-usage-commands-home")]
    WirelessUsageCommandsHome,
    #[serde(rename = "wireless-usage-commands-northamerica")]
    #[display("wireless-usage-commands-northamerica")]
    WirelessUsageCommandsNorthamerica,
    #[serde(rename = "wireless-usage-commands-oceania")]
    #[display("wireless-usage-commands-oceania")]
    WirelessUsageCommandsOceania,
    #[serde(rename = "wireless-usage-commands-roaming")]
    #[display("wireless-usage-commands-roaming")]
    WirelessUsageCommandsRoaming,
    #[serde(rename = "wireless-usage-data")]
    #[display("wireless-usage-data")]
    WirelessUsageData,
    #[serde(rename = "wireless-usage-data-africa")]
    #[display("wireless-usage-data-africa")]
    WirelessUsageDataAfrica,
    #[serde(rename = "wireless-usage-data-asia")]
    #[display("wireless-usage-data-asia")]
    WirelessUsageDataAsia,
    #[serde(rename = "wireless-usage-data-centralandsouthamerica")]
    #[display("wireless-usage-data-centralandsouthamerica")]
    WirelessUsageDataCentralandsouthamerica,
    #[serde(rename = "wireless-usage-data-custom-additionalmb")]
    #[display("wireless-usage-data-custom-additionalmb")]
    WirelessUsageDataCustomAdditionalmb,
    #[serde(rename = "wireless-usage-data-custom-first5mb")]
    #[display("wireless-usage-data-custom-first5mb")]
    WirelessUsageDataCustomFirst5Mb,
    #[serde(rename = "wireless-usage-data-domestic-roaming")]
    #[display("wireless-usage-data-domestic-roaming")]
    WirelessUsageDataDomesticRoaming,
    #[serde(rename = "wireless-usage-data-europe")]
    #[display("wireless-usage-data-europe")]
    WirelessUsageDataEurope,
    #[serde(rename = "wireless-usage-data-individual-additionalgb")]
    #[display("wireless-usage-data-individual-additionalgb")]
    WirelessUsageDataIndividualAdditionalgb,
    #[serde(rename = "wireless-usage-data-individual-firstgb")]
    #[display("wireless-usage-data-individual-firstgb")]
    WirelessUsageDataIndividualFirstgb,
    #[serde(rename = "wireless-usage-data-international-roaming-canada")]
    #[display("wireless-usage-data-international-roaming-canada")]
    WirelessUsageDataInternationalRoamingCanada,
    #[serde(rename = "wireless-usage-data-international-roaming-india")]
    #[display("wireless-usage-data-international-roaming-india")]
    WirelessUsageDataInternationalRoamingIndia,
    #[serde(rename = "wireless-usage-data-international-roaming-mexico")]
    #[display("wireless-usage-data-international-roaming-mexico")]
    WirelessUsageDataInternationalRoamingMexico,
    #[serde(rename = "wireless-usage-data-northamerica")]
    #[display("wireless-usage-data-northamerica")]
    WirelessUsageDataNorthamerica,
    #[serde(rename = "wireless-usage-data-oceania")]
    #[display("wireless-usage-data-oceania")]
    WirelessUsageDataOceania,
    #[serde(rename = "wireless-usage-data-pooled")]
    #[display("wireless-usage-data-pooled")]
    WirelessUsageDataPooled,
    #[serde(rename = "wireless-usage-data-pooled-downlink")]
    #[display("wireless-usage-data-pooled-downlink")]
    WirelessUsageDataPooledDownlink,
    #[serde(rename = "wireless-usage-data-pooled-uplink")]
    #[display("wireless-usage-data-pooled-uplink")]
    WirelessUsageDataPooledUplink,
    #[serde(rename = "wireless-usage-mrc")]
    #[display("wireless-usage-mrc")]
    WirelessUsageMrc,
    #[serde(rename = "wireless-usage-mrc-custom")]
    #[display("wireless-usage-mrc-custom")]
    WirelessUsageMrcCustom,
    #[serde(rename = "wireless-usage-mrc-individual")]
    #[display("wireless-usage-mrc-individual")]
    WirelessUsageMrcIndividual,
    #[serde(rename = "wireless-usage-mrc-pooled")]
    #[display("wireless-usage-mrc-pooled")]
    WirelessUsageMrcPooled,
    #[serde(rename = "wireless-usage-mrc-suspended")]
    #[display("wireless-usage-mrc-suspended")]
    WirelessUsageMrcSuspended,
    #[serde(rename = "wireless-usage-sms")]
    #[display("wireless-usage-sms")]
    WirelessUsageSms,
    #[serde(rename = "wireless-usage-voice")]
    #[display("wireless-usage-voice")]
    WirelessUsageVoice,
}

#[doc = "The HTTP method we use to call `callback_url`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountUsageUsageTrigger {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that the \
             trigger monitors."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The API version used to create the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    #[doc = "The HTTP method we use to call `callback_url`. Can be: `GET` or `POST`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub callback_method: Option<CallbackMethod>,
    #[doc = "The URL we call using the `callback_method` when the trigger fires."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub callback_url: Option<String>,
    #[doc = "The current value of the field the trigger is watching."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub current_value: Option<String>,
    #[doc = "The date and time in GMT that the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the trigger was last fired specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_fired: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The date and time in GMT that the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_updated: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The string that you assigned to describe the trigger."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub recurring: Option<UsageTriggerEnumRecurring>,
    #[doc = "The unique string that that we created to identify the UsageTrigger resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub trigger_by: Option<UsageTriggerEnumTriggerField>,
    #[doc = "The value at which the trigger will fire.  Must be a positive, numeric value."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub trigger_value: Option<String>,
    #[doc = "The URI of the resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_category: Option<UsageTriggerEnumUsageCategory>,
    #[doc = "The URI of the [UsageRecord](https://www.twilio.com/docs/usage/api/usage-record) resource this trigger watches, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_record_uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountUsageUsageTrigger {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountUsageUsageTrigger {
    const LENGTH: usize = 16;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(callback_method) = &self.callback_method {
                format!("{callback_method:?}")
            } else {
                String::new()
            },
            if let Some(callback_url) = &self.callback_url {
                format!("{callback_url:?}")
            } else {
                String::new()
            },
            if let Some(current_value) = &self.current_value {
                format!("{current_value:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(date_fired) = &self.date_fired {
                format!("{date_fired:?}")
            } else {
                String::new()
            },
            if let Some(date_updated) = &self.date_updated {
                format!("{date_updated:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(recurring) = &self.recurring {
                format!("{recurring:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(trigger_by) = &self.trigger_by {
                format!("{trigger_by:?}")
            } else {
                String::new()
            },
            if let Some(trigger_value) = &self.trigger_value {
                format!("{trigger_value:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
            if let Some(usage_category) = &self.usage_category {
                format!("{usage_category:?}")
            } else {
                String::new()
            },
            if let Some(usage_record_uri) = &self.usage_record_uri {
                format!("{usage_record_uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "callback_method".to_string(),
            "callback_url".to_string(),
            "current_value".to_string(),
            "date_created".to_string(),
            "date_fired".to_string(),
            "date_updated".to_string(),
            "friendly_name".to_string(),
            "recurring".to_string(),
            "sid".to_string(),
            "trigger_by".to_string(),
            "trigger_value".to_string(),
            "uri".to_string(),
            "usage_category".to_string(),
            "usage_record_uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UsageTriggerEnumUsageCategory {
    #[serde(rename = "a2p-registration-fees")]
    #[display("a2p-registration-fees")]
    A2PRegistrationFees,
    #[serde(rename = "agent-conference")]
    #[display("agent-conference")]
    AgentConference,
    #[serde(rename = "amazon-polly")]
    #[display("amazon-polly")]
    AmazonPolly,
    #[serde(rename = "answering-machine-detection")]
    #[display("answering-machine-detection")]
    AnsweringMachineDetection,
    #[serde(rename = "authy-authentications")]
    #[display("authy-authentications")]
    AuthyAuthentications,
    #[serde(rename = "authy-calls-outbound")]
    #[display("authy-calls-outbound")]
    AuthyCallsOutbound,
    #[serde(rename = "authy-monthly-fees")]
    #[display("authy-monthly-fees")]
    AuthyMonthlyFees,
    #[serde(rename = "authy-phone-intelligence")]
    #[display("authy-phone-intelligence")]
    AuthyPhoneIntelligence,
    #[serde(rename = "authy-phone-verifications")]
    #[display("authy-phone-verifications")]
    AuthyPhoneVerifications,
    #[serde(rename = "authy-sms-outbound")]
    #[display("authy-sms-outbound")]
    AuthySmsOutbound,
    #[serde(rename = "call-progess-events")]
    #[display("call-progess-events")]
    CallProgessEvents,
    #[serde(rename = "calleridlookups")]
    #[display("calleridlookups")]
    Calleridlookups,
    #[serde(rename = "calls")]
    #[display("calls")]
    Calls,
    #[serde(rename = "calls-client")]
    #[display("calls-client")]
    CallsClient,
    #[serde(rename = "calls-globalconference")]
    #[display("calls-globalconference")]
    CallsGlobalconference,
    #[serde(rename = "calls-inbound")]
    #[display("calls-inbound")]
    CallsInbound,
    #[serde(rename = "calls-inbound-local")]
    #[display("calls-inbound-local")]
    CallsInboundLocal,
    #[serde(rename = "calls-inbound-mobile")]
    #[display("calls-inbound-mobile")]
    CallsInboundMobile,
    #[serde(rename = "calls-inbound-tollfree")]
    #[display("calls-inbound-tollfree")]
    CallsInboundTollfree,
    #[serde(rename = "calls-outbound")]
    #[display("calls-outbound")]
    CallsOutbound,
    #[serde(rename = "calls-pay-verb-transactions")]
    #[display("calls-pay-verb-transactions")]
    CallsPayVerbTransactions,
    #[serde(rename = "calls-recordings")]
    #[display("calls-recordings")]
    CallsRecordings,
    #[serde(rename = "calls-sip")]
    #[display("calls-sip")]
    CallsSip,
    #[serde(rename = "calls-sip-inbound")]
    #[display("calls-sip-inbound")]
    CallsSipInbound,
    #[serde(rename = "calls-sip-outbound")]
    #[display("calls-sip-outbound")]
    CallsSipOutbound,
    #[serde(rename = "calls-transfers")]
    #[display("calls-transfers")]
    CallsTransfers,
    #[serde(rename = "carrier-lookups")]
    #[display("carrier-lookups")]
    CarrierLookups,
    #[serde(rename = "conversations")]
    #[display("conversations")]
    Conversations,
    #[serde(rename = "conversations-api-requests")]
    #[display("conversations-api-requests")]
    ConversationsApiRequests,
    #[serde(rename = "conversations-conversation-events")]
    #[display("conversations-conversation-events")]
    ConversationsConversationEvents,
    #[serde(rename = "conversations-endpoint-connectivity")]
    #[display("conversations-endpoint-connectivity")]
    ConversationsEndpointConnectivity,
    #[serde(rename = "conversations-events")]
    #[display("conversations-events")]
    ConversationsEvents,
    #[serde(rename = "conversations-participant-events")]
    #[display("conversations-participant-events")]
    ConversationsParticipantEvents,
    #[serde(rename = "conversations-participants")]
    #[display("conversations-participants")]
    ConversationsParticipants,
    #[serde(rename = "cps")]
    #[display("cps")]
    Cps,
    #[serde(rename = "flex-usage")]
    #[display("flex-usage")]
    FlexUsage,
    #[serde(rename = "fraud-lookups")]
    #[display("fraud-lookups")]
    FraudLookups,
    #[serde(rename = "group-rooms")]
    #[display("group-rooms")]
    GroupRooms,
    #[serde(rename = "group-rooms-data-track")]
    #[display("group-rooms-data-track")]
    GroupRoomsDataTrack,
    #[serde(rename = "group-rooms-encrypted-media-recorded")]
    #[display("group-rooms-encrypted-media-recorded")]
    GroupRoomsEncryptedMediaRecorded,
    #[serde(rename = "group-rooms-media-downloaded")]
    #[display("group-rooms-media-downloaded")]
    GroupRoomsMediaDownloaded,
    #[serde(rename = "group-rooms-media-recorded")]
    #[display("group-rooms-media-recorded")]
    GroupRoomsMediaRecorded,
    #[serde(rename = "group-rooms-media-routed")]
    #[display("group-rooms-media-routed")]
    GroupRoomsMediaRouted,
    #[serde(rename = "group-rooms-media-stored")]
    #[display("group-rooms-media-stored")]
    GroupRoomsMediaStored,
    #[serde(rename = "group-rooms-participant-minutes")]
    #[display("group-rooms-participant-minutes")]
    GroupRoomsParticipantMinutes,
    #[serde(rename = "group-rooms-recorded-minutes")]
    #[display("group-rooms-recorded-minutes")]
    GroupRoomsRecordedMinutes,
    #[serde(rename = "imp-v1-usage")]
    #[display("imp-v1-usage")]
    ImpUsage,
    #[serde(rename = "lookups")]
    #[display("lookups")]
    Lookups,
    #[serde(rename = "marketplace")]
    #[display("marketplace")]
    Marketplace,
    #[serde(rename = "marketplace-algorithmia-named-entity-recognition")]
    #[display("marketplace-algorithmia-named-entity-recognition")]
    MarketplaceAlgorithmiaNamedEntityRecognition,
    #[serde(rename = "marketplace-cadence-transcription")]
    #[display("marketplace-cadence-transcription")]
    MarketplaceCadenceTranscription,
    #[serde(rename = "marketplace-cadence-translation")]
    #[display("marketplace-cadence-translation")]
    MarketplaceCadenceTranslation,
    #[serde(rename = "marketplace-capio-speech-to-text")]
    #[display("marketplace-capio-speech-to-text")]
    MarketplaceCapioSpeechToText,
    #[serde(rename = "marketplace-convriza-ababa")]
    #[display("marketplace-convriza-ababa")]
    MarketplaceConvrizaAbaba,
    #[serde(rename = "marketplace-deepgram-phrase-detector")]
    #[display("marketplace-deepgram-phrase-detector")]
    MarketplaceDeepgramPhraseDetector,
    #[serde(rename = "marketplace-digital-segment-business-info")]
    #[display("marketplace-digital-segment-business-info")]
    MarketplaceDigitalSegmentBusinessInfo,
    #[serde(rename = "marketplace-facebook-offline-conversions")]
    #[display("marketplace-facebook-offline-conversions")]
    MarketplaceFacebookOfflineConversions,
    #[serde(rename = "marketplace-google-speech-to-text")]
    #[display("marketplace-google-speech-to-text")]
    MarketplaceGoogleSpeechToText,
    #[serde(rename = "marketplace-ibm-watson-message-insights")]
    #[display("marketplace-ibm-watson-message-insights")]
    MarketplaceIbmWatsonMessageInsights,
    #[serde(rename = "marketplace-ibm-watson-message-sentiment")]
    #[display("marketplace-ibm-watson-message-sentiment")]
    MarketplaceIbmWatsonMessageSentiment,
    #[serde(rename = "marketplace-ibm-watson-recording-analysis")]
    #[display("marketplace-ibm-watson-recording-analysis")]
    MarketplaceIbmWatsonRecordingAnalysis,
    #[serde(rename = "marketplace-ibm-watson-tone-analyzer")]
    #[display("marketplace-ibm-watson-tone-analyzer")]
    MarketplaceIbmWatsonToneAnalyzer,
    #[serde(rename = "marketplace-icehook-systems-scout")]
    #[display("marketplace-icehook-systems-scout")]
    MarketplaceIcehookSystemsScout,
    #[serde(rename = "marketplace-infogroup-dataaxle-bizinfo")]
    #[display("marketplace-infogroup-dataaxle-bizinfo")]
    MarketplaceInfogroupDataaxleBizinfo,
    #[serde(rename = "marketplace-keen-io-contact-center-analytics")]
    #[display("marketplace-keen-io-contact-center-analytics")]
    MarketplaceKeenIoContactCenterAnalytics,
    #[serde(rename = "marketplace-marchex-cleancall")]
    #[display("marketplace-marchex-cleancall")]
    MarketplaceMarchexCleancall,
    #[serde(rename = "marketplace-marchex-sentiment-analysis-for-sms")]
    #[display("marketplace-marchex-sentiment-analysis-for-sms")]
    MarketplaceMarchexSentimentAnalysisForSms,
    #[serde(rename = "marketplace-marketplace-nextcaller-social-id")]
    #[display("marketplace-marketplace-nextcaller-social-id")]
    MarketplaceMarketplaceNextcallerSocialId,
    #[serde(rename = "marketplace-mobile-commons-opt-out-classifier")]
    #[display("marketplace-mobile-commons-opt-out-classifier")]
    MarketplaceMobileCommonsOptOutClassifier,
    #[serde(rename = "marketplace-nexiwave-voicemail-to-text")]
    #[display("marketplace-nexiwave-voicemail-to-text")]
    MarketplaceNexiwaveVoicemailToText,
    #[serde(rename = "marketplace-nextcaller-advanced-caller-identification")]
    #[display("marketplace-nextcaller-advanced-caller-identification")]
    MarketplaceNextcallerAdvancedCallerIdentification,
    #[serde(rename = "marketplace-nomorobo-spam-score")]
    #[display("marketplace-nomorobo-spam-score")]
    MarketplaceNomoroboSpamScore,
    #[serde(rename = "marketplace-payfone-tcpa-compliance")]
    #[display("marketplace-payfone-tcpa-compliance")]
    MarketplacePayfoneTcpaCompliance,
    #[serde(rename = "marketplace-remeeting-automatic-speech-recognition")]
    #[display("marketplace-remeeting-automatic-speech-recognition")]
    MarketplaceRemeetingAutomaticSpeechRecognition,
    #[serde(rename = "marketplace-tcpa-defense-solutions-blacklist-feed")]
    #[display("marketplace-tcpa-defense-solutions-blacklist-feed")]
    MarketplaceTcpaDefenseSolutionsBlacklistFeed,
    #[serde(rename = "marketplace-telo-opencnam")]
    #[display("marketplace-telo-opencnam")]
    MarketplaceTeloOpencnam,
    #[serde(rename = "marketplace-truecnam-true-spam")]
    #[display("marketplace-truecnam-true-spam")]
    MarketplaceTruecnamTrueSpam,
    #[serde(rename = "marketplace-twilio-caller-name-lookup-us")]
    #[display("marketplace-twilio-caller-name-lookup-us")]
    MarketplaceTwilioCallerNameLookupUs,
    #[serde(rename = "marketplace-twilio-carrier-information-lookup")]
    #[display("marketplace-twilio-carrier-information-lookup")]
    MarketplaceTwilioCarrierInformationLookup,
    #[serde(rename = "marketplace-voicebase-pci")]
    #[display("marketplace-voicebase-pci")]
    MarketplaceVoicebasePci,
    #[serde(rename = "marketplace-voicebase-transcription")]
    #[display("marketplace-voicebase-transcription")]
    MarketplaceVoicebaseTranscription,
    #[serde(rename = "marketplace-voicebase-transcription-custom-vocabulary")]
    #[display("marketplace-voicebase-transcription-custom-vocabulary")]
    MarketplaceVoicebaseTranscriptionCustomVocabulary,
    #[serde(rename = "marketplace-whitepages-pro-caller-identification")]
    #[display("marketplace-whitepages-pro-caller-identification")]
    MarketplaceWhitepagesProCallerIdentification,
    #[serde(rename = "marketplace-whitepages-pro-phone-intelligence")]
    #[display("marketplace-whitepages-pro-phone-intelligence")]
    MarketplaceWhitepagesProPhoneIntelligence,
    #[serde(rename = "marketplace-whitepages-pro-phone-reputation")]
    #[display("marketplace-whitepages-pro-phone-reputation")]
    MarketplaceWhitepagesProPhoneReputation,
    #[serde(rename = "marketplace-wolfarm-spoken-results")]
    #[display("marketplace-wolfarm-spoken-results")]
    MarketplaceWolfarmSpokenResults,
    #[serde(rename = "marketplace-wolfram-short-answer")]
    #[display("marketplace-wolfram-short-answer")]
    MarketplaceWolframShortAnswer,
    #[serde(rename = "marketplace-ytica-contact-center-reporting-analytics")]
    #[display("marketplace-ytica-contact-center-reporting-analytics")]
    MarketplaceYticaContactCenterReportingAnalytics,
    #[serde(rename = "mediastorage")]
    #[display("mediastorage")]
    Mediastorage,
    #[serde(rename = "mms")]
    #[display("mms")]
    Mms,
    #[serde(rename = "mms-inbound")]
    #[display("mms-inbound")]
    MmsInbound,
    #[serde(rename = "mms-inbound-longcode")]
    #[display("mms-inbound-longcode")]
    MmsInboundLongcode,
    #[serde(rename = "mms-inbound-shortcode")]
    #[display("mms-inbound-shortcode")]
    MmsInboundShortcode,
    #[serde(rename = "mms-messages-carrierfees")]
    #[display("mms-messages-carrierfees")]
    MmsMessagesCarrierfees,
    #[serde(rename = "mms-outbound")]
    #[display("mms-outbound")]
    MmsOutbound,
    #[serde(rename = "mms-outbound-longcode")]
    #[display("mms-outbound-longcode")]
    MmsOutboundLongcode,
    #[serde(rename = "mms-outbound-shortcode")]
    #[display("mms-outbound-shortcode")]
    MmsOutboundShortcode,
    #[serde(rename = "monitor-reads")]
    #[display("monitor-reads")]
    MonitorReads,
    #[serde(rename = "monitor-storage")]
    #[display("monitor-storage")]
    MonitorStorage,
    #[serde(rename = "monitor-writes")]
    #[display("monitor-writes")]
    MonitorWrites,
    #[serde(rename = "notify")]
    #[display("notify")]
    Notify,
    #[serde(rename = "notify-actions-attempts")]
    #[display("notify-actions-attempts")]
    NotifyActionsAttempts,
    #[serde(rename = "notify-channels")]
    #[display("notify-channels")]
    NotifyChannels,
    #[serde(rename = "number-format-lookups")]
    #[display("number-format-lookups")]
    NumberFormatLookups,
    #[serde(rename = "pchat")]
    #[display("pchat")]
    Pchat,
    #[serde(rename = "pchat-users")]
    #[display("pchat-users")]
    PchatUsers,
    #[serde(rename = "peer-to-peer-rooms-participant-minutes")]
    #[display("peer-to-peer-rooms-participant-minutes")]
    PeerToPeerRoomsParticipantMinutes,
    #[serde(rename = "pfax")]
    #[display("pfax")]
    Pfax,
    #[serde(rename = "pfax-minutes")]
    #[display("pfax-minutes")]
    PfaxMinutes,
    #[serde(rename = "pfax-minutes-inbound")]
    #[display("pfax-minutes-inbound")]
    PfaxMinutesInbound,
    #[serde(rename = "pfax-minutes-outbound")]
    #[display("pfax-minutes-outbound")]
    PfaxMinutesOutbound,
    #[serde(rename = "pfax-pages")]
    #[display("pfax-pages")]
    PfaxPages,
    #[serde(rename = "phonenumbers")]
    #[display("phonenumbers")]
    Phonenumbers,
    #[serde(rename = "phonenumbers-cps")]
    #[display("phonenumbers-cps")]
    PhonenumbersCps,
    #[serde(rename = "phonenumbers-emergency")]
    #[display("phonenumbers-emergency")]
    PhonenumbersEmergency,
    #[serde(rename = "phonenumbers-local")]
    #[display("phonenumbers-local")]
    PhonenumbersLocal,
    #[serde(rename = "phonenumbers-mobile")]
    #[display("phonenumbers-mobile")]
    PhonenumbersMobile,
    #[serde(rename = "phonenumbers-setups")]
    #[display("phonenumbers-setups")]
    PhonenumbersSetups,
    #[serde(rename = "phonenumbers-tollfree")]
    #[display("phonenumbers-tollfree")]
    PhonenumbersTollfree,
    #[serde(rename = "premiumsupport")]
    #[display("premiumsupport")]
    Premiumsupport,
    #[serde(rename = "proxy")]
    #[display("proxy")]
    Proxy,
    #[serde(rename = "proxy-active-sessions")]
    #[display("proxy-active-sessions")]
    ProxyActiveSessions,
    #[serde(rename = "pstnconnectivity")]
    #[display("pstnconnectivity")]
    Pstnconnectivity,
    #[serde(rename = "pv")]
    #[display("pv")]
    Pv,
    #[serde(rename = "pv-composition-media-downloaded")]
    #[display("pv-composition-media-downloaded")]
    PvCompositionMediaDownloaded,
    #[serde(rename = "pv-composition-media-encrypted")]
    #[display("pv-composition-media-encrypted")]
    PvCompositionMediaEncrypted,
    #[serde(rename = "pv-composition-media-stored")]
    #[display("pv-composition-media-stored")]
    PvCompositionMediaStored,
    #[serde(rename = "pv-composition-minutes")]
    #[display("pv-composition-minutes")]
    PvCompositionMinutes,
    #[serde(rename = "pv-recording-compositions")]
    #[display("pv-recording-compositions")]
    PvRecordingCompositions,
    #[serde(rename = "pv-room-participants")]
    #[display("pv-room-participants")]
    PvRoomParticipants,
    #[serde(rename = "pv-room-participants-au1")]
    #[display("pv-room-participants-au1")]
    PvRoomParticipantsAu1,
    #[serde(rename = "pv-room-participants-br1")]
    #[display("pv-room-participants-br1")]
    PvRoomParticipantsBr1,
    #[serde(rename = "pv-room-participants-ie1")]
    #[display("pv-room-participants-ie1")]
    PvRoomParticipantsIe1,
    #[serde(rename = "pv-room-participants-jp1")]
    #[display("pv-room-participants-jp1")]
    PvRoomParticipantsJp1,
    #[serde(rename = "pv-room-participants-sg1")]
    #[display("pv-room-participants-sg1")]
    PvRoomParticipantsSg1,
    #[serde(rename = "pv-room-participants-us1")]
    #[display("pv-room-participants-us1")]
    PvRoomParticipantsUs1,
    #[serde(rename = "pv-room-participants-us2")]
    #[display("pv-room-participants-us2")]
    PvRoomParticipantsUs2,
    #[serde(rename = "pv-rooms")]
    #[display("pv-rooms")]
    PvRooms,
    #[serde(rename = "pv-sip-endpoint-registrations")]
    #[display("pv-sip-endpoint-registrations")]
    PvSipEndpointRegistrations,
    #[serde(rename = "recordings")]
    #[display("recordings")]
    Recordings,
    #[serde(rename = "recordingstorage")]
    #[display("recordingstorage")]
    Recordingstorage,
    #[serde(rename = "rooms-group-bandwidth")]
    #[display("rooms-group-bandwidth")]
    RoomsGroupBandwidth,
    #[serde(rename = "rooms-group-minutes")]
    #[display("rooms-group-minutes")]
    RoomsGroupMinutes,
    #[serde(rename = "rooms-peer-to-peer-minutes")]
    #[display("rooms-peer-to-peer-minutes")]
    RoomsPeerToPeerMinutes,
    #[serde(rename = "shortcodes")]
    #[display("shortcodes")]
    Shortcodes,
    #[serde(rename = "shortcodes-customerowned")]
    #[display("shortcodes-customerowned")]
    ShortcodesCustomerowned,
    #[serde(rename = "shortcodes-mms-enablement")]
    #[display("shortcodes-mms-enablement")]
    ShortcodesMmsEnablement,
    #[serde(rename = "shortcodes-mps")]
    #[display("shortcodes-mps")]
    ShortcodesMps,
    #[serde(rename = "shortcodes-random")]
    #[display("shortcodes-random")]
    ShortcodesRandom,
    #[serde(rename = "shortcodes-uk")]
    #[display("shortcodes-uk")]
    ShortcodesUk,
    #[serde(rename = "shortcodes-vanity")]
    #[display("shortcodes-vanity")]
    ShortcodesVanity,
    #[serde(rename = "small-group-rooms")]
    #[display("small-group-rooms")]
    SmallGroupRooms,
    #[serde(rename = "small-group-rooms-data-track")]
    #[display("small-group-rooms-data-track")]
    SmallGroupRoomsDataTrack,
    #[serde(rename = "small-group-rooms-participant-minutes")]
    #[display("small-group-rooms-participant-minutes")]
    SmallGroupRoomsParticipantMinutes,
    #[serde(rename = "sms")]
    #[display("sms")]
    Sms,
    #[serde(rename = "sms-inbound")]
    #[display("sms-inbound")]
    SmsInbound,
    #[serde(rename = "sms-inbound-longcode")]
    #[display("sms-inbound-longcode")]
    SmsInboundLongcode,
    #[serde(rename = "sms-inbound-shortcode")]
    #[display("sms-inbound-shortcode")]
    SmsInboundShortcode,
    #[serde(rename = "sms-messages-carrierfees")]
    #[display("sms-messages-carrierfees")]
    SmsMessagesCarrierfees,
    #[serde(rename = "sms-messages-features")]
    #[display("sms-messages-features")]
    SmsMessagesFeatures,
    #[serde(rename = "sms-messages-features-senderid")]
    #[display("sms-messages-features-senderid")]
    SmsMessagesFeaturesSenderid,
    #[serde(rename = "sms-outbound")]
    #[display("sms-outbound")]
    SmsOutbound,
    #[serde(rename = "sms-outbound-content-inspection")]
    #[display("sms-outbound-content-inspection")]
    SmsOutboundContentInspection,
    #[serde(rename = "sms-outbound-longcode")]
    #[display("sms-outbound-longcode")]
    SmsOutboundLongcode,
    #[serde(rename = "sms-outbound-shortcode")]
    #[display("sms-outbound-shortcode")]
    SmsOutboundShortcode,
    #[serde(rename = "speech-recognition")]
    #[display("speech-recognition")]
    SpeechRecognition,
    #[serde(rename = "studio-engagements")]
    #[display("studio-engagements")]
    StudioEngagements,
    #[serde(rename = "sync")]
    #[display("sync")]
    Sync,
    #[serde(rename = "sync-actions")]
    #[display("sync-actions")]
    SyncActions,
    #[serde(rename = "sync-endpoint-hours")]
    #[display("sync-endpoint-hours")]
    SyncEndpointHours,
    #[serde(rename = "sync-endpoint-hours-above-daily-cap")]
    #[display("sync-endpoint-hours-above-daily-cap")]
    SyncEndpointHoursAboveDailyCap,
    #[serde(rename = "taskrouter-tasks")]
    #[display("taskrouter-tasks")]
    TaskrouterTasks,
    #[serde(rename = "totalprice")]
    #[display("totalprice")]
    Totalprice,
    #[serde(rename = "transcriptions")]
    #[display("transcriptions")]
    Transcriptions,
    #[serde(rename = "trunking-cps")]
    #[display("trunking-cps")]
    TrunkingCps,
    #[serde(rename = "trunking-emergency-calls")]
    #[display("trunking-emergency-calls")]
    TrunkingEmergencyCalls,
    #[serde(rename = "trunking-origination")]
    #[display("trunking-origination")]
    TrunkingOrigination,
    #[serde(rename = "trunking-origination-local")]
    #[display("trunking-origination-local")]
    TrunkingOriginationLocal,
    #[serde(rename = "trunking-origination-mobile")]
    #[display("trunking-origination-mobile")]
    TrunkingOriginationMobile,
    #[serde(rename = "trunking-origination-tollfree")]
    #[display("trunking-origination-tollfree")]
    TrunkingOriginationTollfree,
    #[serde(rename = "trunking-recordings")]
    #[display("trunking-recordings")]
    TrunkingRecordings,
    #[serde(rename = "trunking-secure")]
    #[display("trunking-secure")]
    TrunkingSecure,
    #[serde(rename = "trunking-termination")]
    #[display("trunking-termination")]
    TrunkingTermination,
    #[serde(rename = "turnmegabytes")]
    #[display("turnmegabytes")]
    Turnmegabytes,
    #[serde(rename = "turnmegabytes-australia")]
    #[display("turnmegabytes-australia")]
    TurnmegabytesAustralia,
    #[serde(rename = "turnmegabytes-brasil")]
    #[display("turnmegabytes-brasil")]
    TurnmegabytesBrasil,
    #[serde(rename = "turnmegabytes-germany")]
    #[display("turnmegabytes-germany")]
    TurnmegabytesGermany,
    #[serde(rename = "turnmegabytes-india")]
    #[display("turnmegabytes-india")]
    TurnmegabytesIndia,
    #[serde(rename = "turnmegabytes-ireland")]
    #[display("turnmegabytes-ireland")]
    TurnmegabytesIreland,
    #[serde(rename = "turnmegabytes-japan")]
    #[display("turnmegabytes-japan")]
    TurnmegabytesJapan,
    #[serde(rename = "turnmegabytes-singapore")]
    #[display("turnmegabytes-singapore")]
    TurnmegabytesSingapore,
    #[serde(rename = "turnmegabytes-useast")]
    #[display("turnmegabytes-useast")]
    TurnmegabytesUseast,
    #[serde(rename = "turnmegabytes-uswest")]
    #[display("turnmegabytes-uswest")]
    TurnmegabytesUswest,
    #[serde(rename = "twilio-interconnect")]
    #[display("twilio-interconnect")]
    TwilioInterconnect,
    #[serde(rename = "verify-push")]
    #[display("verify-push")]
    VerifyPush,
    #[serde(rename = "verify-totp")]
    #[display("verify-totp")]
    VerifyTotp,
    #[serde(rename = "verify-whatsapp-conversations-business-initiated")]
    #[display("verify-whatsapp-conversations-business-initiated")]
    VerifyWhatsappConversationsBusinessInitiated,
    #[serde(rename = "video-recordings")]
    #[display("video-recordings")]
    VideoRecordings,
    #[serde(rename = "virtual-agent")]
    #[display("virtual-agent")]
    VirtualAgent,
    #[serde(rename = "voice-insights")]
    #[display("voice-insights")]
    VoiceInsights,
    #[serde(rename = "voice-insights-client-insights-on-demand-minute")]
    #[display("voice-insights-client-insights-on-demand-minute")]
    VoiceInsightsClientInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-ptsn-insights-on-demand-minute")]
    #[display("voice-insights-ptsn-insights-on-demand-minute")]
    VoiceInsightsPtsnInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-interface-insights-on-demand-minute")]
    #[display("voice-insights-sip-interface-insights-on-demand-minute")]
    VoiceInsightsSipInterfaceInsightsOnDemandMinute,
    #[serde(rename = "voice-insights-sip-trunking-insights-on-demand-minute")]
    #[display("voice-insights-sip-trunking-insights-on-demand-minute")]
    VoiceInsightsSipTrunkingInsightsOnDemandMinute,
    #[serde(rename = "wireless")]
    #[display("wireless")]
    Wireless,
    #[serde(rename = "wireless-orders")]
    #[display("wireless-orders")]
    WirelessOrders,
    #[serde(rename = "wireless-orders-artwork")]
    #[display("wireless-orders-artwork")]
    WirelessOrdersArtwork,
    #[serde(rename = "wireless-orders-bulk")]
    #[display("wireless-orders-bulk")]
    WirelessOrdersBulk,
    #[serde(rename = "wireless-orders-esim")]
    #[display("wireless-orders-esim")]
    WirelessOrdersEsim,
    #[serde(rename = "wireless-orders-starter")]
    #[display("wireless-orders-starter")]
    WirelessOrdersStarter,
    #[serde(rename = "wireless-usage")]
    #[display("wireless-usage")]
    WirelessUsage,
    #[serde(rename = "wireless-usage-commands")]
    #[display("wireless-usage-commands")]
    WirelessUsageCommands,
    #[serde(rename = "wireless-usage-commands-africa")]
    #[display("wireless-usage-commands-africa")]
    WirelessUsageCommandsAfrica,
    #[serde(rename = "wireless-usage-commands-asia")]
    #[display("wireless-usage-commands-asia")]
    WirelessUsageCommandsAsia,
    #[serde(rename = "wireless-usage-commands-centralandsouthamerica")]
    #[display("wireless-usage-commands-centralandsouthamerica")]
    WirelessUsageCommandsCentralandsouthamerica,
    #[serde(rename = "wireless-usage-commands-europe")]
    #[display("wireless-usage-commands-europe")]
    WirelessUsageCommandsEurope,
    #[serde(rename = "wireless-usage-commands-home")]
    #[display("wireless-usage-commands-home")]
    WirelessUsageCommandsHome,
    #[serde(rename = "wireless-usage-commands-northamerica")]
    #[display("wireless-usage-commands-northamerica")]
    WirelessUsageCommandsNorthamerica,
    #[serde(rename = "wireless-usage-commands-oceania")]
    #[display("wireless-usage-commands-oceania")]
    WirelessUsageCommandsOceania,
    #[serde(rename = "wireless-usage-commands-roaming")]
    #[display("wireless-usage-commands-roaming")]
    WirelessUsageCommandsRoaming,
    #[serde(rename = "wireless-usage-data")]
    #[display("wireless-usage-data")]
    WirelessUsageData,
    #[serde(rename = "wireless-usage-data-africa")]
    #[display("wireless-usage-data-africa")]
    WirelessUsageDataAfrica,
    #[serde(rename = "wireless-usage-data-asia")]
    #[display("wireless-usage-data-asia")]
    WirelessUsageDataAsia,
    #[serde(rename = "wireless-usage-data-centralandsouthamerica")]
    #[display("wireless-usage-data-centralandsouthamerica")]
    WirelessUsageDataCentralandsouthamerica,
    #[serde(rename = "wireless-usage-data-custom-additionalmb")]
    #[display("wireless-usage-data-custom-additionalmb")]
    WirelessUsageDataCustomAdditionalmb,
    #[serde(rename = "wireless-usage-data-custom-first5mb")]
    #[display("wireless-usage-data-custom-first5mb")]
    WirelessUsageDataCustomFirst5Mb,
    #[serde(rename = "wireless-usage-data-domestic-roaming")]
    #[display("wireless-usage-data-domestic-roaming")]
    WirelessUsageDataDomesticRoaming,
    #[serde(rename = "wireless-usage-data-europe")]
    #[display("wireless-usage-data-europe")]
    WirelessUsageDataEurope,
    #[serde(rename = "wireless-usage-data-individual-additionalgb")]
    #[display("wireless-usage-data-individual-additionalgb")]
    WirelessUsageDataIndividualAdditionalgb,
    #[serde(rename = "wireless-usage-data-individual-firstgb")]
    #[display("wireless-usage-data-individual-firstgb")]
    WirelessUsageDataIndividualFirstgb,
    #[serde(rename = "wireless-usage-data-international-roaming-canada")]
    #[display("wireless-usage-data-international-roaming-canada")]
    WirelessUsageDataInternationalRoamingCanada,
    #[serde(rename = "wireless-usage-data-international-roaming-india")]
    #[display("wireless-usage-data-international-roaming-india")]
    WirelessUsageDataInternationalRoamingIndia,
    #[serde(rename = "wireless-usage-data-international-roaming-mexico")]
    #[display("wireless-usage-data-international-roaming-mexico")]
    WirelessUsageDataInternationalRoamingMexico,
    #[serde(rename = "wireless-usage-data-northamerica")]
    #[display("wireless-usage-data-northamerica")]
    WirelessUsageDataNorthamerica,
    #[serde(rename = "wireless-usage-data-oceania")]
    #[display("wireless-usage-data-oceania")]
    WirelessUsageDataOceania,
    #[serde(rename = "wireless-usage-data-pooled")]
    #[display("wireless-usage-data-pooled")]
    WirelessUsageDataPooled,
    #[serde(rename = "wireless-usage-data-pooled-downlink")]
    #[display("wireless-usage-data-pooled-downlink")]
    WirelessUsageDataPooledDownlink,
    #[serde(rename = "wireless-usage-data-pooled-uplink")]
    #[display("wireless-usage-data-pooled-uplink")]
    WirelessUsageDataPooledUplink,
    #[serde(rename = "wireless-usage-mrc")]
    #[display("wireless-usage-mrc")]
    WirelessUsageMrc,
    #[serde(rename = "wireless-usage-mrc-custom")]
    #[display("wireless-usage-mrc-custom")]
    WirelessUsageMrcCustom,
    #[serde(rename = "wireless-usage-mrc-individual")]
    #[display("wireless-usage-mrc-individual")]
    WirelessUsageMrcIndividual,
    #[serde(rename = "wireless-usage-mrc-pooled")]
    #[display("wireless-usage-mrc-pooled")]
    WirelessUsageMrcPooled,
    #[serde(rename = "wireless-usage-mrc-suspended")]
    #[display("wireless-usage-mrc-suspended")]
    WirelessUsageMrcSuspended,
    #[serde(rename = "wireless-usage-sms")]
    #[display("wireless-usage-sms")]
    WirelessUsageSms,
    #[serde(rename = "wireless-usage-voice")]
    #[display("wireless-usage-voice")]
    WirelessUsageVoice,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UsageTriggerEnumRecurring {
    #[serde(rename = "daily")]
    #[display("daily")]
    Daily,
    #[serde(rename = "monthly")]
    #[display("monthly")]
    Monthly,
    #[serde(rename = "yearly")]
    #[display("yearly")]
    Yearly,
    #[serde(rename = "alltime")]
    #[display("alltime")]
    Alltime,
}

#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UsageTriggerEnumTriggerField {
    #[serde(rename = "count")]
    #[display("count")]
    Count,
    #[serde(rename = "usage")]
    #[display("usage")]
    Usage,
    #[serde(rename = "price")]
    #[display("price")]
    Price,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountCallUserDefinedMessage {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created \
             User Defined Message."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) the User \
             Defined Message is associated with."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub call_sid: Option<String>,
    #[doc = "The SID that uniquely identifies this User Defined Message."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The date that this User Defined Message was created, given in RFC 2822 format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
}

impl std::fmt::Display for ApiV2010AccountCallUserDefinedMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountCallUserDefinedMessage {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(call_sid) = &self.call_sid {
                format!("{call_sid:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "call_sid".to_string(),
            "sid".to_string(),
            "date_created".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountCallUserDefinedMessageSubscription {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that \
             subscribed to the User Defined Messages."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) the User \
             Defined Message Subscription is associated with. This refers to the Call SID that is \
             producing the User Defined Messages."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub call_sid: Option<String>,
    #[doc = "The SID that uniquely identifies this User Defined Message Subscription."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
    #[doc = "The date that this User Defined Message Subscription was created, given in RFC 2822 \
             format."]
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub date_created: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "The URI of the User Defined Message Subscription Resource, relative to `https://api.twilio.com`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountCallUserDefinedMessageSubscription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountCallUserDefinedMessageSubscription {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(call_sid) = &self.call_sid {
                format!("{call_sid:?}")
            } else {
                String::new()
            },
            if let Some(sid) = &self.sid {
                format!("{sid:?}")
            } else {
                String::new()
            },
            if let Some(date_created) = &self.date_created {
                format!("{date_created:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "call_sid".to_string(),
            "sid".to_string(),
            "date_created".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ApiV2010AccountValidationRequest {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) responsible \
             for the Caller ID."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account_sid: Option<String>,
    #[doc = "The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) the \
             Caller ID is associated with."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub call_sid: Option<String>,
    #[doc = "The string that you assigned to describe the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub friendly_name: Option<String>,
    #[doc = "The phone number to verify in \
             [E.164](https://www.twilio.com/docs/glossary/what-e164) format, which consists of a \
             + followed by the country code and subscriber number."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone_number: phone_number::PhoneNumber,
    #[doc = "The 6 digit validation code that someone must enter to validate the Caller ID  when \
             `phone_number` is called."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub validation_code: Option<String>,
}

impl std::fmt::Display for ApiV2010AccountValidationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ApiV2010AccountValidationRequest {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(call_sid) = &self.call_sid {
                format!("{call_sid:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            format!("{:?}", self.phone_number),
            if let Some(validation_code) = &self.validation_code {
                format!("{validation_code:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "call_sid".to_string(),
            "friendly_name".to_string(),
            "phone_number".to_string(),
            "validation_code".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListAccountResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub accounts: Option<Vec<ApiV2010Account>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListAccountResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListAccountResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(accounts) = &self.accounts {
                format!("{accounts:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "accounts".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateAccountRequest {
    #[doc = "A human readable description of the account to create, defaults to `SubAccount \
             Created at {YYYY-MM-DD HH:MM meridian}`"]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
}

impl std::fmt::Display for CreateAccountRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateAccountRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![if let Some(friendly_name) = &self.friendly_name {
            format!("{friendly_name:?}")
        } else {
            String::new()
        }]
    }

    fn headers() -> Vec<String> {
        vec!["friendly_name".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateAccountRequest {
    #[doc = "Update the human-readable description of this Account"]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
    #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
    pub status: Option<AccountEnumStatus>,
}

impl std::fmt::Display for UpdateAccountRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateAccountRequest {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec!["friendly_name".to_string(), "status".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListAddressResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub addresses: Option<Vec<ApiV2010AccountAddress>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListAddressResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListAddressResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(addresses) = &self.addresses {
                format!("{addresses:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "addresses".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateAddressRequest {
    #[doc = "The name to associate with the new address."]
    #[serde(rename = "CustomerName")]
    pub customer_name: String,
    #[doc = "The number and street address of the new address."]
    #[serde(rename = "Street")]
    pub street: String,
    #[doc = "The city of the new address."]
    #[serde(rename = "City")]
    pub city: String,
    #[doc = "The state or region of the new address."]
    #[serde(rename = "Region")]
    pub region: String,
    #[doc = "The postal code of the new address."]
    #[serde(rename = "PostalCode")]
    pub postal_code: String,
    #[doc = "The ISO country code of the new address."]
    #[serde(rename = "IsoCountry")]
    pub iso_country: String,
    #[doc = "A descriptive string that you create to describe the new address. It can be up to 64 \
             characters long."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
    #[doc = "Whether to enable emergency calling on the new address. Can be: `true` or `false`."]
    #[serde(
        rename = "EmergencyEnabled",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub emergency_enabled: Option<bool>,
    #[doc = "Whether we should automatically correct the address. Can be: `true` or `false` and \
             the default is `true`. If empty or `true`, we will correct the address you provide \
             if necessary. If `false`, we won't alter the address you provide."]
    #[serde(
        rename = "AutoCorrectAddress",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub auto_correct_address: Option<bool>,
    #[doc = "The additional number and street address of the address."]
    #[serde(
        rename = "StreetSecondary",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub street_secondary: Option<String>,
}

impl std::fmt::Display for CreateAddressRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateAddressRequest {
    const LENGTH: usize = 10;
    fn fields(&self) -> Vec<String> {
        vec![
            self.customer_name.clone(),
            self.street.clone(),
            self.city.clone(),
            self.region.clone(),
            self.postal_code.clone(),
            self.iso_country.clone(),
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(emergency_enabled) = &self.emergency_enabled {
                format!("{emergency_enabled:?}")
            } else {
                String::new()
            },
            if let Some(auto_correct_address) = &self.auto_correct_address {
                format!("{auto_correct_address:?}")
            } else {
                String::new()
            },
            if let Some(street_secondary) = &self.street_secondary {
                format!("{street_secondary:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "customer_name".to_string(),
            "street".to_string(),
            "city".to_string(),
            "region".to_string(),
            "postal_code".to_string(),
            "iso_country".to_string(),
            "friendly_name".to_string(),
            "emergency_enabled".to_string(),
            "auto_correct_address".to_string(),
            "street_secondary".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateAddressRequest {
    #[doc = "A descriptive string that you create to describe the address. It can be up to 64 \
             characters long."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
    #[doc = "The name to associate with the address."]
    #[serde(
        rename = "CustomerName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub customer_name: Option<String>,
    #[doc = "The number and street address of the address."]
    #[serde(rename = "Street", default, skip_serializing_if = "Option::is_none")]
    pub street: Option<String>,
    #[doc = "The city of the address."]
    #[serde(rename = "City", default, skip_serializing_if = "Option::is_none")]
    pub city: Option<String>,
    #[doc = "The state or region of the address."]
    #[serde(rename = "Region", default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[doc = "The postal code of the address."]
    #[serde(
        rename = "PostalCode",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub postal_code: Option<String>,
    #[doc = "Whether to enable emergency calling on the address. Can be: `true` or `false`."]
    #[serde(
        rename = "EmergencyEnabled",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub emergency_enabled: Option<bool>,
    #[doc = "Whether we should automatically correct the address. Can be: `true` or `false` and \
             the default is `true`. If empty or `true`, we will correct the address you provide \
             if necessary. If `false`, we won't alter the address you provide."]
    #[serde(
        rename = "AutoCorrectAddress",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub auto_correct_address: Option<bool>,
    #[doc = "The additional number and street address of the address."]
    #[serde(
        rename = "StreetSecondary",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub street_secondary: Option<String>,
}

impl std::fmt::Display for UpdateAddressRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateAddressRequest {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(customer_name) = &self.customer_name {
                format!("{customer_name:?}")
            } else {
                String::new()
            },
            if let Some(street) = &self.street {
                format!("{street:?}")
            } else {
                String::new()
            },
            if let Some(city) = &self.city {
                format!("{city:?}")
            } else {
                String::new()
            },
            if let Some(region) = &self.region {
                format!("{region:?}")
            } else {
                String::new()
            },
            if let Some(postal_code) = &self.postal_code {
                format!("{postal_code:?}")
            } else {
                String::new()
            },
            if let Some(emergency_enabled) = &self.emergency_enabled {
                format!("{emergency_enabled:?}")
            } else {
                String::new()
            },
            if let Some(auto_correct_address) = &self.auto_correct_address {
                format!("{auto_correct_address:?}")
            } else {
                String::new()
            },
            if let Some(street_secondary) = &self.street_secondary {
                format!("{street_secondary:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "friendly_name".to_string(),
            "customer_name".to_string(),
            "street".to_string(),
            "city".to_string(),
            "region".to_string(),
            "postal_code".to_string(),
            "emergency_enabled".to_string(),
            "auto_correct_address".to_string(),
            "street_secondary".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListApplicationResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub applications: Option<Vec<ApiV2010AccountApplication>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListApplicationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListApplicationResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(applications) = &self.applications {
                format!("{applications:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "applications".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[doc = "The HTTP method we should use to call `voice_url`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateApplicationRequestVoiceMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateApplicationRequestVoiceFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateApplicationRequestStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `sms_url`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateApplicationRequestSmsMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `sms_fallback_url`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateApplicationRequestSmsFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateApplicationRequest {
    #[doc = "The API version to use to start a new TwiML session. Can be: `2010-04-01` or \
             `2008-08-01`. The default value is the account's default API version."]
    #[serde(
        rename = "ApiVersion",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub api_version: Option<String>,
    #[doc = "The URL we should call when the phone number assigned to this application receives a \
             call."]
    #[serde(rename = "VoiceUrl", default, skip_serializing_if = "Option::is_none")]
    pub voice_url: Option<String>,
    #[doc = "The HTTP method we should use to call `voice_url`. Can be: `GET` or `POST`."]
    #[serde(
        rename = "VoiceMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_method: Option<CreateApplicationRequestVoiceMethod>,
    #[doc = "The URL that we should call when an error occurs retrieving or executing the TwiML \
             requested by `url`."]
    #[serde(
        rename = "VoiceFallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_fallback_url: Option<String>,
    #[doc = "The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(
        rename = "VoiceFallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_fallback_method: Option<CreateApplicationRequestVoiceFallbackMethod>,
    #[doc = "The URL we should call using the `status_callback_method` to send status information \
             to your application."]
    #[serde(
        rename = "StatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback: Option<String>,
    #[doc = "The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST`."]
    #[serde(
        rename = "StatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback_method: Option<CreateApplicationRequestStatusCallbackMethod>,
    #[doc = "Whether we should look up the caller's caller-ID name from the CNAM database \
             (additional charges apply). Can be: `true` or `false`."]
    #[serde(
        rename = "VoiceCallerIdLookup",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_caller_id_lookup: Option<bool>,
    #[doc = "The URL we should call when the phone number receives an incoming SMS message."]
    #[serde(rename = "SmsUrl", default, skip_serializing_if = "Option::is_none")]
    pub sms_url: Option<String>,
    #[doc = "The HTTP method we should use to call `sms_url`. Can be: `GET` or `POST`."]
    #[serde(rename = "SmsMethod", default, skip_serializing_if = "Option::is_none")]
    pub sms_method: Option<CreateApplicationRequestSmsMethod>,
    #[doc = "The URL that we should call when an error occurs while retrieving or executing the \
             TwiML from `sms_url`."]
    #[serde(
        rename = "SmsFallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_fallback_url: Option<String>,
    #[doc = "The HTTP method we should use to call `sms_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(
        rename = "SmsFallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_fallback_method: Option<CreateApplicationRequestSmsFallbackMethod>,
    #[doc = "The URL we should call using a POST method to send status information about SMS \
             messages sent by the application."]
    #[serde(
        rename = "SmsStatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_status_callback: Option<String>,
    #[doc = "The URL we should call using a POST method to send message status information to \
             your application."]
    #[serde(
        rename = "MessageStatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub message_status_callback: Option<String>,
    #[doc = "A descriptive string that you create to describe the new application. It can be up \
             to 64 characters long."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
    #[doc = "Whether to allow other Twilio accounts to dial this applicaton using Dial verb. Can \
             be: `true` or `false`."]
    #[serde(
        rename = "PublicApplicationConnectEnabled",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub public_application_connect_enabled: Option<bool>,
}

impl std::fmt::Display for CreateApplicationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateApplicationRequest {
    const LENGTH: usize = 16;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(voice_url) = &self.voice_url {
                format!("{voice_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_method) = &self.voice_method {
                format!("{voice_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_url) = &self.voice_fallback_url {
                format!("{voice_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_method) = &self.voice_fallback_method {
                format!("{voice_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_caller_id_lookup) = &self.voice_caller_id_lookup {
                format!("{voice_caller_id_lookup:?}")
            } else {
                String::new()
            },
            if let Some(sms_url) = &self.sms_url {
                format!("{sms_url:?}")
            } else {
                String::new()
            },
            if let Some(sms_method) = &self.sms_method {
                format!("{sms_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_url) = &self.sms_fallback_url {
                format!("{sms_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_method) = &self.sms_fallback_method {
                format!("{sms_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_status_callback) = &self.sms_status_callback {
                format!("{sms_status_callback:?}")
            } else {
                String::new()
            },
            if let Some(message_status_callback) = &self.message_status_callback {
                format!("{message_status_callback:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(public_application_connect_enabled) =
                &self.public_application_connect_enabled
            {
                format!("{public_application_connect_enabled:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "api_version".to_string(),
            "voice_url".to_string(),
            "voice_method".to_string(),
            "voice_fallback_url".to_string(),
            "voice_fallback_method".to_string(),
            "status_callback".to_string(),
            "status_callback_method".to_string(),
            "voice_caller_id_lookup".to_string(),
            "sms_url".to_string(),
            "sms_method".to_string(),
            "sms_fallback_url".to_string(),
            "sms_fallback_method".to_string(),
            "sms_status_callback".to_string(),
            "message_status_callback".to_string(),
            "friendly_name".to_string(),
            "public_application_connect_enabled".to_string(),
        ]
    }
}

#[doc = "The HTTP method we should use to call `voice_url`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateApplicationRequestVoiceMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateApplicationRequestVoiceFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateApplicationRequestStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `sms_url`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateApplicationRequestSmsMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `sms_fallback_url`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateApplicationRequestSmsFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateApplicationRequest {
    #[doc = "A descriptive string that you create to describe the resource. It can be up to 64 \
             characters long."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
    #[doc = "The API version to use to start a new TwiML session. Can be: `2010-04-01` or \
             `2008-08-01`. The default value is your account's default API version."]
    #[serde(
        rename = "ApiVersion",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub api_version: Option<String>,
    #[doc = "The URL we should call when the phone number assigned to this application receives a \
             call."]
    #[serde(rename = "VoiceUrl", default, skip_serializing_if = "Option::is_none")]
    pub voice_url: Option<String>,
    #[doc = "The HTTP method we should use to call `voice_url`. Can be: `GET` or `POST`."]
    #[serde(
        rename = "VoiceMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_method: Option<UpdateApplicationRequestVoiceMethod>,
    #[doc = "The URL that we should call when an error occurs retrieving or executing the TwiML \
             requested by `url`."]
    #[serde(
        rename = "VoiceFallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_fallback_url: Option<String>,
    #[doc = "The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(
        rename = "VoiceFallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_fallback_method: Option<UpdateApplicationRequestVoiceFallbackMethod>,
    #[doc = "The URL we should call using the `status_callback_method` to send status information \
             to your application."]
    #[serde(
        rename = "StatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback: Option<String>,
    #[doc = "The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST`."]
    #[serde(
        rename = "StatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback_method: Option<UpdateApplicationRequestStatusCallbackMethod>,
    #[doc = "Whether we should look up the caller's caller-ID name from the CNAM database \
             (additional charges apply). Can be: `true` or `false`."]
    #[serde(
        rename = "VoiceCallerIdLookup",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_caller_id_lookup: Option<bool>,
    #[doc = "The URL we should call when the phone number receives an incoming SMS message."]
    #[serde(rename = "SmsUrl", default, skip_serializing_if = "Option::is_none")]
    pub sms_url: Option<String>,
    #[doc = "The HTTP method we should use to call `sms_url`. Can be: `GET` or `POST`."]
    #[serde(rename = "SmsMethod", default, skip_serializing_if = "Option::is_none")]
    pub sms_method: Option<UpdateApplicationRequestSmsMethod>,
    #[doc = "The URL that we should call when an error occurs while retrieving or executing the \
             TwiML from `sms_url`."]
    #[serde(
        rename = "SmsFallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_fallback_url: Option<String>,
    #[doc = "The HTTP method we should use to call `sms_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(
        rename = "SmsFallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_fallback_method: Option<UpdateApplicationRequestSmsFallbackMethod>,
    #[doc = "Same as message_status_callback: The URL we should call using a POST method to send \
             status information about SMS messages sent by the application. Deprecated, included \
             for backwards compatibility."]
    #[serde(
        rename = "SmsStatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_status_callback: Option<String>,
    #[doc = "The URL we should call using a POST method to send message status information to \
             your application."]
    #[serde(
        rename = "MessageStatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub message_status_callback: Option<String>,
    #[doc = "Whether to allow other Twilio accounts to dial this applicaton using Dial verb. Can \
             be: `true` or `false`."]
    #[serde(
        rename = "PublicApplicationConnectEnabled",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub public_application_connect_enabled: Option<bool>,
}

impl std::fmt::Display for UpdateApplicationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateApplicationRequest {
    const LENGTH: usize = 16;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(voice_url) = &self.voice_url {
                format!("{voice_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_method) = &self.voice_method {
                format!("{voice_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_url) = &self.voice_fallback_url {
                format!("{voice_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_method) = &self.voice_fallback_method {
                format!("{voice_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_caller_id_lookup) = &self.voice_caller_id_lookup {
                format!("{voice_caller_id_lookup:?}")
            } else {
                String::new()
            },
            if let Some(sms_url) = &self.sms_url {
                format!("{sms_url:?}")
            } else {
                String::new()
            },
            if let Some(sms_method) = &self.sms_method {
                format!("{sms_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_url) = &self.sms_fallback_url {
                format!("{sms_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_method) = &self.sms_fallback_method {
                format!("{sms_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_status_callback) = &self.sms_status_callback {
                format!("{sms_status_callback:?}")
            } else {
                String::new()
            },
            if let Some(message_status_callback) = &self.message_status_callback {
                format!("{message_status_callback:?}")
            } else {
                String::new()
            },
            if let Some(public_application_connect_enabled) =
                &self.public_application_connect_enabled
            {
                format!("{public_application_connect_enabled:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "friendly_name".to_string(),
            "api_version".to_string(),
            "voice_url".to_string(),
            "voice_method".to_string(),
            "voice_fallback_url".to_string(),
            "voice_fallback_method".to_string(),
            "status_callback".to_string(),
            "status_callback_method".to_string(),
            "voice_caller_id_lookup".to_string(),
            "sms_url".to_string(),
            "sms_method".to_string(),
            "sms_fallback_url".to_string(),
            "sms_fallback_method".to_string(),
            "sms_status_callback".to_string(),
            "message_status_callback".to_string(),
            "public_application_connect_enabled".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListAuthorizedConnectAppResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorized_connect_apps: Option<Vec<ApiV2010AccountAuthorizedConnectApp>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListAuthorizedConnectAppResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListAuthorizedConnectAppResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(authorized_connect_apps) = &self.authorized_connect_apps {
                format!("{authorized_connect_apps:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "authorized_connect_apps".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListAvailablePhoneNumberCountryResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub countries: Option<Vec<ApiV2010AccountAvailablePhoneNumberCountry>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListAvailablePhoneNumberCountryResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListAvailablePhoneNumberCountryResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(countries) = &self.countries {
                format!("{countries:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "countries".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListAvailablePhoneNumberLocalResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub available_phone_numbers:
        Option<Vec<ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberLocal>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListAvailablePhoneNumberLocalResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListAvailablePhoneNumberLocalResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(available_phone_numbers) = &self.available_phone_numbers {
                format!("{available_phone_numbers:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "available_phone_numbers".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListAvailablePhoneNumberMachineToMachineResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub available_phone_numbers:
        Option<Vec<ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberMachineToMachine>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListAvailablePhoneNumberMachineToMachineResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListAvailablePhoneNumberMachineToMachineResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(available_phone_numbers) = &self.available_phone_numbers {
                format!("{available_phone_numbers:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "available_phone_numbers".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListAvailablePhoneNumberMobileResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub available_phone_numbers:
        Option<Vec<ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberMobile>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListAvailablePhoneNumberMobileResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListAvailablePhoneNumberMobileResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(available_phone_numbers) = &self.available_phone_numbers {
                format!("{available_phone_numbers:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "available_phone_numbers".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListAvailablePhoneNumberNationalResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub available_phone_numbers:
        Option<Vec<ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberNational>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListAvailablePhoneNumberNationalResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListAvailablePhoneNumberNationalResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(available_phone_numbers) = &self.available_phone_numbers {
                format!("{available_phone_numbers:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "available_phone_numbers".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListAvailablePhoneNumberSharedCostResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub available_phone_numbers:
        Option<Vec<ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberSharedCost>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListAvailablePhoneNumberSharedCostResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListAvailablePhoneNumberSharedCostResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(available_phone_numbers) = &self.available_phone_numbers {
                format!("{available_phone_numbers:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "available_phone_numbers".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListAvailablePhoneNumberTollFreeResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub available_phone_numbers:
        Option<Vec<ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberTollFree>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListAvailablePhoneNumberTollFreeResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListAvailablePhoneNumberTollFreeResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(available_phone_numbers) = &self.available_phone_numbers {
                format!("{available_phone_numbers:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "available_phone_numbers".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListAvailablePhoneNumberVoipResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub available_phone_numbers:
        Option<Vec<ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberVoip>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListAvailablePhoneNumberVoipResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListAvailablePhoneNumberVoipResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(available_phone_numbers) = &self.available_phone_numbers {
                format!("{available_phone_numbers:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "available_phone_numbers".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListCallResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub calls: Option<Vec<ApiV2010AccountCall>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListCallResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListCallResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(calls) = &self.calls {
                format!("{calls:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "calls".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[doc = "The HTTP method we should use when calling the `url` parameter's value. Can be: `GET` or \
         `POST` and the default is `POST`. If an `application_sid` parameter is present, this \
         parameter is ignored."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum Method {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method that we should use to request the `fallback_url`. Can be: `GET` or `POST` \
         and the default is `POST`. If an `application_sid` parameter is present, this parameter \
         is ignored."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum FallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use when calling the `status_callback` URL. Can be: `GET` or \
         `POST` and the default is `POST`. If an `application_sid` parameter is present, this \
         parameter is ignored."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateCallRequestStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use when calling the `recording_status_callback` URL. Can be: \
         `GET` or `POST` and the default is `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum RecordingStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use when calling the `async_amd_status_callback` URL. Can be: \
         `GET` or `POST` and the default is `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum AsyncAmdStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateCallRequest {
    #[doc = "The phone number, SIP address, or client identifier to call."]
    #[serde(rename = "To")]
    pub to: String,
    #[doc = "The phone number or client identifier to use as the caller id. If using a phone number, it must be a Twilio number or a Verified [outgoing caller id](https://www.twilio.com/docs/voice/api/outgoing-caller-ids) for your account. If the `to` parameter is a phone number, `From` must also be a phone number."]
    #[serde(rename = "From")]
    pub from: String,
    #[doc = "The HTTP method we should use when calling the `url` parameter's value. Can be: \
             `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is \
             present, this parameter is ignored."]
    #[serde(rename = "Method", default, skip_serializing_if = "Option::is_none")]
    pub method: Option<Method>,
    #[doc = "The URL that we call using the `fallback_method` if an error occurs when requesting \
             or executing the TwiML at `url`. If an `application_sid` parameter is present, this \
             parameter is ignored."]
    #[serde(
        rename = "FallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub fallback_url: Option<String>,
    #[doc = "The HTTP method that we should use to request the `fallback_url`. Can be: `GET` or \
             `POST` and the default is `POST`. If an `application_sid` parameter is present, this \
             parameter is ignored."]
    #[serde(
        rename = "FallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub fallback_method: Option<FallbackMethod>,
    #[doc = "The URL we should call using the `status_callback_method` to send status information \
             to your application. If no `status_callback_event` is specified, we will send the \
             `completed` status. If an `application_sid` parameter is present, this parameter is \
             ignored. URLs must contain a valid hostname (underscores are not permitted)."]
    #[serde(
        rename = "StatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback: Option<String>,
    #[doc = "The call progress events that we will send to the `status_callback` URL. Can be: `initiated`, `ringing`, `answered`, and `completed`. If no event is specified, we send the `completed` status. If you want to receive multiple events, specify each one in a separate `status_callback_event` parameter. See the code sample for [monitoring call progress](https://www.twilio.com/docs/voice/api/call-resource?code-sample=code-create-a-call-resource-and-specify-a-statuscallbackevent&code-sdk-version=json). If an `application_sid` is present, this parameter is ignored."]
    #[serde(
        rename = "StatusCallbackEvent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback_event: Option<Vec<String>>,
    #[doc = "The HTTP method we should use when calling the `status_callback` URL. Can be: `GET` \
             or `POST` and the default is `POST`. If an `application_sid` parameter is present, \
             this parameter is ignored."]
    #[serde(
        rename = "StatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback_method: Option<CreateCallRequestStatusCallbackMethod>,
    #[doc = "A string of keys to dial after connecting to the number, maximum of 32 digits. Valid \
             digits in the string include: any digit (`0`-`9`), '`#`', '`*`' and '`w`', to insert \
             a half second pause. For example, if you connected to a company phone number and \
             wanted to pause for one second, and then dial extension 1234 followed by the pound \
             key, the value of this parameter would be `ww1234#`. Remember to URL-encode this \
             string, since the '`#`' character has special meaning in a URL. If both `SendDigits` \
             and `MachineDetection` parameters are provided, then `MachineDetection` will be \
             ignored."]
    #[serde(
        rename = "SendDigits",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub send_digits: Option<String>,
    #[doc = "The integer number of seconds that we should allow the phone to ring before assuming \
             there is no answer. The default is `60` seconds and the maximum is `600` seconds. \
             For some call flows, we will add a 5-second buffer to the timeout value you provide. \
             For this reason, a timeout value of 10 seconds could result in an actual timeout \
             closer to 15 seconds. You can set this to a short time, such as `15` seconds, to \
             hang up before reaching an answering machine or voicemail."]
    #[serde(rename = "Timeout", default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<i64>,
    #[doc = "Whether to record the call. Can be `true` to record the phone call, or `false` to \
             not. The default is `false`. The `recording_url` is sent to the `status_callback` \
             URL."]
    #[serde(rename = "Record", default, skip_serializing_if = "Option::is_none")]
    pub record: Option<bool>,
    #[doc = "The number of channels in the final recording. Can be: `mono` or `dual`. The default \
             is `mono`. `mono` records both legs of the call in a single channel of the recording \
             file. `dual` records each leg to a separate channel of the recording file. The first \
             channel of a dual-channel recording contains the parent call and the second channel \
             contains the child call."]
    #[serde(
        rename = "RecordingChannels",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub recording_channels: Option<String>,
    #[doc = "The URL that we call when the recording is available to be accessed."]
    #[serde(
        rename = "RecordingStatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub recording_status_callback: Option<String>,
    #[doc = "The HTTP method we should use when calling the `recording_status_callback` URL. Can \
             be: `GET` or `POST` and the default is `POST`."]
    #[serde(
        rename = "RecordingStatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub recording_status_callback_method: Option<RecordingStatusCallbackMethod>,
    #[doc = "The username used to authenticate the caller making a SIP call."]
    #[serde(
        rename = "SipAuthUsername",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sip_auth_username: Option<String>,
    #[doc = "The password required to authenticate the user account specified in \
             `sip_auth_username`."]
    #[serde(
        rename = "SipAuthPassword",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sip_auth_password: Option<String>,
    #[doc = "Whether to detect if a human, answering machine, or fax has picked up the call. Can be: `Enable` or `DetectMessageEnd`. Use `Enable` if you would like us to return `AnsweredBy` as soon as the called party is identified. Use `DetectMessageEnd`, if you would like to leave a message on an answering machine. If `send_digits` is provided, this parameter is ignored. For more information, see [Answering Machine Detection](https://www.twilio.com/docs/voice/answering-machine-detection)."]
    #[serde(
        rename = "MachineDetection",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub machine_detection: Option<String>,
    #[doc = "The number of seconds that we should attempt to detect an answering machine before \
             timing out and sending a voice request with `AnsweredBy` of `unknown`. The default \
             timeout is 30 seconds."]
    #[serde(
        rename = "MachineDetectionTimeout",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub machine_detection_timeout: Option<i64>,
    #[doc = "The recording status events that will trigger calls to the URL specified in \
             `recording_status_callback`. Can be: `in-progress`, `completed` and `absent`. \
             Defaults to `completed`. Separate  multiple values with a space."]
    #[serde(
        rename = "RecordingStatusCallbackEvent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub recording_status_callback_event: Option<Vec<String>>,
    #[doc = "Whether to trim any leading and trailing silence from the recording. Can be: \
             `trim-silence` or `do-not-trim` and the default is `trim-silence`."]
    #[serde(rename = "Trim", default, skip_serializing_if = "Option::is_none")]
    pub trim: Option<String>,
    #[doc = "The phone number, SIP address, or Client identifier that made this call. Phone numbers are in [E.164 format](https://wwnw.twilio.com/docs/glossary/what-e164) (e.g., +16175551212). SIP addresses are formatted as `name@company.com`."]
    #[serde(rename = "CallerId", default, skip_serializing_if = "Option::is_none")]
    pub caller_id: Option<String>,
    #[doc = "The number of milliseconds that is used as the measuring stick for the length of the \
             speech activity, where durations lower than this value will be interpreted as a \
             human and longer than this value as a machine. Possible Values: 1000-6000. Default: \
             2400."]
    #[serde(
        rename = "MachineDetectionSpeechThreshold",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub machine_detection_speech_threshold: Option<i64>,
    #[doc = "The number of milliseconds of silence after speech activity at which point the \
             speech activity is considered complete. Possible Values: 500-5000. Default: 1200."]
    #[serde(
        rename = "MachineDetectionSpeechEndThreshold",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub machine_detection_speech_end_threshold: Option<i64>,
    #[doc = "The number of milliseconds of initial silence after which an `unknown` AnsweredBy \
             result will be returned. Possible Values: 2000-10000. Default: 5000."]
    #[serde(
        rename = "MachineDetectionSilenceTimeout",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub machine_detection_silence_timeout: Option<i64>,
    #[doc = "Select whether to perform answering machine detection in the background. Default, \
             blocks the execution of the call until Answering Machine Detection is completed. Can \
             be: `true` or `false`."]
    #[serde(rename = "AsyncAmd", default, skip_serializing_if = "Option::is_none")]
    pub async_amd: Option<String>,
    #[doc = "The URL that we should call using the `async_amd_status_callback_method` to notify \
             customer application whether the call was answered by human, machine or fax."]
    #[serde(
        rename = "AsyncAmdStatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub async_amd_status_callback: Option<String>,
    #[doc = "The HTTP method we should use when calling the `async_amd_status_callback` URL. Can \
             be: `GET` or `POST` and the default is `POST`."]
    #[serde(
        rename = "AsyncAmdStatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub async_amd_status_callback_method: Option<AsyncAmdStatusCallbackMethod>,
    #[doc = "The SID of a BYOC (Bring Your Own Carrier) trunk to route this call with. Note that \
             `byoc` is only meaningful when `to` is a phone number; it will otherwise be ignored. \
             (Beta)"]
    #[serde(rename = "Byoc", default, skip_serializing_if = "Option::is_none")]
    pub byoc: Option<String>,
    #[doc = "The Reason for the outgoing call. Use it to specify the purpose of the call that is \
             presented on the called party's phone. (Branded Calls Beta)"]
    #[serde(
        rename = "CallReason",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub call_reason: Option<String>,
    #[doc = "A token string needed to invoke a forwarded call. A call_token is generated when an \
             incoming call is received on a Twilio number. Pass an incoming call's call_token \
             value to a forwarded call via the call_token parameter when creating a new call. A \
             forwarded call should bear the same CallerID of the original incoming call."]
    #[serde(rename = "CallToken", default, skip_serializing_if = "Option::is_none")]
    pub call_token: Option<String>,
    #[doc = "The audio track to record for the call. Can be: `inbound`, `outbound` or `both`. The \
             default is `both`. `inbound` records the audio that is received by Twilio. \
             `outbound` records the audio that is generated from Twilio. `both` records the audio \
             that is received and generated by Twilio."]
    #[serde(
        rename = "RecordingTrack",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub recording_track: Option<String>,
    #[doc = "The maximum duration of the call in seconds. Constraints depend on account and \
             configuration."]
    #[serde(rename = "TimeLimit", default, skip_serializing_if = "Option::is_none")]
    pub time_limit: Option<i64>,
    #[doc = "The absolute URL that returns the TwiML instructions for the call. We will call this URL using the `method` when the call connects. For more information, see the [Url Parameter](https://www.twilio.com/docs/voice/make-calls#specify-a-url-parameter) section in [Making Calls](https://www.twilio.com/docs/voice/make-calls)."]
    #[serde(rename = "Url", default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[doc = "TwiML instructions for the call Twilio will use without fetching Twiml from url \
             parameter. If both `twiml` and `url` are provided then `twiml` parameter will be \
             ignored. Max 4000 characters."]
    #[serde(rename = "Twiml", default, skip_serializing_if = "Option::is_none")]
    pub twiml: Option<String>,
    #[doc = "The SID of the Application resource that will handle the call, if the call will be \
             handled by an application."]
    #[serde(
        rename = "ApplicationSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub application_sid: Option<String>,
}

impl std::fmt::Display for CreateCallRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateCallRequest {
    const LENGTH: usize = 35;
    fn fields(&self) -> Vec<String> {
        vec![
            self.to.clone(),
            self.from.clone(),
            if let Some(method) = &self.method {
                format!("{method:?}")
            } else {
                String::new()
            },
            if let Some(fallback_url) = &self.fallback_url {
                format!("{fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(fallback_method) = &self.fallback_method {
                format!("{fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_event) = &self.status_callback_event {
                format!("{status_callback_event:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(send_digits) = &self.send_digits {
                format!("{send_digits:?}")
            } else {
                String::new()
            },
            if let Some(timeout) = &self.timeout {
                format!("{timeout:?}")
            } else {
                String::new()
            },
            if let Some(record) = &self.record {
                format!("{record:?}")
            } else {
                String::new()
            },
            if let Some(recording_channels) = &self.recording_channels {
                format!("{recording_channels:?}")
            } else {
                String::new()
            },
            if let Some(recording_status_callback) = &self.recording_status_callback {
                format!("{recording_status_callback:?}")
            } else {
                String::new()
            },
            if let Some(recording_status_callback_method) = &self.recording_status_callback_method {
                format!("{recording_status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(sip_auth_username) = &self.sip_auth_username {
                format!("{sip_auth_username:?}")
            } else {
                String::new()
            },
            if let Some(sip_auth_password) = &self.sip_auth_password {
                format!("{sip_auth_password:?}")
            } else {
                String::new()
            },
            if let Some(machine_detection) = &self.machine_detection {
                format!("{machine_detection:?}")
            } else {
                String::new()
            },
            if let Some(machine_detection_timeout) = &self.machine_detection_timeout {
                format!("{machine_detection_timeout:?}")
            } else {
                String::new()
            },
            if let Some(recording_status_callback_event) = &self.recording_status_callback_event {
                format!("{recording_status_callback_event:?}")
            } else {
                String::new()
            },
            if let Some(trim) = &self.trim {
                format!("{trim:?}")
            } else {
                String::new()
            },
            if let Some(caller_id) = &self.caller_id {
                format!("{caller_id:?}")
            } else {
                String::new()
            },
            if let Some(machine_detection_speech_threshold) =
                &self.machine_detection_speech_threshold
            {
                format!("{machine_detection_speech_threshold:?}")
            } else {
                String::new()
            },
            if let Some(machine_detection_speech_end_threshold) =
                &self.machine_detection_speech_end_threshold
            {
                format!("{machine_detection_speech_end_threshold:?}")
            } else {
                String::new()
            },
            if let Some(machine_detection_silence_timeout) = &self.machine_detection_silence_timeout
            {
                format!("{machine_detection_silence_timeout:?}")
            } else {
                String::new()
            },
            if let Some(async_amd) = &self.async_amd {
                format!("{async_amd:?}")
            } else {
                String::new()
            },
            if let Some(async_amd_status_callback) = &self.async_amd_status_callback {
                format!("{async_amd_status_callback:?}")
            } else {
                String::new()
            },
            if let Some(async_amd_status_callback_method) = &self.async_amd_status_callback_method {
                format!("{async_amd_status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(byoc) = &self.byoc {
                format!("{byoc:?}")
            } else {
                String::new()
            },
            if let Some(call_reason) = &self.call_reason {
                format!("{call_reason:?}")
            } else {
                String::new()
            },
            if let Some(call_token) = &self.call_token {
                format!("{call_token:?}")
            } else {
                String::new()
            },
            if let Some(recording_track) = &self.recording_track {
                format!("{recording_track:?}")
            } else {
                String::new()
            },
            if let Some(time_limit) = &self.time_limit {
                format!("{time_limit:?}")
            } else {
                String::new()
            },
            if let Some(url) = &self.url {
                format!("{url:?}")
            } else {
                String::new()
            },
            if let Some(twiml) = &self.twiml {
                format!("{twiml:?}")
            } else {
                String::new()
            },
            if let Some(application_sid) = &self.application_sid {
                format!("{application_sid:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "to".to_string(),
            "from".to_string(),
            "method".to_string(),
            "fallback_url".to_string(),
            "fallback_method".to_string(),
            "status_callback".to_string(),
            "status_callback_event".to_string(),
            "status_callback_method".to_string(),
            "send_digits".to_string(),
            "timeout".to_string(),
            "record".to_string(),
            "recording_channels".to_string(),
            "recording_status_callback".to_string(),
            "recording_status_callback_method".to_string(),
            "sip_auth_username".to_string(),
            "sip_auth_password".to_string(),
            "machine_detection".to_string(),
            "machine_detection_timeout".to_string(),
            "recording_status_callback_event".to_string(),
            "trim".to_string(),
            "caller_id".to_string(),
            "machine_detection_speech_threshold".to_string(),
            "machine_detection_speech_end_threshold".to_string(),
            "machine_detection_silence_timeout".to_string(),
            "async_amd".to_string(),
            "async_amd_status_callback".to_string(),
            "async_amd_status_callback_method".to_string(),
            "byoc".to_string(),
            "call_reason".to_string(),
            "call_token".to_string(),
            "recording_track".to_string(),
            "time_limit".to_string(),
            "url".to_string(),
            "twiml".to_string(),
            "application_sid".to_string(),
        ]
    }
}

#[doc = "The HTTP method we should use when calling the `url`. Can be: `GET` or `POST` and the \
         default is `POST`. If an `application_sid` parameter is present, this parameter is \
         ignored."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateCallRequestMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use when requesting the `status_callback` URL. Can be: `GET` or \
         `POST` and the default is `POST`. If an `application_sid` parameter is present, this \
         parameter is ignored."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateCallRequestStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateCallRequest {
    #[doc = "The absolute URL that returns the TwiML instructions for the call. We will call this URL using the `method` when the call connects. For more information, see the [Url Parameter](https://www.twilio.com/docs/voice/make-calls#specify-a-url-parameter) section in [Making Calls](https://www.twilio.com/docs/voice/make-calls)."]
    #[serde(rename = "Url", default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[doc = "The HTTP method we should use when calling the `url`. Can be: `GET` or `POST` and \
             the default is `POST`. If an `application_sid` parameter is present, this parameter \
             is ignored."]
    #[serde(rename = "Method", default, skip_serializing_if = "Option::is_none")]
    pub method: Option<UpdateCallRequestMethod>,
    #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
    pub status: Option<CallEnumUpdateStatus>,
    #[doc = "The URL that we call using the `fallback_method` if an error occurs when requesting \
             or executing the TwiML at `url`. If an `application_sid` parameter is present, this \
             parameter is ignored."]
    #[serde(
        rename = "FallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub fallback_url: Option<String>,
    #[doc = "The HTTP method that we should use to request the `fallback_url`. Can be: `GET` or \
             `POST` and the default is `POST`. If an `application_sid` parameter is present, this \
             parameter is ignored."]
    #[serde(
        rename = "FallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub fallback_method: Option<FallbackMethod>,
    #[doc = "The URL we should call using the `status_callback_method` to send status information \
             to your application. If no `status_callback_event` is specified, we will send the \
             `completed` status. If an `application_sid` parameter is present, this parameter is \
             ignored. URLs must contain a valid hostname (underscores are not permitted)."]
    #[serde(
        rename = "StatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback: Option<String>,
    #[doc = "The HTTP method we should use when requesting the `status_callback` URL. Can be: \
             `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is \
             present, this parameter is ignored."]
    #[serde(
        rename = "StatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback_method: Option<UpdateCallRequestStatusCallbackMethod>,
    #[doc = "TwiML instructions for the call Twilio will use without fetching Twiml from url. \
             Twiml and url parameters are mutually exclusive"]
    #[serde(rename = "Twiml", default, skip_serializing_if = "Option::is_none")]
    pub twiml: Option<String>,
    #[doc = "The maximum duration of the call in seconds. Constraints depend on account and \
             configuration."]
    #[serde(rename = "TimeLimit", default, skip_serializing_if = "Option::is_none")]
    pub time_limit: Option<i64>,
}

impl std::fmt::Display for UpdateCallRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateCallRequest {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(url) = &self.url {
                format!("{url:?}")
            } else {
                String::new()
            },
            if let Some(method) = &self.method {
                format!("{method:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
            if let Some(fallback_url) = &self.fallback_url {
                format!("{fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(fallback_method) = &self.fallback_method {
                format!("{fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(twiml) = &self.twiml {
                format!("{twiml:?}")
            } else {
                String::new()
            },
            if let Some(time_limit) = &self.time_limit {
                format!("{time_limit:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "method".to_string(),
            "status".to_string(),
            "fallback_url".to_string(),
            "fallback_method".to_string(),
            "status_callback".to_string(),
            "status_callback_method".to_string(),
            "twiml".to_string(),
            "time_limit".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListCallEventResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub events: Option<Vec<ApiV2010AccountCallCallEvent>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListCallEventResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListCallEventResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(events) = &self.events {
                format!("{events:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "events".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateCallFeedbackRequest {
    #[doc = "The call quality expressed as an integer from `1` to `5` where `1` represents very \
             poor call quality and `5` represents a perfect call."]
    #[serde(
        rename = "QualityScore",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub quality_score: Option<i64>,
    #[doc = "One or more issues experienced during the call. The issues can be: \
             `imperfect-audio`, `dropped-call`, `incorrect-caller-id`, `post-dial-delay`, \
             `digits-not-captured`, `audio-latency`, `unsolicited-call`, or `one-way-audio`."]
    #[serde(rename = "Issue", default, skip_serializing_if = "Option::is_none")]
    pub issue: Option<Vec<CallFeedbackEnumIssues>>,
}

impl std::fmt::Display for UpdateCallFeedbackRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateCallFeedbackRequest {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(quality_score) = &self.quality_score {
                format!("{quality_score:?}")
            } else {
                String::new()
            },
            if let Some(issue) = &self.issue {
                format!("{issue:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec!["quality_score".to_string(), "issue".to_string()]
    }
}

#[doc = "The HTTP method (`GET` or `POST`) we use to make the request to the `StatusCallback` URL."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateCallFeedbackSummaryRequestStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateCallFeedbackSummaryRequest {
    #[doc = "Only include feedback given on or after this date. Format is `YYYY-MM-DD` and \
             specified in UTC."]
    #[serde(rename = "StartDate")]
    pub start_date: chrono::NaiveDate,
    #[doc = "Only include feedback given on or before this date. Format is `YYYY-MM-DD` and \
             specified in UTC."]
    #[serde(rename = "EndDate")]
    pub end_date: chrono::NaiveDate,
    #[doc = "Whether to also include Feedback resources from all subaccounts. `true` includes \
             feedback from all subaccounts and `false`, the default, includes feedback from only \
             the specified account."]
    #[serde(
        rename = "IncludeSubaccounts",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub include_subaccounts: Option<bool>,
    #[doc = "The URL that we will request when the feedback summary is complete."]
    #[serde(
        rename = "StatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback: Option<String>,
    #[doc = "The HTTP method (`GET` or `POST`) we use to make the request to the `StatusCallback` \
             URL."]
    #[serde(
        rename = "StatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback_method: Option<CreateCallFeedbackSummaryRequestStatusCallbackMethod>,
}

impl std::fmt::Display for CreateCallFeedbackSummaryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateCallFeedbackSummaryRequest {
    const LENGTH: usize = 5;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.start_date),
            format!("{:?}", self.end_date),
            if let Some(include_subaccounts) = &self.include_subaccounts {
                format!("{include_subaccounts:?}")
            } else {
                String::new()
            },
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "start_date".to_string(),
            "end_date".to_string(),
            "include_subaccounts".to_string(),
            "status_callback".to_string(),
            "status_callback_method".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListCallNotificationResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notifications: Option<Vec<ApiV2010AccountCallCallNotification>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListCallNotificationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListCallNotificationResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(notifications) = &self.notifications {
                format!("{notifications:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "notifications".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListCallRecordingResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub recordings: Option<Vec<ApiV2010AccountCallCallRecording>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListCallRecordingResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListCallRecordingResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(recordings) = &self.recordings {
                format!("{recordings:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "recordings".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[doc = "The HTTP method we should use to call `recording_status_callback`. Can be: `GET` or \
         `POST` and the default is `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateCallRecordingRequestRecordingStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateCallRecordingRequest {
    #[doc = "The recording status events on which we should call the `recording_status_callback` \
             URL. Can be: `in-progress`, `completed` and `absent` and the default is `completed`. \
             Separate multiple event values with a space."]
    #[serde(
        rename = "RecordingStatusCallbackEvent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub recording_status_callback_event: Option<Vec<String>>,
    #[doc = "The URL we should call using the `recording_status_callback_method` on each recording event specified in  `recording_status_callback_event`. For more information, see [RecordingStatusCallback parameters](https://www.twilio.com/docs/voice/api/recording#recordingstatuscallback)."]
    #[serde(
        rename = "RecordingStatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub recording_status_callback: Option<String>,
    #[doc = "The HTTP method we should use to call `recording_status_callback`. Can be: `GET` or \
             `POST` and the default is `POST`."]
    #[serde(
        rename = "RecordingStatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub recording_status_callback_method:
        Option<CreateCallRecordingRequestRecordingStatusCallbackMethod>,
    #[doc = "Whether to trim any leading and trailing silence in the recording. Can be: \
             `trim-silence` or `do-not-trim` and the default is `do-not-trim`. `trim-silence` \
             trims the silence from the beginning and end of the recording and `do-not-trim` does \
             not."]
    #[serde(rename = "Trim", default, skip_serializing_if = "Option::is_none")]
    pub trim: Option<String>,
    #[doc = "The number of channels used in the recording. Can be: `mono` or `dual` and the \
             default is `mono`. `mono` records all parties of the call into one channel. `dual` \
             records each party of a 2-party call into separate channels."]
    #[serde(
        rename = "RecordingChannels",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub recording_channels: Option<String>,
    #[doc = "The audio track to record for the call. Can be: `inbound`, `outbound` or `both`. The \
             default is `both`. `inbound` records the audio that is received by Twilio. \
             `outbound` records the audio that is generated from Twilio. `both` records the audio \
             that is received and generated by Twilio."]
    #[serde(
        rename = "RecordingTrack",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub recording_track: Option<String>,
}

impl std::fmt::Display for CreateCallRecordingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateCallRecordingRequest {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(recording_status_callback_event) = &self.recording_status_callback_event {
                format!("{recording_status_callback_event:?}")
            } else {
                String::new()
            },
            if let Some(recording_status_callback) = &self.recording_status_callback {
                format!("{recording_status_callback:?}")
            } else {
                String::new()
            },
            if let Some(recording_status_callback_method) = &self.recording_status_callback_method {
                format!("{recording_status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(trim) = &self.trim {
                format!("{trim:?}")
            } else {
                String::new()
            },
            if let Some(recording_channels) = &self.recording_channels {
                format!("{recording_channels:?}")
            } else {
                String::new()
            },
            if let Some(recording_track) = &self.recording_track {
                format!("{recording_track:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "recording_status_callback_event".to_string(),
            "recording_status_callback".to_string(),
            "recording_status_callback_method".to_string(),
            "trim".to_string(),
            "recording_channels".to_string(),
            "recording_track".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateCallRecordingRequest {
    #[serde(rename = "Status")]
    pub status: CallRecordingEnumStatus,
    #[doc = "Whether to record during a pause. Can be: `skip` or `silence` and the default is \
             `silence`. `skip` does not record during the pause period, while `silence` will \
             replace the actual audio of the call with silence during the pause period. This \
             parameter only applies when setting `status` is set to `paused`."]
    #[serde(
        rename = "PauseBehavior",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub pause_behavior: Option<String>,
}

impl std::fmt::Display for UpdateCallRecordingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateCallRecordingRequest {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.status),
            if let Some(pause_behavior) = &self.pause_behavior {
                format!("{pause_behavior:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec!["status".to_string(), "pause_behavior".to_string()]
    }
}

#[doc = "The HTTP method used to call `announce_url`. Can be: `GET` or `POST` and the default is \
         `POST`"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum AnnounceMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateConferenceRequest {
    #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
    pub status: Option<ConferenceEnumUpdateStatus>,
    #[doc = "The URL we should call to announce something into the conference. The URL may return \
             an MP3 file, a WAV file, or a TwiML document that contains `<Play>`, `<Say>`, \
             `<Pause>`, or `<Redirect>` verbs."]
    #[serde(
        rename = "AnnounceUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub announce_url: Option<String>,
    #[doc = "The HTTP method used to call `announce_url`. Can be: `GET` or `POST` and the default \
             is `POST`"]
    #[serde(
        rename = "AnnounceMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub announce_method: Option<AnnounceMethod>,
}

impl std::fmt::Display for UpdateConferenceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateConferenceRequest {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
            if let Some(announce_url) = &self.announce_url {
                format!("{announce_url:?}")
            } else {
                String::new()
            },
            if let Some(announce_method) = &self.announce_method {
                format!("{announce_method:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "status".to_string(),
            "announce_url".to_string(),
            "announce_method".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListConferenceResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conferences: Option<Vec<ApiV2010AccountConference>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListConferenceResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListConferenceResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(conferences) = &self.conferences {
                format!("{conferences:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "conferences".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateConferenceRecordingRequest {
    #[serde(rename = "Status")]
    pub status: ConferenceRecordingEnumStatus,
    #[doc = "Whether to record during a pause. Can be: `skip` or `silence` and the default is \
             `silence`. `skip` does not record during the pause period, while `silence` will \
             replace the actual audio of the call with silence during the pause period. This \
             parameter only applies when setting `status` is set to `paused`."]
    #[serde(
        rename = "PauseBehavior",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub pause_behavior: Option<String>,
}

impl std::fmt::Display for UpdateConferenceRecordingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateConferenceRecordingRequest {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.status),
            if let Some(pause_behavior) = &self.pause_behavior {
                format!("{pause_behavior:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec!["status".to_string(), "pause_behavior".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListConferenceRecordingResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub recordings: Option<Vec<ApiV2010AccountConferenceConferenceRecording>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListConferenceRecordingResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListConferenceRecordingResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(recordings) = &self.recordings {
                format!("{recordings:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "recordings".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[doc = "The HTTP method to use when calling `deauthorize_callback_url`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateConnectAppRequestDeauthorizeCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateConnectAppRequest {
    #[doc = "The URL to redirect the user to after we authenticate the user and obtain \
             authorization to access the Connect App."]
    #[serde(
        rename = "AuthorizeRedirectUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub authorize_redirect_url: Option<String>,
    #[doc = "The company name to set for the Connect App."]
    #[serde(
        rename = "CompanyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub company_name: Option<String>,
    #[doc = "The HTTP method to use when calling `deauthorize_callback_url`."]
    #[serde(
        rename = "DeauthorizeCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub deauthorize_callback_method: Option<UpdateConnectAppRequestDeauthorizeCallbackMethod>,
    #[doc = "The URL to call using the `deauthorize_callback_method` to de-authorize the Connect \
             App."]
    #[serde(
        rename = "DeauthorizeCallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub deauthorize_callback_url: Option<String>,
    #[doc = "A description of the Connect App."]
    #[serde(
        rename = "Description",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub description: Option<String>,
    #[doc = "A descriptive string that you create to describe the resource. It can be up to 64 \
             characters long."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
    #[doc = "A public URL where users can obtain more information about this Connect App."]
    #[serde(
        rename = "HomepageUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub homepage_url: Option<String>,
    #[doc = "A comma-separated list of the permissions you will request from the users of this \
             ConnectApp.  Can include: `get-all` and `post-all`."]
    #[serde(
        rename = "Permissions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub permissions: Option<Vec<ConnectAppEnumPermission>>,
}

impl std::fmt::Display for UpdateConnectAppRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateConnectAppRequest {
    const LENGTH: usize = 8;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(authorize_redirect_url) = &self.authorize_redirect_url {
                format!("{authorize_redirect_url:?}")
            } else {
                String::new()
            },
            if let Some(company_name) = &self.company_name {
                format!("{company_name:?}")
            } else {
                String::new()
            },
            if let Some(deauthorize_callback_method) = &self.deauthorize_callback_method {
                format!("{deauthorize_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(deauthorize_callback_url) = &self.deauthorize_callback_url {
                format!("{deauthorize_callback_url:?}")
            } else {
                String::new()
            },
            if let Some(description) = &self.description {
                format!("{description:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(homepage_url) = &self.homepage_url {
                format!("{homepage_url:?}")
            } else {
                String::new()
            },
            if let Some(permissions) = &self.permissions {
                format!("{permissions:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "authorize_redirect_url".to_string(),
            "company_name".to_string(),
            "deauthorize_callback_method".to_string(),
            "deauthorize_callback_url".to_string(),
            "description".to_string(),
            "friendly_name".to_string(),
            "homepage_url".to_string(),
            "permissions".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListConnectAppResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub connect_apps: Option<Vec<ApiV2010AccountConnectApp>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListConnectAppResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListConnectAppResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(connect_apps) = &self.connect_apps {
                format!("{connect_apps:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "connect_apps".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListDependentPhoneNumberResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dependent_phone_numbers: Option<Vec<ApiV2010AccountAddressDependentPhoneNumber>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListDependentPhoneNumberResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListDependentPhoneNumberResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(dependent_phone_numbers) = &self.dependent_phone_numbers {
                format!("{dependent_phone_numbers:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "dependent_phone_numbers".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[doc = "The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` \
         and defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateIncomingPhoneNumberRequestSmsFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and \
         defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateIncomingPhoneNumberRequestSmsMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and \
         defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateIncomingPhoneNumberRequestStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` \
         and defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateIncomingPhoneNumberRequestVoiceFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and \
         defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateIncomingPhoneNumberRequestVoiceMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateIncomingPhoneNumberRequest {
    #[doc = "The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the IncomingPhoneNumber resource to update.  For more information, see [Exchanging Numbers Between Subaccounts](https://www.twilio.com/docs/iam/api/subaccounts#exchanging-numbers)."]
    #[serde(
        rename = "AccountSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub account_sid: Option<String>,
    #[doc = "The API version to use for incoming calls made to the phone number. The default is \
             `2010-04-01`."]
    #[serde(
        rename = "ApiVersion",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub api_version: Option<String>,
    #[doc = "A descriptive string that you created to describe this phone number. It can be up to \
             64 characters long. By default, this is a formatted version of the phone number."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
    #[doc = "The SID of the application that should handle SMS messages sent to the number. If an \
             `sms_application_sid` is present, we ignore all of the `sms_*_url` urls and use \
             those set on the application."]
    #[serde(
        rename = "SmsApplicationSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_application_sid: Option<String>,
    #[doc = "The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or \
             `POST` and defaults to `POST`."]
    #[serde(
        rename = "SmsFallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_fallback_method: Option<UpdateIncomingPhoneNumberRequestSmsFallbackMethod>,
    #[doc = "The URL that we should call when an error occurs while requesting or executing the \
             TwiML defined by `sms_url`."]
    #[serde(
        rename = "SmsFallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_fallback_url: Option<String>,
    #[doc = "The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and \
             defaults to `POST`."]
    #[serde(rename = "SmsMethod", default, skip_serializing_if = "Option::is_none")]
    pub sms_method: Option<UpdateIncomingPhoneNumberRequestSmsMethod>,
    #[doc = "The URL we should call when the phone number receives an incoming SMS message."]
    #[serde(rename = "SmsUrl", default, skip_serializing_if = "Option::is_none")]
    pub sms_url: Option<String>,
    #[doc = "The URL we should call using the `status_callback_method` to send status information \
             to your application."]
    #[serde(
        rename = "StatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback: Option<String>,
    #[doc = "The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and \
             defaults to `POST`."]
    #[serde(
        rename = "StatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback_method: Option<UpdateIncomingPhoneNumberRequestStatusCallbackMethod>,
    #[doc = "The SID of the application we should use to handle phone calls to the phone number. \
             If a `voice_application_sid` is present, we ignore all of the voice urls and use \
             only those set on the application. Setting a `voice_application_sid` will \
             automatically delete your `trunk_sid` and vice versa."]
    #[serde(
        rename = "VoiceApplicationSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_application_sid: Option<String>,
    #[doc = "Whether to lookup the caller's name from the CNAM database and post it to your app. \
             Can be: `true` or `false` and defaults to `false`."]
    #[serde(
        rename = "VoiceCallerIdLookup",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_caller_id_lookup: Option<bool>,
    #[doc = "The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or \
             `POST` and defaults to `POST`."]
    #[serde(
        rename = "VoiceFallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_fallback_method: Option<UpdateIncomingPhoneNumberRequestVoiceFallbackMethod>,
    #[doc = "The URL that we should call when an error occurs retrieving or executing the TwiML \
             requested by `url`."]
    #[serde(
        rename = "VoiceFallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_fallback_url: Option<String>,
    #[doc = "The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and \
             defaults to `POST`."]
    #[serde(
        rename = "VoiceMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_method: Option<UpdateIncomingPhoneNumberRequestVoiceMethod>,
    #[doc = "The URL that we should call to answer a call to the phone number. The `voice_url` \
             will not be called if a `voice_application_sid` or a `trunk_sid` is set."]
    #[serde(rename = "VoiceUrl", default, skip_serializing_if = "Option::is_none")]
    pub voice_url: Option<String>,
    #[serde(
        rename = "EmergencyStatus",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub emergency_status: Option<IncomingPhoneNumberEnumEmergencyStatus>,
    #[doc = "The SID of the emergency address configuration to use for emergency calling from \
             this phone number."]
    #[serde(
        rename = "EmergencyAddressSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub emergency_address_sid: Option<String>,
    #[doc = "The SID of the Trunk we should use to handle phone calls to the phone number. If a \
             `trunk_sid` is present, we ignore all of the voice urls and voice applications and \
             use only those set on the Trunk. Setting a `trunk_sid` will automatically delete \
             your `voice_application_sid` and vice versa."]
    #[serde(rename = "TrunkSid", default, skip_serializing_if = "Option::is_none")]
    pub trunk_sid: Option<String>,
    #[serde(
        rename = "VoiceReceiveMode",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_receive_mode: Option<IncomingPhoneNumberEnumVoiceReceiveMode>,
    #[doc = "The SID of the Identity resource that we should associate with the phone number. \
             Some regions require an identity to meet local regulations."]
    #[serde(
        rename = "IdentitySid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub identity_sid: Option<String>,
    #[doc = "The SID of the Address resource we should associate with the phone number. Some \
             regions require addresses to meet local regulations."]
    #[serde(
        rename = "AddressSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub address_sid: Option<String>,
    #[doc = "The SID of the Bundle resource that you associate with the phone number. Some \
             regions require a Bundle to meet local Regulations."]
    #[serde(rename = "BundleSid", default, skip_serializing_if = "Option::is_none")]
    pub bundle_sid: Option<String>,
}

impl std::fmt::Display for UpdateIncomingPhoneNumberRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateIncomingPhoneNumberRequest {
    const LENGTH: usize = 23;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(account_sid) = &self.account_sid {
                format!("{account_sid:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(sms_application_sid) = &self.sms_application_sid {
                format!("{sms_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_method) = &self.sms_fallback_method {
                format!("{sms_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_url) = &self.sms_fallback_url {
                format!("{sms_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(sms_method) = &self.sms_method {
                format!("{sms_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_url) = &self.sms_url {
                format!("{sms_url:?}")
            } else {
                String::new()
            },
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_application_sid) = &self.voice_application_sid {
                format!("{voice_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(voice_caller_id_lookup) = &self.voice_caller_id_lookup {
                format!("{voice_caller_id_lookup:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_method) = &self.voice_fallback_method {
                format!("{voice_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_url) = &self.voice_fallback_url {
                format!("{voice_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_method) = &self.voice_method {
                format!("{voice_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_url) = &self.voice_url {
                format!("{voice_url:?}")
            } else {
                String::new()
            },
            if let Some(emergency_status) = &self.emergency_status {
                format!("{emergency_status:?}")
            } else {
                String::new()
            },
            if let Some(emergency_address_sid) = &self.emergency_address_sid {
                format!("{emergency_address_sid:?}")
            } else {
                String::new()
            },
            if let Some(trunk_sid) = &self.trunk_sid {
                format!("{trunk_sid:?}")
            } else {
                String::new()
            },
            if let Some(voice_receive_mode) = &self.voice_receive_mode {
                format!("{voice_receive_mode:?}")
            } else {
                String::new()
            },
            if let Some(identity_sid) = &self.identity_sid {
                format!("{identity_sid:?}")
            } else {
                String::new()
            },
            if let Some(address_sid) = &self.address_sid {
                format!("{address_sid:?}")
            } else {
                String::new()
            },
            if let Some(bundle_sid) = &self.bundle_sid {
                format!("{bundle_sid:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "account_sid".to_string(),
            "api_version".to_string(),
            "friendly_name".to_string(),
            "sms_application_sid".to_string(),
            "sms_fallback_method".to_string(),
            "sms_fallback_url".to_string(),
            "sms_method".to_string(),
            "sms_url".to_string(),
            "status_callback".to_string(),
            "status_callback_method".to_string(),
            "voice_application_sid".to_string(),
            "voice_caller_id_lookup".to_string(),
            "voice_fallback_method".to_string(),
            "voice_fallback_url".to_string(),
            "voice_method".to_string(),
            "voice_url".to_string(),
            "emergency_status".to_string(),
            "emergency_address_sid".to_string(),
            "trunk_sid".to_string(),
            "voice_receive_mode".to_string(),
            "identity_sid".to_string(),
            "address_sid".to_string(),
            "bundle_sid".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListIncomingPhoneNumberResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub incoming_phone_numbers: Option<Vec<ApiV2010AccountIncomingPhoneNumber>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListIncomingPhoneNumberResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListIncomingPhoneNumberResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(incoming_phone_numbers) = &self.incoming_phone_numbers {
                format!("{incoming_phone_numbers:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "incoming_phone_numbers".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[doc = "The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` \
         and defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberRequestSmsFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and \
         defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberRequestSmsMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and \
         defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberRequestStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` \
         and defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberRequestVoiceFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and \
         defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberRequestVoiceMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateIncomingPhoneNumberRequest {
    #[doc = "The API version to use for incoming calls made to the new phone number. The default \
             is `2010-04-01`."]
    #[serde(
        rename = "ApiVersion",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub api_version: Option<String>,
    #[doc = "A descriptive string that you created to describe the new phone number. It can be up \
             to 64 characters long. By default, this is a formatted version of the new phone \
             number."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
    #[doc = "The SID of the application that should handle SMS messages sent to the new phone \
             number. If an `sms_application_sid` is present, we ignore all of the `sms_*_url` \
             urls and use those set on the application."]
    #[serde(
        rename = "SmsApplicationSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_application_sid: Option<String>,
    #[doc = "The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or \
             `POST` and defaults to `POST`."]
    #[serde(
        rename = "SmsFallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_fallback_method: Option<CreateIncomingPhoneNumberRequestSmsFallbackMethod>,
    #[doc = "The URL that we should call when an error occurs while requesting or executing the \
             TwiML defined by `sms_url`."]
    #[serde(
        rename = "SmsFallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_fallback_url: Option<String>,
    #[doc = "The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and \
             defaults to `POST`."]
    #[serde(rename = "SmsMethod", default, skip_serializing_if = "Option::is_none")]
    pub sms_method: Option<CreateIncomingPhoneNumberRequestSmsMethod>,
    #[doc = "The URL we should call when the new phone number receives an incoming SMS message."]
    #[serde(rename = "SmsUrl", default, skip_serializing_if = "Option::is_none")]
    pub sms_url: Option<String>,
    #[doc = "The URL we should call using the `status_callback_method` to send status information \
             to your application."]
    #[serde(
        rename = "StatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback: Option<String>,
    #[doc = "The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and \
             defaults to `POST`."]
    #[serde(
        rename = "StatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback_method: Option<CreateIncomingPhoneNumberRequestStatusCallbackMethod>,
    #[doc = "The SID of the application we should use to handle calls to the new phone number. If \
             a `voice_application_sid` is present, we ignore all of the voice urls and use only \
             those set on the application. Setting a `voice_application_sid` will automatically \
             delete your `trunk_sid` and vice versa."]
    #[serde(
        rename = "VoiceApplicationSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_application_sid: Option<String>,
    #[doc = "Whether to lookup the caller's name from the CNAM database and post it to your app. \
             Can be: `true` or `false` and defaults to `false`."]
    #[serde(
        rename = "VoiceCallerIdLookup",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_caller_id_lookup: Option<bool>,
    #[doc = "The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or \
             `POST` and defaults to `POST`."]
    #[serde(
        rename = "VoiceFallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_fallback_method: Option<CreateIncomingPhoneNumberRequestVoiceFallbackMethod>,
    #[doc = "The URL that we should call when an error occurs retrieving or executing the TwiML \
             requested by `url`."]
    #[serde(
        rename = "VoiceFallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_fallback_url: Option<String>,
    #[doc = "The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and \
             defaults to `POST`."]
    #[serde(
        rename = "VoiceMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_method: Option<CreateIncomingPhoneNumberRequestVoiceMethod>,
    #[doc = "The URL that we should call to answer a call to the new phone number. The \
             `voice_url` will not be called if a `voice_application_sid` or a `trunk_sid` is set."]
    #[serde(rename = "VoiceUrl", default, skip_serializing_if = "Option::is_none")]
    pub voice_url: Option<String>,
    #[serde(
        rename = "EmergencyStatus",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub emergency_status: Option<IncomingPhoneNumberEnumEmergencyStatus>,
    #[doc = "The SID of the emergency address configuration to use for emergency calling from the \
             new phone number."]
    #[serde(
        rename = "EmergencyAddressSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub emergency_address_sid: Option<String>,
    #[doc = "The SID of the Trunk we should use to handle calls to the new phone number. If a \
             `trunk_sid` is present, we ignore all of the voice urls and voice applications and \
             use only those set on the Trunk. Setting a `trunk_sid` will automatically delete \
             your `voice_application_sid` and vice versa."]
    #[serde(rename = "TrunkSid", default, skip_serializing_if = "Option::is_none")]
    pub trunk_sid: Option<String>,
    #[doc = "The SID of the Identity resource that we should associate with the new phone number. \
             Some regions require an identity to meet local regulations."]
    #[serde(
        rename = "IdentitySid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub identity_sid: Option<String>,
    #[doc = "The SID of the Address resource we should associate with the new phone number. Some \
             regions require addresses to meet local regulations."]
    #[serde(
        rename = "AddressSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub address_sid: Option<String>,
    #[serde(
        rename = "VoiceReceiveMode",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_receive_mode: Option<IncomingPhoneNumberEnumVoiceReceiveMode>,
    #[doc = "The SID of the Bundle resource that you associate with the phone number. Some \
             regions require a Bundle to meet local Regulations."]
    #[serde(rename = "BundleSid", default, skip_serializing_if = "Option::is_none")]
    pub bundle_sid: Option<String>,
    #[doc = "The phone number to purchase specified in [E.164](https://www.twilio.com/docs/glossary/what-e164) format.  E.164 phone numbers consist of a + followed by the country code and subscriber number without punctuation characters. For example, +14155551234."]
    #[serde(
        rename = "PhoneNumber",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub phone_number: phone_number::PhoneNumber,
    #[doc = "The desired area code for your new incoming phone number. Can be any three-digit, US \
             or Canada area code. We will provision an available phone number within this area \
             code for you. **You must provide an `area_code` or a `phone_number`.** (US and \
             Canada only)."]
    #[serde(rename = "AreaCode", default, skip_serializing_if = "Option::is_none")]
    pub area_code: Option<String>,
}

impl std::fmt::Display for CreateIncomingPhoneNumberRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateIncomingPhoneNumberRequest {
    const LENGTH: usize = 24;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(sms_application_sid) = &self.sms_application_sid {
                format!("{sms_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_method) = &self.sms_fallback_method {
                format!("{sms_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_url) = &self.sms_fallback_url {
                format!("{sms_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(sms_method) = &self.sms_method {
                format!("{sms_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_url) = &self.sms_url {
                format!("{sms_url:?}")
            } else {
                String::new()
            },
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_application_sid) = &self.voice_application_sid {
                format!("{voice_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(voice_caller_id_lookup) = &self.voice_caller_id_lookup {
                format!("{voice_caller_id_lookup:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_method) = &self.voice_fallback_method {
                format!("{voice_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_url) = &self.voice_fallback_url {
                format!("{voice_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_method) = &self.voice_method {
                format!("{voice_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_url) = &self.voice_url {
                format!("{voice_url:?}")
            } else {
                String::new()
            },
            if let Some(emergency_status) = &self.emergency_status {
                format!("{emergency_status:?}")
            } else {
                String::new()
            },
            if let Some(emergency_address_sid) = &self.emergency_address_sid {
                format!("{emergency_address_sid:?}")
            } else {
                String::new()
            },
            if let Some(trunk_sid) = &self.trunk_sid {
                format!("{trunk_sid:?}")
            } else {
                String::new()
            },
            if let Some(identity_sid) = &self.identity_sid {
                format!("{identity_sid:?}")
            } else {
                String::new()
            },
            if let Some(address_sid) = &self.address_sid {
                format!("{address_sid:?}")
            } else {
                String::new()
            },
            if let Some(voice_receive_mode) = &self.voice_receive_mode {
                format!("{voice_receive_mode:?}")
            } else {
                String::new()
            },
            if let Some(bundle_sid) = &self.bundle_sid {
                format!("{bundle_sid:?}")
            } else {
                String::new()
            },
            format!("{:?}", self.phone_number),
            if let Some(area_code) = &self.area_code {
                format!("{area_code:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "api_version".to_string(),
            "friendly_name".to_string(),
            "sms_application_sid".to_string(),
            "sms_fallback_method".to_string(),
            "sms_fallback_url".to_string(),
            "sms_method".to_string(),
            "sms_url".to_string(),
            "status_callback".to_string(),
            "status_callback_method".to_string(),
            "voice_application_sid".to_string(),
            "voice_caller_id_lookup".to_string(),
            "voice_fallback_method".to_string(),
            "voice_fallback_url".to_string(),
            "voice_method".to_string(),
            "voice_url".to_string(),
            "emergency_status".to_string(),
            "emergency_address_sid".to_string(),
            "trunk_sid".to_string(),
            "identity_sid".to_string(),
            "address_sid".to_string(),
            "voice_receive_mode".to_string(),
            "bundle_sid".to_string(),
            "phone_number".to_string(),
            "area_code".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListIncomingPhoneNumberAssignedAddOnResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assigned_add_ons:
        Option<Vec<ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListIncomingPhoneNumberAssignedAddOnResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListIncomingPhoneNumberAssignedAddOnResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(assigned_add_ons) = &self.assigned_add_ons {
                format!("{assigned_add_ons:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "assigned_add_ons".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateIncomingPhoneNumberAssignedAddOnRequest {
    #[doc = "The SID that identifies the Add-on installation."]
    #[serde(rename = "InstalledAddOnSid")]
    pub installed_add_on_sid: String,
}

impl std::fmt::Display for CreateIncomingPhoneNumberAssignedAddOnRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateIncomingPhoneNumberAssignedAddOnRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![self.installed_add_on_sid.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["installed_add_on_sid".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListIncomingPhoneNumberAssignedAddOnExtensionResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub extensions : Option < Vec < ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOnIncomingPhoneNumberAssignedAddOnExtension > > , # [serde (default , skip_serializing_if = "Option::is_none")] pub end : Option < i64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub first_page_uri : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub next_page_uri : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub page : Option < i64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub page_size : Option < i64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub previous_page_uri : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub start : Option < i64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub uri : Option < String > , }

impl std::fmt::Display for ListIncomingPhoneNumberAssignedAddOnExtensionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListIncomingPhoneNumberAssignedAddOnExtensionResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(extensions) = &self.extensions {
                format!("{extensions:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "extensions".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListIncomingPhoneNumberLocalResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub incoming_phone_numbers:
        Option<Vec<ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocal>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListIncomingPhoneNumberLocalResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListIncomingPhoneNumberLocalResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(incoming_phone_numbers) = &self.incoming_phone_numbers {
                format!("{incoming_phone_numbers:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "incoming_phone_numbers".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[doc = "The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` \
         and defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberLocalRequestSmsFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and \
         defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberLocalRequestSmsMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and \
         defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberLocalRequestStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` \
         and defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberLocalRequestVoiceFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and \
         defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberLocalRequestVoiceMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateIncomingPhoneNumberLocalRequest {
    #[doc = "The phone number to purchase specified in [E.164](https://www.twilio.com/docs/glossary/what-e164) format.  E.164 phone numbers consist of a + followed by the country code and subscriber number without punctuation characters. For example, +14155551234."]
    #[serde(
        rename = "PhoneNumber",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub phone_number: phone_number::PhoneNumber,
    #[doc = "The API version to use for incoming calls made to the new phone number. The default \
             is `2010-04-01`."]
    #[serde(
        rename = "ApiVersion",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub api_version: Option<String>,
    #[doc = "A descriptive string that you created to describe the new phone number. It can be up \
             to 64 characters long. By default, this is a formatted version of the phone number."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
    #[doc = "The SID of the application that should handle SMS messages sent to the new phone \
             number. If an `sms_application_sid` is present, we ignore all of the `sms_*_url` \
             urls and use those set on the application."]
    #[serde(
        rename = "SmsApplicationSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_application_sid: Option<String>,
    #[doc = "The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or \
             `POST` and defaults to `POST`."]
    #[serde(
        rename = "SmsFallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_fallback_method: Option<CreateIncomingPhoneNumberLocalRequestSmsFallbackMethod>,
    #[doc = "The URL that we should call when an error occurs while requesting or executing the \
             TwiML defined by `sms_url`."]
    #[serde(
        rename = "SmsFallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_fallback_url: Option<String>,
    #[doc = "The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and \
             defaults to `POST`."]
    #[serde(rename = "SmsMethod", default, skip_serializing_if = "Option::is_none")]
    pub sms_method: Option<CreateIncomingPhoneNumberLocalRequestSmsMethod>,
    #[doc = "The URL we should call when the new phone number receives an incoming SMS message."]
    #[serde(rename = "SmsUrl", default, skip_serializing_if = "Option::is_none")]
    pub sms_url: Option<String>,
    #[doc = "The URL we should call using the `status_callback_method` to send status information \
             to your application."]
    #[serde(
        rename = "StatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback: Option<String>,
    #[doc = "The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and \
             defaults to `POST`."]
    #[serde(
        rename = "StatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback_method: Option<CreateIncomingPhoneNumberLocalRequestStatusCallbackMethod>,
    #[doc = "The SID of the application we should use to handle calls to the new phone number. If \
             a `voice_application_sid` is present, we ignore all of the voice urls and use only \
             those set on the application. Setting a `voice_application_sid` will automatically \
             delete your `trunk_sid` and vice versa."]
    #[serde(
        rename = "VoiceApplicationSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_application_sid: Option<String>,
    #[doc = "Whether to lookup the caller's name from the CNAM database and post it to your app. \
             Can be: `true` or `false` and defaults to `false`."]
    #[serde(
        rename = "VoiceCallerIdLookup",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_caller_id_lookup: Option<bool>,
    #[doc = "The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or \
             `POST` and defaults to `POST`."]
    #[serde(
        rename = "VoiceFallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_fallback_method: Option<CreateIncomingPhoneNumberLocalRequestVoiceFallbackMethod>,
    #[doc = "The URL that we should call when an error occurs retrieving or executing the TwiML \
             requested by `url`."]
    #[serde(
        rename = "VoiceFallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_fallback_url: Option<String>,
    #[doc = "The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and \
             defaults to `POST`."]
    #[serde(
        rename = "VoiceMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_method: Option<CreateIncomingPhoneNumberLocalRequestVoiceMethod>,
    #[doc = "The URL that we should call to answer a call to the new phone number. The \
             `voice_url` will not be called if a `voice_application_sid` or a `trunk_sid` is set."]
    #[serde(rename = "VoiceUrl", default, skip_serializing_if = "Option::is_none")]
    pub voice_url: Option<String>,
    #[doc = "The SID of the Identity resource that we should associate with the new phone number. \
             Some regions require an identity to meet local regulations."]
    #[serde(
        rename = "IdentitySid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub identity_sid: Option<String>,
    #[doc = "The SID of the Address resource we should associate with the new phone number. Some \
             regions require addresses to meet local regulations."]
    #[serde(
        rename = "AddressSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub address_sid: Option<String>,
    #[serde(
        rename = "EmergencyStatus",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub emergency_status: Option<IncomingPhoneNumberLocalEnumEmergencyStatus>,
    #[doc = "The SID of the emergency address configuration to use for emergency calling from the \
             new phone number."]
    #[serde(
        rename = "EmergencyAddressSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub emergency_address_sid: Option<String>,
    #[doc = "The SID of the Trunk we should use to handle calls to the new phone number. If a \
             `trunk_sid` is present, we ignore all of the voice urls and voice applications and \
             use only those set on the Trunk. Setting a `trunk_sid` will automatically delete \
             your `voice_application_sid` and vice versa."]
    #[serde(rename = "TrunkSid", default, skip_serializing_if = "Option::is_none")]
    pub trunk_sid: Option<String>,
    #[serde(
        rename = "VoiceReceiveMode",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_receive_mode: Option<IncomingPhoneNumberLocalEnumVoiceReceiveMode>,
    #[doc = "The SID of the Bundle resource that you associate with the phone number. Some \
             regions require a Bundle to meet local Regulations."]
    #[serde(rename = "BundleSid", default, skip_serializing_if = "Option::is_none")]
    pub bundle_sid: Option<String>,
}

impl std::fmt::Display for CreateIncomingPhoneNumberLocalRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateIncomingPhoneNumberLocalRequest {
    const LENGTH: usize = 23;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.phone_number),
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(sms_application_sid) = &self.sms_application_sid {
                format!("{sms_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_method) = &self.sms_fallback_method {
                format!("{sms_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_url) = &self.sms_fallback_url {
                format!("{sms_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(sms_method) = &self.sms_method {
                format!("{sms_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_url) = &self.sms_url {
                format!("{sms_url:?}")
            } else {
                String::new()
            },
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_application_sid) = &self.voice_application_sid {
                format!("{voice_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(voice_caller_id_lookup) = &self.voice_caller_id_lookup {
                format!("{voice_caller_id_lookup:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_method) = &self.voice_fallback_method {
                format!("{voice_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_url) = &self.voice_fallback_url {
                format!("{voice_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_method) = &self.voice_method {
                format!("{voice_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_url) = &self.voice_url {
                format!("{voice_url:?}")
            } else {
                String::new()
            },
            if let Some(identity_sid) = &self.identity_sid {
                format!("{identity_sid:?}")
            } else {
                String::new()
            },
            if let Some(address_sid) = &self.address_sid {
                format!("{address_sid:?}")
            } else {
                String::new()
            },
            if let Some(emergency_status) = &self.emergency_status {
                format!("{emergency_status:?}")
            } else {
                String::new()
            },
            if let Some(emergency_address_sid) = &self.emergency_address_sid {
                format!("{emergency_address_sid:?}")
            } else {
                String::new()
            },
            if let Some(trunk_sid) = &self.trunk_sid {
                format!("{trunk_sid:?}")
            } else {
                String::new()
            },
            if let Some(voice_receive_mode) = &self.voice_receive_mode {
                format!("{voice_receive_mode:?}")
            } else {
                String::new()
            },
            if let Some(bundle_sid) = &self.bundle_sid {
                format!("{bundle_sid:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "phone_number".to_string(),
            "api_version".to_string(),
            "friendly_name".to_string(),
            "sms_application_sid".to_string(),
            "sms_fallback_method".to_string(),
            "sms_fallback_url".to_string(),
            "sms_method".to_string(),
            "sms_url".to_string(),
            "status_callback".to_string(),
            "status_callback_method".to_string(),
            "voice_application_sid".to_string(),
            "voice_caller_id_lookup".to_string(),
            "voice_fallback_method".to_string(),
            "voice_fallback_url".to_string(),
            "voice_method".to_string(),
            "voice_url".to_string(),
            "identity_sid".to_string(),
            "address_sid".to_string(),
            "emergency_status".to_string(),
            "emergency_address_sid".to_string(),
            "trunk_sid".to_string(),
            "voice_receive_mode".to_string(),
            "bundle_sid".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListIncomingPhoneNumberMobileResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub incoming_phone_numbers:
        Option<Vec<ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobile>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListIncomingPhoneNumberMobileResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListIncomingPhoneNumberMobileResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(incoming_phone_numbers) = &self.incoming_phone_numbers {
                format!("{incoming_phone_numbers:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "incoming_phone_numbers".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[doc = "The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` \
         and defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberMobileRequestSmsFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and \
         defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberMobileRequestSmsMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and \
         defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberMobileRequestStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` \
         and defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberMobileRequestVoiceFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and \
         defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberMobileRequestVoiceMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateIncomingPhoneNumberMobileRequest {
    #[doc = "The phone number to purchase specified in [E.164](https://www.twilio.com/docs/glossary/what-e164) format.  E.164 phone numbers consist of a + followed by the country code and subscriber number without punctuation characters. For example, +14155551234."]
    #[serde(
        rename = "PhoneNumber",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub phone_number: phone_number::PhoneNumber,
    #[doc = "The API version to use for incoming calls made to the new phone number. The default \
             is `2010-04-01`."]
    #[serde(
        rename = "ApiVersion",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub api_version: Option<String>,
    #[doc = "A descriptive string that you created to describe the new phone number. It can be up \
             to 64 characters long. By default, the is a formatted version of the phone number."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
    #[doc = "The SID of the application that should handle SMS messages sent to the new phone \
             number. If an `sms_application_sid` is present, we ignore all of the `sms_*_url` \
             urls and use those of the application."]
    #[serde(
        rename = "SmsApplicationSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_application_sid: Option<String>,
    #[doc = "The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or \
             `POST` and defaults to `POST`."]
    #[serde(
        rename = "SmsFallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_fallback_method: Option<CreateIncomingPhoneNumberMobileRequestSmsFallbackMethod>,
    #[doc = "The URL that we should call when an error occurs while requesting or executing the \
             TwiML defined by `sms_url`."]
    #[serde(
        rename = "SmsFallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_fallback_url: Option<String>,
    #[doc = "The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and \
             defaults to `POST`."]
    #[serde(rename = "SmsMethod", default, skip_serializing_if = "Option::is_none")]
    pub sms_method: Option<CreateIncomingPhoneNumberMobileRequestSmsMethod>,
    #[doc = "The URL we should call when the new phone number receives an incoming SMS message."]
    #[serde(rename = "SmsUrl", default, skip_serializing_if = "Option::is_none")]
    pub sms_url: Option<String>,
    #[doc = "The URL we should call using the `status_callback_method` to send status information \
             to your application."]
    #[serde(
        rename = "StatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback: Option<String>,
    #[doc = "The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and \
             defaults to `POST`."]
    #[serde(
        rename = "StatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback_method: Option<CreateIncomingPhoneNumberMobileRequestStatusCallbackMethod>,
    #[doc = "The SID of the application we should use to handle calls to the new phone number. If \
             a `voice_application_sid` is present, we ignore all of the voice urls and use only \
             those set on the application. Setting a `voice_application_sid` will automatically \
             delete your `trunk_sid` and vice versa."]
    #[serde(
        rename = "VoiceApplicationSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_application_sid: Option<String>,
    #[doc = "Whether to lookup the caller's name from the CNAM database and post it to your app. \
             Can be: `true` or `false` and defaults to `false`."]
    #[serde(
        rename = "VoiceCallerIdLookup",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_caller_id_lookup: Option<bool>,
    #[doc = "The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or \
             `POST` and defaults to `POST`."]
    #[serde(
        rename = "VoiceFallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_fallback_method: Option<CreateIncomingPhoneNumberMobileRequestVoiceFallbackMethod>,
    #[doc = "The URL that we should call when an error occurs retrieving or executing the TwiML \
             requested by `url`."]
    #[serde(
        rename = "VoiceFallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_fallback_url: Option<String>,
    #[doc = "The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and \
             defaults to `POST`."]
    #[serde(
        rename = "VoiceMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_method: Option<CreateIncomingPhoneNumberMobileRequestVoiceMethod>,
    #[doc = "The URL that we should call to answer a call to the new phone number. The \
             `voice_url` will not be called if a `voice_application_sid` or a `trunk_sid` is set."]
    #[serde(rename = "VoiceUrl", default, skip_serializing_if = "Option::is_none")]
    pub voice_url: Option<String>,
    #[doc = "The SID of the Identity resource that we should associate with the new phone number. \
             Some regions require an identity to meet local regulations."]
    #[serde(
        rename = "IdentitySid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub identity_sid: Option<String>,
    #[doc = "The SID of the Address resource we should associate with the new phone number. Some \
             regions require addresses to meet local regulations."]
    #[serde(
        rename = "AddressSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub address_sid: Option<String>,
    #[serde(
        rename = "EmergencyStatus",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub emergency_status: Option<IncomingPhoneNumberMobileEnumEmergencyStatus>,
    #[doc = "The SID of the emergency address configuration to use for emergency calling from the \
             new phone number."]
    #[serde(
        rename = "EmergencyAddressSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub emergency_address_sid: Option<String>,
    #[doc = "The SID of the Trunk we should use to handle calls to the new phone number. If a \
             `trunk_sid` is present, we ignore all of the voice urls and voice applications and \
             use only those set on the Trunk. Setting a `trunk_sid` will automatically delete \
             your `voice_application_sid` and vice versa."]
    #[serde(rename = "TrunkSid", default, skip_serializing_if = "Option::is_none")]
    pub trunk_sid: Option<String>,
    #[serde(
        rename = "VoiceReceiveMode",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_receive_mode: Option<IncomingPhoneNumberMobileEnumVoiceReceiveMode>,
    #[doc = "The SID of the Bundle resource that you associate with the phone number. Some \
             regions require a Bundle to meet local Regulations."]
    #[serde(rename = "BundleSid", default, skip_serializing_if = "Option::is_none")]
    pub bundle_sid: Option<String>,
}

impl std::fmt::Display for CreateIncomingPhoneNumberMobileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateIncomingPhoneNumberMobileRequest {
    const LENGTH: usize = 23;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.phone_number),
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(sms_application_sid) = &self.sms_application_sid {
                format!("{sms_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_method) = &self.sms_fallback_method {
                format!("{sms_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_url) = &self.sms_fallback_url {
                format!("{sms_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(sms_method) = &self.sms_method {
                format!("{sms_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_url) = &self.sms_url {
                format!("{sms_url:?}")
            } else {
                String::new()
            },
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_application_sid) = &self.voice_application_sid {
                format!("{voice_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(voice_caller_id_lookup) = &self.voice_caller_id_lookup {
                format!("{voice_caller_id_lookup:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_method) = &self.voice_fallback_method {
                format!("{voice_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_url) = &self.voice_fallback_url {
                format!("{voice_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_method) = &self.voice_method {
                format!("{voice_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_url) = &self.voice_url {
                format!("{voice_url:?}")
            } else {
                String::new()
            },
            if let Some(identity_sid) = &self.identity_sid {
                format!("{identity_sid:?}")
            } else {
                String::new()
            },
            if let Some(address_sid) = &self.address_sid {
                format!("{address_sid:?}")
            } else {
                String::new()
            },
            if let Some(emergency_status) = &self.emergency_status {
                format!("{emergency_status:?}")
            } else {
                String::new()
            },
            if let Some(emergency_address_sid) = &self.emergency_address_sid {
                format!("{emergency_address_sid:?}")
            } else {
                String::new()
            },
            if let Some(trunk_sid) = &self.trunk_sid {
                format!("{trunk_sid:?}")
            } else {
                String::new()
            },
            if let Some(voice_receive_mode) = &self.voice_receive_mode {
                format!("{voice_receive_mode:?}")
            } else {
                String::new()
            },
            if let Some(bundle_sid) = &self.bundle_sid {
                format!("{bundle_sid:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "phone_number".to_string(),
            "api_version".to_string(),
            "friendly_name".to_string(),
            "sms_application_sid".to_string(),
            "sms_fallback_method".to_string(),
            "sms_fallback_url".to_string(),
            "sms_method".to_string(),
            "sms_url".to_string(),
            "status_callback".to_string(),
            "status_callback_method".to_string(),
            "voice_application_sid".to_string(),
            "voice_caller_id_lookup".to_string(),
            "voice_fallback_method".to_string(),
            "voice_fallback_url".to_string(),
            "voice_method".to_string(),
            "voice_url".to_string(),
            "identity_sid".to_string(),
            "address_sid".to_string(),
            "emergency_status".to_string(),
            "emergency_address_sid".to_string(),
            "trunk_sid".to_string(),
            "voice_receive_mode".to_string(),
            "bundle_sid".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListIncomingPhoneNumberTollFreeResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub incoming_phone_numbers:
        Option<Vec<ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFree>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListIncomingPhoneNumberTollFreeResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListIncomingPhoneNumberTollFreeResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(incoming_phone_numbers) = &self.incoming_phone_numbers {
                format!("{incoming_phone_numbers:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "incoming_phone_numbers".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[doc = "The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` \
         and defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberTollFreeRequestSmsFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and \
         defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberTollFreeRequestSmsMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and \
         defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberTollFreeRequestStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` \
         and defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberTollFreeRequestVoiceFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and \
         defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateIncomingPhoneNumberTollFreeRequestVoiceMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateIncomingPhoneNumberTollFreeRequest {
    #[doc = "The phone number to purchase specified in [E.164](https://www.twilio.com/docs/glossary/what-e164) format.  E.164 phone numbers consist of a + followed by the country code and subscriber number without punctuation characters. For example, +14155551234."]
    #[serde(
        rename = "PhoneNumber",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub phone_number: phone_number::PhoneNumber,
    #[doc = "The API version to use for incoming calls made to the new phone number. The default \
             is `2010-04-01`."]
    #[serde(
        rename = "ApiVersion",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub api_version: Option<String>,
    #[doc = "A descriptive string that you created to describe the new phone number. It can be up \
             to 64 characters long. By default, this is a formatted version of the phone number."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
    #[doc = "The SID of the application that should handle SMS messages sent to the new phone \
             number. If an `sms_application_sid` is present, we ignore all `sms_*_url` values and \
             use those of the application."]
    #[serde(
        rename = "SmsApplicationSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_application_sid: Option<String>,
    #[doc = "The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or \
             `POST` and defaults to `POST`."]
    #[serde(
        rename = "SmsFallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_fallback_method: Option<CreateIncomingPhoneNumberTollFreeRequestSmsFallbackMethod>,
    #[doc = "The URL that we should call when an error occurs while requesting or executing the \
             TwiML defined by `sms_url`."]
    #[serde(
        rename = "SmsFallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_fallback_url: Option<String>,
    #[doc = "The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and \
             defaults to `POST`."]
    #[serde(rename = "SmsMethod", default, skip_serializing_if = "Option::is_none")]
    pub sms_method: Option<CreateIncomingPhoneNumberTollFreeRequestSmsMethod>,
    #[doc = "The URL we should call when the new phone number receives an incoming SMS message."]
    #[serde(rename = "SmsUrl", default, skip_serializing_if = "Option::is_none")]
    pub sms_url: Option<String>,
    #[doc = "The URL we should call using the `status_callback_method` to send status information \
             to your application."]
    #[serde(
        rename = "StatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback: Option<String>,
    #[doc = "The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and \
             defaults to `POST`."]
    #[serde(
        rename = "StatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback_method:
        Option<CreateIncomingPhoneNumberTollFreeRequestStatusCallbackMethod>,
    #[doc = "The SID of the application we should use to handle calls to the new phone number. If \
             a `voice_application_sid` is present, we ignore all of the voice urls and use those \
             set on the application. Setting a `voice_application_sid` will automatically delete \
             your `trunk_sid` and vice versa."]
    #[serde(
        rename = "VoiceApplicationSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_application_sid: Option<String>,
    #[doc = "Whether to lookup the caller's name from the CNAM database and post it to your app. \
             Can be: `true` or `false` and defaults to `false`."]
    #[serde(
        rename = "VoiceCallerIdLookup",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_caller_id_lookup: Option<bool>,
    #[doc = "The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or \
             `POST` and defaults to `POST`."]
    #[serde(
        rename = "VoiceFallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_fallback_method: Option<CreateIncomingPhoneNumberTollFreeRequestVoiceFallbackMethod>,
    #[doc = "The URL that we should call when an error occurs retrieving or executing the TwiML \
             requested by `url`."]
    #[serde(
        rename = "VoiceFallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_fallback_url: Option<String>,
    #[doc = "The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and \
             defaults to `POST`."]
    #[serde(
        rename = "VoiceMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_method: Option<CreateIncomingPhoneNumberTollFreeRequestVoiceMethod>,
    #[doc = "The URL that we should call to answer a call to the new phone number. The \
             `voice_url` will not be called if a `voice_application_sid` or a `trunk_sid` is set."]
    #[serde(rename = "VoiceUrl", default, skip_serializing_if = "Option::is_none")]
    pub voice_url: Option<String>,
    #[doc = "The SID of the Identity resource that we should associate with the new phone number. \
             Some regions require an Identity to meet local regulations."]
    #[serde(
        rename = "IdentitySid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub identity_sid: Option<String>,
    #[doc = "The SID of the Address resource we should associate with the new phone number. Some \
             regions require addresses to meet local regulations."]
    #[serde(
        rename = "AddressSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub address_sid: Option<String>,
    #[serde(
        rename = "EmergencyStatus",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub emergency_status: Option<IncomingPhoneNumberTollFreeEnumEmergencyStatus>,
    #[doc = "The SID of the emergency address configuration to use for emergency calling from the \
             new phone number."]
    #[serde(
        rename = "EmergencyAddressSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub emergency_address_sid: Option<String>,
    #[doc = "The SID of the Trunk we should use to handle calls to the new phone number. If a \
             `trunk_sid` is present, we ignore all of the voice urls and voice applications and \
             use only those set on the Trunk. Setting a `trunk_sid` will automatically delete \
             your `voice_application_sid` and vice versa."]
    #[serde(rename = "TrunkSid", default, skip_serializing_if = "Option::is_none")]
    pub trunk_sid: Option<String>,
    #[serde(
        rename = "VoiceReceiveMode",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_receive_mode: Option<IncomingPhoneNumberTollFreeEnumVoiceReceiveMode>,
    #[doc = "The SID of the Bundle resource that you associate with the phone number. Some \
             regions require a Bundle to meet local Regulations."]
    #[serde(rename = "BundleSid", default, skip_serializing_if = "Option::is_none")]
    pub bundle_sid: Option<String>,
}

impl std::fmt::Display for CreateIncomingPhoneNumberTollFreeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateIncomingPhoneNumberTollFreeRequest {
    const LENGTH: usize = 23;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.phone_number),
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(sms_application_sid) = &self.sms_application_sid {
                format!("{sms_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_method) = &self.sms_fallback_method {
                format!("{sms_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_url) = &self.sms_fallback_url {
                format!("{sms_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(sms_method) = &self.sms_method {
                format!("{sms_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_url) = &self.sms_url {
                format!("{sms_url:?}")
            } else {
                String::new()
            },
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_application_sid) = &self.voice_application_sid {
                format!("{voice_application_sid:?}")
            } else {
                String::new()
            },
            if let Some(voice_caller_id_lookup) = &self.voice_caller_id_lookup {
                format!("{voice_caller_id_lookup:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_method) = &self.voice_fallback_method {
                format!("{voice_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_url) = &self.voice_fallback_url {
                format!("{voice_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_method) = &self.voice_method {
                format!("{voice_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_url) = &self.voice_url {
                format!("{voice_url:?}")
            } else {
                String::new()
            },
            if let Some(identity_sid) = &self.identity_sid {
                format!("{identity_sid:?}")
            } else {
                String::new()
            },
            if let Some(address_sid) = &self.address_sid {
                format!("{address_sid:?}")
            } else {
                String::new()
            },
            if let Some(emergency_status) = &self.emergency_status {
                format!("{emergency_status:?}")
            } else {
                String::new()
            },
            if let Some(emergency_address_sid) = &self.emergency_address_sid {
                format!("{emergency_address_sid:?}")
            } else {
                String::new()
            },
            if let Some(trunk_sid) = &self.trunk_sid {
                format!("{trunk_sid:?}")
            } else {
                String::new()
            },
            if let Some(voice_receive_mode) = &self.voice_receive_mode {
                format!("{voice_receive_mode:?}")
            } else {
                String::new()
            },
            if let Some(bundle_sid) = &self.bundle_sid {
                format!("{bundle_sid:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "phone_number".to_string(),
            "api_version".to_string(),
            "friendly_name".to_string(),
            "sms_application_sid".to_string(),
            "sms_fallback_method".to_string(),
            "sms_fallback_url".to_string(),
            "sms_method".to_string(),
            "sms_url".to_string(),
            "status_callback".to_string(),
            "status_callback_method".to_string(),
            "voice_application_sid".to_string(),
            "voice_caller_id_lookup".to_string(),
            "voice_fallback_method".to_string(),
            "voice_fallback_url".to_string(),
            "voice_method".to_string(),
            "voice_url".to_string(),
            "identity_sid".to_string(),
            "address_sid".to_string(),
            "emergency_status".to_string(),
            "emergency_address_sid".to_string(),
            "trunk_sid".to_string(),
            "voice_receive_mode".to_string(),
            "bundle_sid".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateKeyRequest {
    #[doc = "A descriptive string that you create to describe the resource. It can be up to 64 \
             characters long."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
}

impl std::fmt::Display for UpdateKeyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateKeyRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![if let Some(friendly_name) = &self.friendly_name {
            format!("{friendly_name:?}")
        } else {
            String::new()
        }]
    }

    fn headers() -> Vec<String> {
        vec!["friendly_name".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListKeyResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keys: Option<Vec<ApiV2010AccountKey>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListKeyResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListKeyResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(keys) = &self.keys {
                format!("{keys:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "keys".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateNewKeyRequest {
    #[doc = "A descriptive string that you create to describe the resource. It can be up to 64 \
             characters long."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
}

impl std::fmt::Display for CreateNewKeyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateNewKeyRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![if let Some(friendly_name) = &self.friendly_name {
            format!("{friendly_name:?}")
        } else {
            String::new()
        }]
    }

    fn headers() -> Vec<String> {
        vec!["friendly_name".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListMediaResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub media_list: Option<Vec<ApiV2010AccountMessageMedia>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListMediaResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListMediaResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(media_list) = &self.media_list {
                format!("{media_list:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "media_list".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[doc = "How to pass the update request data. Can be `GET` or `POST` and the default is `POST`. \
         `POST` sends the data as encoded form data and `GET` sends the data as query parameters."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateMemberRequestMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateMemberRequest {
    #[doc = "The absolute URL of the Queue resource."]
    #[serde(rename = "Url")]
    pub url: String,
    #[doc = "How to pass the update request data. Can be `GET` or `POST` and the default is \
             `POST`. `POST` sends the data as encoded form data and `GET` sends the data as query \
             parameters."]
    #[serde(rename = "Method", default, skip_serializing_if = "Option::is_none")]
    pub method: Option<UpdateMemberRequestMethod>,
}

impl std::fmt::Display for UpdateMemberRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateMemberRequest {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            self.url.clone(),
            if let Some(method) = &self.method {
                format!("{method:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec!["url".to_string(), "method".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListMemberResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub queue_members: Option<Vec<ApiV2010AccountQueueMember>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListMemberResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListMemberResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(queue_members) = &self.queue_members {
                format!("{queue_members:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "queue_members".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListMessageResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub messages: Option<Vec<ApiV2010AccountMessage>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListMessageResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListMessageResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(messages) = &self.messages {
                format!("{messages:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "messages".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateMessageRequest {
    #[doc = "The destination phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format for SMS/MMS or [Channel user address](https://www.twilio.com/docs/sms/channels#channel-addresses) for other 3rd-party channels."]
    #[serde(rename = "To", default, skip_serializing_if = "Option::is_none")]
    pub to: phone_number::PhoneNumber,
    #[doc = "The URL we should call using the `status_callback_method` to send status information to your application. If specified, we POST these message status changes to the URL: `queued`, `failed`, `sent`, `delivered`, or `undelivered`. Twilio will POST its [standard request parameters](https://www.twilio.com/docs/sms/twiml#request-parameters) as well as some additional parameters including `MessageSid`, `MessageStatus`, and `ErrorCode`. If you include this parameter with the `messaging_service_sid`, we use this URL instead of the Status Callback URL of the [Messaging Service](https://www.twilio.com/docs/sms/services/api). URLs must contain a valid hostname and underscores are not allowed."]
    #[serde(
        rename = "StatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback: Option<String>,
    #[doc = "The SID of the application that should receive message status. We POST a `message_sid` parameter and a `message_status` parameter with a value of `sent` or `failed` to the [application](https://www.twilio.com/docs/usage/api/applications)'s `message_status_callback`. If a `status_callback` parameter is also passed, it will be ignored and the application's `message_status_callback` parameter will be used."]
    #[serde(
        rename = "ApplicationSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub application_sid: Option<String>,
    #[doc = "The maximum total price in US dollars that you will pay for the message to be \
             delivered. Can be a decimal value that has up to 4 decimal places. All messages are \
             queued for delivery and the message cost is checked before the message is sent. If \
             the cost exceeds `max_price`, the message will fail and a status of `Failed` is sent \
             to the status callback. If `MaxPrice` is not set, the message cost is not checked."]
    #[serde(rename = "MaxPrice", default, skip_serializing_if = "Option::is_none")]
    pub max_price: Option<f64>,
    #[doc = "Whether to confirm delivery of the message. Set this value to `true` if you are sending messages that have a trackable user action and you intend to confirm delivery of the message using the [Message Feedback API](https://www.twilio.com/docs/sms/api/message-feedback-resource). This parameter is `false` by default."]
    #[serde(
        rename = "ProvideFeedback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub provide_feedback: Option<bool>,
    #[doc = "Total number of attempts made ( including this ) to send out the message regardless \
             of the provider used"]
    #[serde(rename = "Attempt", default, skip_serializing_if = "Option::is_none")]
    pub attempt: Option<i64>,
    #[doc = "How long in seconds the message can remain in our outgoing message queue. After this \
             period elapses, the message fails and we call your status callback. Can be between 1 \
             and the default value of 14,400 seconds. After a message has been accepted by a \
             carrier, however, we cannot guarantee that the message will not be queued after this \
             period. We recommend that this value be at least 5 seconds."]
    #[serde(
        rename = "ValidityPeriod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub validity_period: Option<i64>,
    #[doc = "Reserved"]
    #[serde(
        rename = "ForceDelivery",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub force_delivery: Option<bool>,
    #[serde(
        rename = "ContentRetention",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub content_retention: Option<MessageEnumContentRetention>,
    #[serde(
        rename = "AddressRetention",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub address_retention: Option<MessageEnumAddressRetention>,
    #[doc = "Whether to detect Unicode characters that have a similar GSM-7 character and replace \
             them. Can be: `true` or `false`."]
    #[serde(
        rename = "SmartEncoded",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub smart_encoded: Option<bool>,
    #[doc = "Rich actions for Channels Messages."]
    #[serde(
        rename = "PersistentAction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub persistent_action: Option<Vec<String>>,
    #[doc = "Determines the usage of Click Tracking. Setting it to `true` will instruct Twilio to \
             replace all links in the Message with a shortened version based on the associated \
             Domain Sid and track clicks on them. If this parameter is not set on an API call, we \
             will use the value set on the Messaging Service. If this parameter is not set and \
             the value is not configured on the Messaging Service used this will default to \
             `false`."]
    #[serde(
        rename = "ShortenUrls",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub shorten_urls: Option<bool>,
    #[serde(
        rename = "ScheduleType",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub schedule_type: Option<MessageEnumScheduleType>,
    #[doc = "The time that Twilio will send the message. Must be in ISO 8601 format."]
    #[serde(
        rename = "SendAt",
        default,
        skip_serializing_if = "Option::is_none",
        deserialize_with = "crate::utils::nullable_date_time_format::deserialize"
    )]
    pub send_at: Option<chrono::DateTime<chrono::Utc>>,
    #[doc = "If set to True, Twilio will deliver the message as a single MMS message, regardless \
             of the presence of media."]
    #[serde(rename = "SendAsMms", default, skip_serializing_if = "Option::is_none")]
    pub send_as_mms: Option<bool>,
    #[doc = "The SID of the Content object returned at Content API content create time (https://www.twilio.com/docs/content-api/create-and-send-your-first-content-api-template#create-a-template). If this parameter is not specified, then the Content API will not be utilized."]
    #[serde(
        rename = "ContentSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub content_sid: Option<String>,
    #[doc = "Key-value pairs of variable names to substitution values, used alongside a \
             content_sid. If not specified, Content API will default to the default variables \
             defined at create time."]
    #[serde(
        rename = "ContentVariables",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub content_variables: Option<String>,
    #[doc = "A Twilio phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, an [alphanumeric sender ID](https://www.twilio.com/docs/sms/send-messages#use-an-alphanumeric-sender-id), or a [Channel Endpoint address](https://www.twilio.com/docs/sms/channels#channel-addresses) that is enabled for the type of message you want to send. Phone numbers or [short codes](https://www.twilio.com/docs/sms/api/short-code) purchased from Twilio also work here. You cannot, for example, spoof messages from a private cell phone number. If you are using `messaging_service_sid`, this parameter must be empty."]
    #[serde(rename = "From", default, skip_serializing_if = "Option::is_none")]
    pub from: phone_number::PhoneNumber,
    #[doc = "The SID of the [Messaging Service](https://www.twilio.com/docs/sms/services#send-a-message-with-copilot) you want to associate with the Message. Set this parameter to use the [Messaging Service Settings and Copilot Features](https://www.twilio.com/console/sms/services) you have configured and leave the `from` parameter empty. When only this parameter is set, Twilio will use your enabled Copilot Features to select the `from` phone number for delivery."]
    #[serde(
        rename = "MessagingServiceSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub messaging_service_sid: Option<String>,
    #[doc = "The text of the message you want to send. Can be up to 1,600 characters in length."]
    #[serde(rename = "Body", default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    #[doc = "The URL of the media to send with the message. The media can be of type `gif`, `png`, and `jpeg` and will be formatted correctly on the recipient's device. The media size limit is 5MB for supported file types (JPEG, PNG, GIF) and 500KB for [other types](https://www.twilio.com/docs/sms/accepted-mime-types) of accepted media. To send more than one image in the message body, provide multiple `media_url` parameters in the POST request. You can include up to 10 `media_url` parameters per message. You can send images in an SMS message in only the US and Canada."]
    #[serde(rename = "MediaUrl", default, skip_serializing_if = "Option::is_none")]
    pub media_url: Option<Vec<String>>,
}

impl std::fmt::Display for CreateMessageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateMessageRequest {
    const LENGTH: usize = 22;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.to),
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(application_sid) = &self.application_sid {
                format!("{application_sid:?}")
            } else {
                String::new()
            },
            if let Some(max_price) = &self.max_price {
                format!("{max_price:?}")
            } else {
                String::new()
            },
            if let Some(provide_feedback) = &self.provide_feedback {
                format!("{provide_feedback:?}")
            } else {
                String::new()
            },
            if let Some(attempt) = &self.attempt {
                format!("{attempt:?}")
            } else {
                String::new()
            },
            if let Some(validity_period) = &self.validity_period {
                format!("{validity_period:?}")
            } else {
                String::new()
            },
            if let Some(force_delivery) = &self.force_delivery {
                format!("{force_delivery:?}")
            } else {
                String::new()
            },
            if let Some(content_retention) = &self.content_retention {
                format!("{content_retention:?}")
            } else {
                String::new()
            },
            if let Some(address_retention) = &self.address_retention {
                format!("{address_retention:?}")
            } else {
                String::new()
            },
            if let Some(smart_encoded) = &self.smart_encoded {
                format!("{smart_encoded:?}")
            } else {
                String::new()
            },
            if let Some(persistent_action) = &self.persistent_action {
                format!("{persistent_action:?}")
            } else {
                String::new()
            },
            if let Some(shorten_urls) = &self.shorten_urls {
                format!("{shorten_urls:?}")
            } else {
                String::new()
            },
            if let Some(schedule_type) = &self.schedule_type {
                format!("{schedule_type:?}")
            } else {
                String::new()
            },
            if let Some(send_at) = &self.send_at {
                format!("{send_at:?}")
            } else {
                String::new()
            },
            if let Some(send_as_mms) = &self.send_as_mms {
                format!("{send_as_mms:?}")
            } else {
                String::new()
            },
            if let Some(content_sid) = &self.content_sid {
                format!("{content_sid:?}")
            } else {
                String::new()
            },
            if let Some(content_variables) = &self.content_variables {
                format!("{content_variables:?}")
            } else {
                String::new()
            },
            format!("{:?}", self.from),
            if let Some(messaging_service_sid) = &self.messaging_service_sid {
                format!("{messaging_service_sid:?}")
            } else {
                String::new()
            },
            if let Some(body) = &self.body {
                format!("{body:?}")
            } else {
                String::new()
            },
            if let Some(media_url) = &self.media_url {
                format!("{media_url:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "to".to_string(),
            "status_callback".to_string(),
            "application_sid".to_string(),
            "max_price".to_string(),
            "provide_feedback".to_string(),
            "attempt".to_string(),
            "validity_period".to_string(),
            "force_delivery".to_string(),
            "content_retention".to_string(),
            "address_retention".to_string(),
            "smart_encoded".to_string(),
            "persistent_action".to_string(),
            "shorten_urls".to_string(),
            "schedule_type".to_string(),
            "send_at".to_string(),
            "send_as_mms".to_string(),
            "content_sid".to_string(),
            "content_variables".to_string(),
            "from".to_string(),
            "messaging_service_sid".to_string(),
            "body".to_string(),
            "media_url".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateMessageRequest {
    #[doc = "The text of the message you want to send. Can be up to 1,600 characters long."]
    #[serde(rename = "Body", default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
    pub status: Option<MessageEnumUpdateStatus>,
}

impl std::fmt::Display for UpdateMessageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateMessageRequest {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(body) = &self.body {
                format!("{body:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec!["body".to_string(), "status".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateMessageFeedbackRequest {
    #[serde(rename = "Outcome", default, skip_serializing_if = "Option::is_none")]
    pub outcome: Option<MessageFeedbackEnumOutcome>,
}

impl std::fmt::Display for CreateMessageFeedbackRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateMessageFeedbackRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![if let Some(outcome) = &self.outcome {
            format!("{outcome:?}")
        } else {
            String::new()
        }]
    }

    fn headers() -> Vec<String> {
        vec!["outcome".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListSigningKeyResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signing_keys: Option<Vec<ApiV2010AccountSigningKey>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListSigningKeyResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListSigningKeyResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(signing_keys) = &self.signing_keys {
                format!("{signing_keys:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "signing_keys".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateNewSigningKeyRequest {
    #[doc = "A descriptive string that you create to describe the resource. It can be up to 64 \
             characters long."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
}

impl std::fmt::Display for CreateNewSigningKeyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateNewSigningKeyRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![if let Some(friendly_name) = &self.friendly_name {
            format!("{friendly_name:?}")
        } else {
            String::new()
        }]
    }

    fn headers() -> Vec<String> {
        vec!["friendly_name".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListNotificationResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notifications: Option<Vec<ApiV2010AccountNotification>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListNotificationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListNotificationResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(notifications) = &self.notifications {
                format!("{notifications:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "notifications".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateOutgoingCallerIdRequest {
    #[doc = "A descriptive string that you create to describe the resource. It can be up to 64 \
             characters long."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
}

impl std::fmt::Display for UpdateOutgoingCallerIdRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateOutgoingCallerIdRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![if let Some(friendly_name) = &self.friendly_name {
            format!("{friendly_name:?}")
        } else {
            String::new()
        }]
    }

    fn headers() -> Vec<String> {
        vec!["friendly_name".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListOutgoingCallerIdResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub outgoing_caller_ids: Option<Vec<ApiV2010AccountOutgoingCallerId>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListOutgoingCallerIdResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListOutgoingCallerIdResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(outgoing_caller_ids) = &self.outgoing_caller_ids {
                format!("{outgoing_caller_ids:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "outgoing_caller_ids".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[doc = "The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST`, and the \
         default is `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateValidationRequestRequestStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateValidationRequestRequest {
    #[doc = "The phone number to verify in \
             [E.164](https://www.twilio.com/docs/glossary/what-e164) format, which consists of a \
             + followed by the country code and subscriber number."]
    #[serde(
        rename = "PhoneNumber",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub phone_number: phone_number::PhoneNumber,
    #[doc = "A descriptive string that you create to describe the new caller ID resource. It can \
             be up to 64 characters long. The default value is a formatted version of the phone \
             number."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
    #[doc = "The number of seconds to delay before initiating the verification call. Can be an \
             integer between `0` and `60`, inclusive. The default is `0`."]
    #[serde(rename = "CallDelay", default, skip_serializing_if = "Option::is_none")]
    pub call_delay: Option<i64>,
    #[doc = "The digits to dial after connecting the verification call."]
    #[serde(rename = "Extension", default, skip_serializing_if = "Option::is_none")]
    pub extension: Option<String>,
    #[doc = "The URL we should call using the `status_callback_method` to send status information \
             about the verification process to your application."]
    #[serde(
        rename = "StatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback: Option<String>,
    #[doc = "The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST`, \
             and the default is `POST`."]
    #[serde(
        rename = "StatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback_method: Option<CreateValidationRequestRequestStatusCallbackMethod>,
}

impl std::fmt::Display for CreateValidationRequestRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateValidationRequestRequest {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            format!("{:?}", self.phone_number),
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(call_delay) = &self.call_delay {
                format!("{call_delay:?}")
            } else {
                String::new()
            },
            if let Some(extension) = &self.extension {
                format!("{extension:?}")
            } else {
                String::new()
            },
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "phone_number".to_string(),
            "friendly_name".to_string(),
            "call_delay".to_string(),
            "extension".to_string(),
            "status_callback".to_string(),
            "status_callback_method".to_string(),
        ]
    }
}

#[doc = "The HTTP method we should use to call `hold_url`. Can be: `GET` or `POST` and the default \
         is `GET`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum HoldMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `announce_url`. Can be: `GET` or `POST` and \
         defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateParticipantRequestAnnounceMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default \
         is `POST`. When using a static audio file, this should be `GET` so that we can cache the \
         file."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum WaitMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateParticipantRequest {
    #[doc = "Whether the participant should be muted. Can be `true` or `false`. `true` will mute \
             the participant, and `false` will un-mute them. Anything value other than `true` or \
             `false` is interpreted as `false`."]
    #[serde(rename = "Muted", default, skip_serializing_if = "Option::is_none")]
    pub muted: Option<bool>,
    #[doc = "Whether the participant should be on hold. Can be: `true` or `false`. `true` puts \
             the participant on hold, and `false` lets them rejoin the conference."]
    #[serde(rename = "Hold", default, skip_serializing_if = "Option::is_none")]
    pub hold: Option<bool>,
    #[doc = "The URL we call using the `hold_method` for music that plays when the participant is \
             on hold. The URL may return an MP3 file, a WAV file, or a TwiML document that \
             contains `<Play>`, `<Say>`, `<Pause>`, or `<Redirect>` verbs."]
    #[serde(rename = "HoldUrl", default, skip_serializing_if = "Option::is_none")]
    pub hold_url: Option<String>,
    #[doc = "The HTTP method we should use to call `hold_url`. Can be: `GET` or `POST` and the \
             default is `GET`."]
    #[serde(
        rename = "HoldMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub hold_method: Option<HoldMethod>,
    #[doc = "The URL we call using the `announce_method` for an announcement to the participant. \
             The URL may return an MP3 file, a WAV file, or a TwiML document that contains \
             `<Play>`, `<Say>`, `<Pause>`, or `<Redirect>` verbs."]
    #[serde(
        rename = "AnnounceUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub announce_url: Option<String>,
    #[doc = "The HTTP method we should use to call `announce_url`. Can be: `GET` or `POST` and \
             defaults to `POST`."]
    #[serde(
        rename = "AnnounceMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub announce_method: Option<UpdateParticipantRequestAnnounceMethod>,
    #[doc = "The URL we call using the `wait_method` for the music to play while participants are waiting for the conference to start. The URL may return an MP3 file, a WAV file, or a TwiML document that contains `<Play>`, `<Say>`, `<Pause>`, or `<Redirect>` verbs. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic)."]
    #[serde(rename = "WaitUrl", default, skip_serializing_if = "Option::is_none")]
    pub wait_url: Option<String>,
    #[doc = "The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the \
             default is `POST`. When using a static audio file, this should be `GET` so that we \
             can cache the file."]
    #[serde(
        rename = "WaitMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub wait_method: Option<WaitMethod>,
    #[doc = "Whether to play a notification beep to the conference when the participant exits. \
             Can be: `true` or `false`."]
    #[serde(
        rename = "BeepOnExit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub beep_on_exit: Option<bool>,
    #[doc = "Whether to end the conference when the participant leaves. Can be: `true` or `false` \
             and defaults to `false`."]
    #[serde(
        rename = "EndConferenceOnExit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub end_conference_on_exit: Option<bool>,
    #[doc = "Whether the participant is coaching another call. Can be: `true` or `false`. If not \
             present, defaults to `false` unless `call_sid_to_coach` is defined. If `true`, \
             `call_sid_to_coach` must be defined."]
    #[serde(rename = "Coaching", default, skip_serializing_if = "Option::is_none")]
    pub coaching: Option<bool>,
    #[doc = "The SID of the participant who is being `coached`. The participant being coached is \
             the only participant who can hear the participant who is `coaching`."]
    #[serde(
        rename = "CallSidToCoach",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub call_sid_to_coach: Option<String>,
}

impl std::fmt::Display for UpdateParticipantRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateParticipantRequest {
    const LENGTH: usize = 12;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(muted) = &self.muted {
                format!("{muted:?}")
            } else {
                String::new()
            },
            if let Some(hold) = &self.hold {
                format!("{hold:?}")
            } else {
                String::new()
            },
            if let Some(hold_url) = &self.hold_url {
                format!("{hold_url:?}")
            } else {
                String::new()
            },
            if let Some(hold_method) = &self.hold_method {
                format!("{hold_method:?}")
            } else {
                String::new()
            },
            if let Some(announce_url) = &self.announce_url {
                format!("{announce_url:?}")
            } else {
                String::new()
            },
            if let Some(announce_method) = &self.announce_method {
                format!("{announce_method:?}")
            } else {
                String::new()
            },
            if let Some(wait_url) = &self.wait_url {
                format!("{wait_url:?}")
            } else {
                String::new()
            },
            if let Some(wait_method) = &self.wait_method {
                format!("{wait_method:?}")
            } else {
                String::new()
            },
            if let Some(beep_on_exit) = &self.beep_on_exit {
                format!("{beep_on_exit:?}")
            } else {
                String::new()
            },
            if let Some(end_conference_on_exit) = &self.end_conference_on_exit {
                format!("{end_conference_on_exit:?}")
            } else {
                String::new()
            },
            if let Some(coaching) = &self.coaching {
                format!("{coaching:?}")
            } else {
                String::new()
            },
            if let Some(call_sid_to_coach) = &self.call_sid_to_coach {
                format!("{call_sid_to_coach:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "muted".to_string(),
            "hold".to_string(),
            "hold_url".to_string(),
            "hold_method".to_string(),
            "announce_url".to_string(),
            "announce_method".to_string(),
            "wait_url".to_string(),
            "wait_method".to_string(),
            "beep_on_exit".to_string(),
            "end_conference_on_exit".to_string(),
            "coaching".to_string(),
            "call_sid_to_coach".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListParticipantResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub participants: Option<Vec<ApiV2010AccountConferenceParticipant>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListParticipantResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListParticipantResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(participants) = &self.participants {
                format!("{participants:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "participants".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[doc = "The HTTP method we should use to call `status_callback`. Can be: `GET` and `POST` and \
         defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateParticipantRequestStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or \
         `POST` and defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum ConferenceStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or \
         `POST` and defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateParticipantRequestRecordingStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `conference_recording_status_callback`. Can be: \
         `GET` or `POST` and defaults to `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum ConferenceRecordingStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use when calling the `amd_status_callback` URL. Can be: `GET` \
         or `POST` and the default is `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum AmdStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateParticipantRequest {
    #[doc = "The phone number, Client identifier, or username portion of SIP address that made this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). Client identifiers are formatted `client:name`. If using a phone number, it must be a Twilio number or a Verified [outgoing caller id](https://www.twilio.com/docs/voice/api/outgoing-caller-ids) for your account. If the `to` parameter is a phone number, `from` must also be a phone number. If `to` is sip address, this value of `from` should be a username portion to be used to populate the P-Asserted-Identity header that is passed to the SIP endpoint."]
    #[serde(rename = "From")]
    pub from: String,
    #[doc = "The phone number, SIP address, or Client identifier that received this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). SIP addresses are formatted as `sip:name@company.com`. Client identifiers are formatted `client:name`. [Custom parameters](https://www.twilio.com/docs/voice/api/conference-participant-resource#custom-parameters) may also be specified."]
    #[serde(rename = "To")]
    pub to: String,
    #[doc = "The URL we should call using the `status_callback_method` to send status information \
             to your application."]
    #[serde(
        rename = "StatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback: Option<String>,
    #[doc = "The HTTP method we should use to call `status_callback`. Can be: `GET` and `POST` \
             and defaults to `POST`."]
    #[serde(
        rename = "StatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback_method: Option<CreateParticipantRequestStatusCallbackMethod>,
    #[doc = "The conference state changes that should generate a call to `status_callback`. Can \
             be: `initiated`, `ringing`, `answered`, and `completed`. Separate multiple values \
             with a space. The default value is `completed`."]
    #[serde(
        rename = "StatusCallbackEvent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback_event: Option<Vec<String>>,
    #[doc = "A label for this participant. If one is supplied, it may subsequently be used to \
             fetch, update or delete the participant."]
    #[serde(rename = "Label", default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    #[doc = "The number of seconds that we should allow the phone to ring before assuming there \
             is no answer. Can be an integer between `5` and `600`, inclusive. The default value \
             is `60`. We always add a 5-second timeout buffer to outgoing calls, so  value of 10 \
             would result in an actual timeout that was closer to 15 seconds."]
    #[serde(rename = "Timeout", default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<i64>,
    #[doc = "Whether to record the participant and their conferences, including the time between \
             conferences. Can be `true` or `false` and the default is `false`."]
    #[serde(rename = "Record", default, skip_serializing_if = "Option::is_none")]
    pub record: Option<bool>,
    #[doc = "Whether the agent is muted in the conference. Can be `true` or `false` and the \
             default is `false`."]
    #[serde(rename = "Muted", default, skip_serializing_if = "Option::is_none")]
    pub muted: Option<bool>,
    #[doc = "Whether to play a notification beep to the conference when the participant joins. \
             Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`."]
    #[serde(rename = "Beep", default, skip_serializing_if = "Option::is_none")]
    pub beep: Option<String>,
    #[doc = "Whether to start the conference when the participant joins, if it has not already \
             started. Can be: `true` or `false` and the default is `true`. If `false` and the \
             conference has not started, the participant is muted and hears background music \
             until another participant starts the conference."]
    #[serde(
        rename = "StartConferenceOnEnter",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub start_conference_on_enter: Option<bool>,
    #[doc = "Whether to end the conference when the participant leaves. Can be: `true` or `false` \
             and defaults to `false`."]
    #[serde(
        rename = "EndConferenceOnExit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub end_conference_on_exit: Option<bool>,
    #[doc = "The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic)."]
    #[serde(rename = "WaitUrl", default, skip_serializing_if = "Option::is_none")]
    pub wait_url: Option<String>,
    #[doc = "The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the \
             default is `POST`. When using a static audio file, this should be `GET` so that we \
             can cache the file."]
    #[serde(
        rename = "WaitMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub wait_method: Option<WaitMethod>,
    #[doc = "Whether to allow an agent to hear the state of the outbound call, including ringing \
             or disconnect messages. Can be: `true` or `false` and defaults to `true`."]
    #[serde(
        rename = "EarlyMedia",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub early_media: Option<bool>,
    #[doc = "The maximum number of participants in the conference. Can be a positive integer from \
             `2` to `250`. The default value is `250`."]
    #[serde(
        rename = "MaxParticipants",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub max_participants: Option<i64>,
    #[doc = "Whether to record the conference the participant is joining. Can be: `true`, \
             `false`, `record-from-start`, and `do-not-record`. The default value is `false`."]
    #[serde(
        rename = "ConferenceRecord",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub conference_record: Option<String>,
    #[doc = "Whether to trim leading and trailing silence from your recorded conference audio \
             files. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`."]
    #[serde(
        rename = "ConferenceTrim",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub conference_trim: Option<String>,
    #[doc = "The URL we should call using the `conference_status_callback_method` when the \
             conference events in `conference_status_callback_event` occur. Only the value set by \
             the first participant to join the conference is used. Subsequent \
             `conference_status_callback` values are ignored."]
    #[serde(
        rename = "ConferenceStatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub conference_status_callback: Option<String>,
    #[doc = "The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or \
             `POST` and defaults to `POST`."]
    #[serde(
        rename = "ConferenceStatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub conference_status_callback_method: Option<ConferenceStatusCallbackMethod>,
    #[doc = "The conference state changes that should generate a call to \
             `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, \
             `hold`, `modify`, `speaker`, and `announcement`. Separate multiple values with a \
             space. Defaults to `start end`."]
    #[serde(
        rename = "ConferenceStatusCallbackEvent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub conference_status_callback_event: Option<Vec<String>>,
    #[doc = "The recording channels for the final recording. Can be: `mono` or `dual` and the \
             default is `mono`."]
    #[serde(
        rename = "RecordingChannels",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub recording_channels: Option<String>,
    #[doc = "The URL that we should call using the `recording_status_callback_method` when the \
             recording status changes."]
    #[serde(
        rename = "RecordingStatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub recording_status_callback: Option<String>,
    #[doc = "The HTTP method we should use when we call `recording_status_callback`. Can be: \
             `GET` or `POST` and defaults to `POST`."]
    #[serde(
        rename = "RecordingStatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub recording_status_callback_method:
        Option<CreateParticipantRequestRecordingStatusCallbackMethod>,
    #[doc = "The SIP username used for authentication."]
    #[serde(
        rename = "SipAuthUsername",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sip_auth_username: Option<String>,
    #[doc = "The SIP password for authentication."]
    #[serde(
        rename = "SipAuthPassword",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sip_auth_password: Option<String>,
    #[doc = "The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`."]
    #[serde(rename = "Region", default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[doc = "The URL we should call using the `conference_recording_status_callback_method` when \
             the conference recording is available."]
    #[serde(
        rename = "ConferenceRecordingStatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub conference_recording_status_callback: Option<String>,
    #[doc = "The HTTP method we should use to call `conference_recording_status_callback`. Can \
             be: `GET` or `POST` and defaults to `POST`."]
    #[serde(
        rename = "ConferenceRecordingStatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub conference_recording_status_callback_method:
        Option<ConferenceRecordingStatusCallbackMethod>,
    #[doc = "The recording state changes that should generate a call to \
             `recording_status_callback`. Can be: `started`, `in-progress`, `paused`, `resumed`, \
             `stopped`, `completed`, `failed`, and `absent`. Separate multiple values with a \
             space, ex: `'in-progress completed failed'`."]
    #[serde(
        rename = "RecordingStatusCallbackEvent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub recording_status_callback_event: Option<Vec<String>>,
    #[doc = "The conference recording state changes that generate a call to \
             `conference_recording_status_callback`. Can be: `in-progress`, `completed`, \
             `failed`, and `absent`. Separate multiple values with a space, ex: `'in-progress \
             completed failed'`"]
    #[serde(
        rename = "ConferenceRecordingStatusCallbackEvent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub conference_recording_status_callback_event: Option<Vec<String>>,
    #[doc = "Whether the participant is coaching another call. Can be: `true` or `false`. If not \
             present, defaults to `false` unless `call_sid_to_coach` is defined. If `true`, \
             `call_sid_to_coach` must be defined."]
    #[serde(rename = "Coaching", default, skip_serializing_if = "Option::is_none")]
    pub coaching: Option<bool>,
    #[doc = "The SID of the participant who is being `coached`. The participant being coached is \
             the only participant who can hear the participant who is `coaching`."]
    #[serde(
        rename = "CallSidToCoach",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub call_sid_to_coach: Option<String>,
    #[doc = "Jitter buffer size for the connecting participant. Twilio will use this setting to \
             apply Jitter Buffer before participant's audio is mixed into the conference. Can be: \
             `off`, `small`, `medium`, and `large`. Default to `large`."]
    #[serde(
        rename = "JitterBufferSize",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub jitter_buffer_size: Option<String>,
    #[doc = "The SID of a BYOC (Bring Your Own Carrier) trunk to route this call with. Note that \
             `byoc` is only meaningful when `to` is a phone number; it will otherwise be ignored. \
             (Beta)"]
    #[serde(rename = "Byoc", default, skip_serializing_if = "Option::is_none")]
    pub byoc: Option<String>,
    #[doc = "The phone number, Client identifier, or username portion of SIP address that made this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). Client identifiers are formatted `client:name`. If using a phone number, it must be a Twilio number or a Verified [outgoing caller id](https://www.twilio.com/docs/voice/api/outgoing-caller-ids) for your account. If the `to` parameter is a phone number, `callerId` must also be a phone number. If `to` is sip address, this value of `callerId` should be a username portion to be used to populate the From header that is passed to the SIP endpoint."]
    #[serde(rename = "CallerId", default, skip_serializing_if = "Option::is_none")]
    pub caller_id: Option<String>,
    #[doc = "The Reason for the outgoing call. Use it to specify the purpose of the call that is \
             presented on the called party's phone. (Branded Calls Beta)"]
    #[serde(
        rename = "CallReason",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub call_reason: Option<String>,
    #[doc = "The audio track to record for the call. Can be: `inbound`, `outbound` or `both`. The \
             default is `both`. `inbound` records the audio that is received by Twilio. \
             `outbound` records the audio that is sent from Twilio. `both` records the audio that \
             is received and sent by Twilio."]
    #[serde(
        rename = "RecordingTrack",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub recording_track: Option<String>,
    #[doc = "The maximum duration of the call in seconds. Constraints depend on account and \
             configuration."]
    #[serde(rename = "TimeLimit", default, skip_serializing_if = "Option::is_none")]
    pub time_limit: Option<i64>,
    #[doc = "Whether to detect if a human, answering machine, or fax has picked up the call. Can be: `Enable` or `DetectMessageEnd`. Use `Enable` if you would like us to return `AnsweredBy` as soon as the called party is identified. Use `DetectMessageEnd`, if you would like to leave a message on an answering machine. If `send_digits` is provided, this parameter is ignored. For more information, see [Answering Machine Detection](https://www.twilio.com/docs/voice/answering-machine-detection)."]
    #[serde(
        rename = "MachineDetection",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub machine_detection: Option<String>,
    #[doc = "The number of seconds that we should attempt to detect an answering machine before \
             timing out and sending a voice request with `AnsweredBy` of `unknown`. The default \
             timeout is 30 seconds."]
    #[serde(
        rename = "MachineDetectionTimeout",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub machine_detection_timeout: Option<i64>,
    #[doc = "The number of milliseconds that is used as the measuring stick for the length of the \
             speech activity, where durations lower than this value will be interpreted as a \
             human and longer than this value as a machine. Possible Values: 1000-6000. Default: \
             2400."]
    #[serde(
        rename = "MachineDetectionSpeechThreshold",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub machine_detection_speech_threshold: Option<i64>,
    #[doc = "The number of milliseconds of silence after speech activity at which point the \
             speech activity is considered complete. Possible Values: 500-5000. Default: 1200."]
    #[serde(
        rename = "MachineDetectionSpeechEndThreshold",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub machine_detection_speech_end_threshold: Option<i64>,
    #[doc = "The number of milliseconds of initial silence after which an `unknown` AnsweredBy \
             result will be returned. Possible Values: 2000-10000. Default: 5000."]
    #[serde(
        rename = "MachineDetectionSilenceTimeout",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub machine_detection_silence_timeout: Option<i64>,
    #[doc = "The URL that we should call using the `amd_status_callback_method` to notify \
             customer application whether the call was answered by human, machine or fax."]
    #[serde(
        rename = "AmdStatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub amd_status_callback: Option<String>,
    #[doc = "The HTTP method we should use when calling the `amd_status_callback` URL. Can be: \
             `GET` or `POST` and the default is `POST`."]
    #[serde(
        rename = "AmdStatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub amd_status_callback_method: Option<AmdStatusCallbackMethod>,
}

impl std::fmt::Display for CreateParticipantRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateParticipantRequest {
    const LENGTH: usize = 46;
    fn fields(&self) -> Vec<String> {
        vec![
            self.from.clone(),
            self.to.clone(),
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_event) = &self.status_callback_event {
                format!("{status_callback_event:?}")
            } else {
                String::new()
            },
            if let Some(label) = &self.label {
                format!("{label:?}")
            } else {
                String::new()
            },
            if let Some(timeout) = &self.timeout {
                format!("{timeout:?}")
            } else {
                String::new()
            },
            if let Some(record) = &self.record {
                format!("{record:?}")
            } else {
                String::new()
            },
            if let Some(muted) = &self.muted {
                format!("{muted:?}")
            } else {
                String::new()
            },
            if let Some(beep) = &self.beep {
                format!("{beep:?}")
            } else {
                String::new()
            },
            if let Some(start_conference_on_enter) = &self.start_conference_on_enter {
                format!("{start_conference_on_enter:?}")
            } else {
                String::new()
            },
            if let Some(end_conference_on_exit) = &self.end_conference_on_exit {
                format!("{end_conference_on_exit:?}")
            } else {
                String::new()
            },
            if let Some(wait_url) = &self.wait_url {
                format!("{wait_url:?}")
            } else {
                String::new()
            },
            if let Some(wait_method) = &self.wait_method {
                format!("{wait_method:?}")
            } else {
                String::new()
            },
            if let Some(early_media) = &self.early_media {
                format!("{early_media:?}")
            } else {
                String::new()
            },
            if let Some(max_participants) = &self.max_participants {
                format!("{max_participants:?}")
            } else {
                String::new()
            },
            if let Some(conference_record) = &self.conference_record {
                format!("{conference_record:?}")
            } else {
                String::new()
            },
            if let Some(conference_trim) = &self.conference_trim {
                format!("{conference_trim:?}")
            } else {
                String::new()
            },
            if let Some(conference_status_callback) = &self.conference_status_callback {
                format!("{conference_status_callback:?}")
            } else {
                String::new()
            },
            if let Some(conference_status_callback_method) = &self.conference_status_callback_method
            {
                format!("{conference_status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(conference_status_callback_event) = &self.conference_status_callback_event {
                format!("{conference_status_callback_event:?}")
            } else {
                String::new()
            },
            if let Some(recording_channels) = &self.recording_channels {
                format!("{recording_channels:?}")
            } else {
                String::new()
            },
            if let Some(recording_status_callback) = &self.recording_status_callback {
                format!("{recording_status_callback:?}")
            } else {
                String::new()
            },
            if let Some(recording_status_callback_method) = &self.recording_status_callback_method {
                format!("{recording_status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(sip_auth_username) = &self.sip_auth_username {
                format!("{sip_auth_username:?}")
            } else {
                String::new()
            },
            if let Some(sip_auth_password) = &self.sip_auth_password {
                format!("{sip_auth_password:?}")
            } else {
                String::new()
            },
            if let Some(region) = &self.region {
                format!("{region:?}")
            } else {
                String::new()
            },
            if let Some(conference_recording_status_callback) =
                &self.conference_recording_status_callback
            {
                format!("{conference_recording_status_callback:?}")
            } else {
                String::new()
            },
            if let Some(conference_recording_status_callback_method) =
                &self.conference_recording_status_callback_method
            {
                format!("{conference_recording_status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(recording_status_callback_event) = &self.recording_status_callback_event {
                format!("{recording_status_callback_event:?}")
            } else {
                String::new()
            },
            if let Some(conference_recording_status_callback_event) =
                &self.conference_recording_status_callback_event
            {
                format!("{conference_recording_status_callback_event:?}")
            } else {
                String::new()
            },
            if let Some(coaching) = &self.coaching {
                format!("{coaching:?}")
            } else {
                String::new()
            },
            if let Some(call_sid_to_coach) = &self.call_sid_to_coach {
                format!("{call_sid_to_coach:?}")
            } else {
                String::new()
            },
            if let Some(jitter_buffer_size) = &self.jitter_buffer_size {
                format!("{jitter_buffer_size:?}")
            } else {
                String::new()
            },
            if let Some(byoc) = &self.byoc {
                format!("{byoc:?}")
            } else {
                String::new()
            },
            if let Some(caller_id) = &self.caller_id {
                format!("{caller_id:?}")
            } else {
                String::new()
            },
            if let Some(call_reason) = &self.call_reason {
                format!("{call_reason:?}")
            } else {
                String::new()
            },
            if let Some(recording_track) = &self.recording_track {
                format!("{recording_track:?}")
            } else {
                String::new()
            },
            if let Some(time_limit) = &self.time_limit {
                format!("{time_limit:?}")
            } else {
                String::new()
            },
            if let Some(machine_detection) = &self.machine_detection {
                format!("{machine_detection:?}")
            } else {
                String::new()
            },
            if let Some(machine_detection_timeout) = &self.machine_detection_timeout {
                format!("{machine_detection_timeout:?}")
            } else {
                String::new()
            },
            if let Some(machine_detection_speech_threshold) =
                &self.machine_detection_speech_threshold
            {
                format!("{machine_detection_speech_threshold:?}")
            } else {
                String::new()
            },
            if let Some(machine_detection_speech_end_threshold) =
                &self.machine_detection_speech_end_threshold
            {
                format!("{machine_detection_speech_end_threshold:?}")
            } else {
                String::new()
            },
            if let Some(machine_detection_silence_timeout) = &self.machine_detection_silence_timeout
            {
                format!("{machine_detection_silence_timeout:?}")
            } else {
                String::new()
            },
            if let Some(amd_status_callback) = &self.amd_status_callback {
                format!("{amd_status_callback:?}")
            } else {
                String::new()
            },
            if let Some(amd_status_callback_method) = &self.amd_status_callback_method {
                format!("{amd_status_callback_method:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "from".to_string(),
            "to".to_string(),
            "status_callback".to_string(),
            "status_callback_method".to_string(),
            "status_callback_event".to_string(),
            "label".to_string(),
            "timeout".to_string(),
            "record".to_string(),
            "muted".to_string(),
            "beep".to_string(),
            "start_conference_on_enter".to_string(),
            "end_conference_on_exit".to_string(),
            "wait_url".to_string(),
            "wait_method".to_string(),
            "early_media".to_string(),
            "max_participants".to_string(),
            "conference_record".to_string(),
            "conference_trim".to_string(),
            "conference_status_callback".to_string(),
            "conference_status_callback_method".to_string(),
            "conference_status_callback_event".to_string(),
            "recording_channels".to_string(),
            "recording_status_callback".to_string(),
            "recording_status_callback_method".to_string(),
            "sip_auth_username".to_string(),
            "sip_auth_password".to_string(),
            "region".to_string(),
            "conference_recording_status_callback".to_string(),
            "conference_recording_status_callback_method".to_string(),
            "recording_status_callback_event".to_string(),
            "conference_recording_status_callback_event".to_string(),
            "coaching".to_string(),
            "call_sid_to_coach".to_string(),
            "jitter_buffer_size".to_string(),
            "byoc".to_string(),
            "caller_id".to_string(),
            "call_reason".to_string(),
            "recording_track".to_string(),
            "time_limit".to_string(),
            "machine_detection".to_string(),
            "machine_detection_timeout".to_string(),
            "machine_detection_speech_threshold".to_string(),
            "machine_detection_speech_end_threshold".to_string(),
            "machine_detection_silence_timeout".to_string(),
            "amd_status_callback".to_string(),
            "amd_status_callback_method".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreatePaymentsRequest {
    #[doc = "A unique token that will be used to ensure that multiple API calls with the same \
             information do not result in multiple transactions. This should be a unique string \
             value per API call and can be a randomly generated."]
    #[serde(rename = "IdempotencyKey")]
    pub idempotency_key: String,
    #[doc = "Provide an absolute or relative URL to receive status updates regarding your Pay session. Read more about the [expected StatusCallback values](https://www.twilio.com/docs/voice/api/payment-resource#statuscallback)"]
    #[serde(rename = "StatusCallback")]
    pub status_callback: String,
    #[serde(
        rename = "BankAccountType",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub bank_account_type: Option<PaymentsEnumBankAccountType>,
    #[doc = "A positive decimal value less than 1,000,000 to charge against the credit card or \
             bank account. Default currency can be overwritten with `currency` field. Leave blank \
             or set to 0 to tokenize."]
    #[serde(
        rename = "ChargeAmount",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub charge_amount: Option<f64>,
    #[doc = "The currency of the `charge_amount`, formatted as [ISO 4127](http://www.iso.org/iso/home/standards/currency_codes.htm) format. The default value is `USD` and all values allowed from the Pay Connector are accepted."]
    #[serde(rename = "Currency", default, skip_serializing_if = "Option::is_none")]
    pub currency: Option<String>,
    #[doc = "The description can be used to provide more details regarding the transaction. This \
             information is submitted along with the payment details to the Payment Connector \
             which are then posted on the transactions."]
    #[serde(
        rename = "Description",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub description: Option<String>,
    #[doc = "A list of inputs that should be accepted. Currently only `dtmf` is supported. All \
             digits captured during a pay session are redacted from the logs."]
    #[serde(rename = "Input", default, skip_serializing_if = "Option::is_none")]
    pub input: Option<String>,
    #[doc = "A positive integer that is used to validate the length of the `PostalCode` inputted \
             by the user. User must enter this many digits."]
    #[serde(
        rename = "MinPostalCodeLength",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub min_postal_code_length: Option<i64>,
    #[doc = "A single-level JSON object used to pass custom parameters to payment processors. (Required for ACH payments). The information that has to be included here depends on the <Pay> Connector. [Read more](https://www.twilio.com/console/voice/pay-connectors)."]
    #[serde(rename = "Parameter", default, skip_serializing_if = "Option::is_none")]
    pub parameter: Option<serde_json::Value>,
    #[doc = "This is the unique name corresponding to the Pay Connector installed in the Twilio Add-ons. Learn more about [<Pay> Connectors](https://www.twilio.com/console/voice/pay-connectors). The default value is `Default`."]
    #[serde(
        rename = "PaymentConnector",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub payment_connector: Option<String>,
    #[serde(
        rename = "PaymentMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub payment_method: Option<PaymentsEnumPaymentMethod>,
    #[doc = "Indicates whether the credit card postal code (zip code) is a required piece of \
             payment information that must be provided by the caller. The default is `true`."]
    #[serde(
        rename = "PostalCode",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub postal_code: Option<bool>,
    #[doc = "Indicates whether the credit card security code is a required piece of payment \
             information that must be provided by the caller. The default is `true`."]
    #[serde(
        rename = "SecurityCode",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub security_code: Option<bool>,
    #[doc = "The number of seconds that <Pay> should wait for the caller to press a digit between \
             each subsequent digit, after the first one, before moving on to validate the digits \
             captured. The default is `5`, maximum is `600`."]
    #[serde(rename = "Timeout", default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<i64>,
    #[serde(rename = "TokenType", default, skip_serializing_if = "Option::is_none")]
    pub token_type: Option<PaymentsEnumTokenType>,
    #[doc = "Credit card types separated by space that Pay should accept. The default value is \
             `visa mastercard amex`"]
    #[serde(
        rename = "ValidCardTypes",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub valid_card_types: Option<String>,
}

impl std::fmt::Display for CreatePaymentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreatePaymentsRequest {
    const LENGTH: usize = 16;
    fn fields(&self) -> Vec<String> {
        vec![
            self.idempotency_key.clone(),
            self.status_callback.clone(),
            if let Some(bank_account_type) = &self.bank_account_type {
                format!("{bank_account_type:?}")
            } else {
                String::new()
            },
            if let Some(charge_amount) = &self.charge_amount {
                format!("{charge_amount:?}")
            } else {
                String::new()
            },
            if let Some(currency) = &self.currency {
                format!("{currency:?}")
            } else {
                String::new()
            },
            if let Some(description) = &self.description {
                format!("{description:?}")
            } else {
                String::new()
            },
            if let Some(input) = &self.input {
                format!("{input:?}")
            } else {
                String::new()
            },
            if let Some(min_postal_code_length) = &self.min_postal_code_length {
                format!("{min_postal_code_length:?}")
            } else {
                String::new()
            },
            if let Some(parameter) = &self.parameter {
                format!("{parameter:?}")
            } else {
                String::new()
            },
            if let Some(payment_connector) = &self.payment_connector {
                format!("{payment_connector:?}")
            } else {
                String::new()
            },
            if let Some(payment_method) = &self.payment_method {
                format!("{payment_method:?}")
            } else {
                String::new()
            },
            if let Some(postal_code) = &self.postal_code {
                format!("{postal_code:?}")
            } else {
                String::new()
            },
            if let Some(security_code) = &self.security_code {
                format!("{security_code:?}")
            } else {
                String::new()
            },
            if let Some(timeout) = &self.timeout {
                format!("{timeout:?}")
            } else {
                String::new()
            },
            if let Some(token_type) = &self.token_type {
                format!("{token_type:?}")
            } else {
                String::new()
            },
            if let Some(valid_card_types) = &self.valid_card_types {
                format!("{valid_card_types:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "idempotency_key".to_string(),
            "status_callback".to_string(),
            "bank_account_type".to_string(),
            "charge_amount".to_string(),
            "currency".to_string(),
            "description".to_string(),
            "input".to_string(),
            "min_postal_code_length".to_string(),
            "parameter".to_string(),
            "payment_connector".to_string(),
            "payment_method".to_string(),
            "postal_code".to_string(),
            "security_code".to_string(),
            "timeout".to_string(),
            "token_type".to_string(),
            "valid_card_types".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdatePaymentsRequest {
    #[doc = "A unique token that will be used to ensure that multiple API calls with the same \
             information do not result in multiple transactions. This should be a unique string \
             value per API call and can be a randomly generated."]
    #[serde(rename = "IdempotencyKey")]
    pub idempotency_key: String,
    #[doc = "Provide an absolute or relative URL to receive status updates regarding your Pay session. Read more about the [Update](https://www.twilio.com/docs/voice/api/payment-resource#statuscallback-update) and [Complete/Cancel](https://www.twilio.com/docs/voice/api/payment-resource#statuscallback-cancelcomplete) POST requests."]
    #[serde(rename = "StatusCallback")]
    pub status_callback: String,
    #[serde(rename = "Capture", default, skip_serializing_if = "Option::is_none")]
    pub capture: Option<PaymentsEnumCapture>,
    #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
    pub status: Option<PaymentsEnumStatus>,
}

impl std::fmt::Display for UpdatePaymentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdatePaymentsRequest {
    const LENGTH: usize = 4;
    fn fields(&self) -> Vec<String> {
        vec![
            self.idempotency_key.clone(),
            self.status_callback.clone(),
            if let Some(capture) = &self.capture {
                format!("{capture:?}")
            } else {
                String::new()
            },
            if let Some(status) = &self.status {
                format!("{status:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "idempotency_key".to_string(),
            "status_callback".to_string(),
            "capture".to_string(),
            "status".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateQueueRequest {
    #[doc = "A descriptive string that you created to describe this resource. It can be up to 64 \
             characters long."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
    #[doc = "The maximum number of calls allowed to be in the queue. The default is 100. The \
             maximum is 5000."]
    #[serde(rename = "MaxSize", default, skip_serializing_if = "Option::is_none")]
    pub max_size: Option<i64>,
}

impl std::fmt::Display for UpdateQueueRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateQueueRequest {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(max_size) = &self.max_size {
                format!("{max_size:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec!["friendly_name".to_string(), "max_size".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListQueueResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub queues: Option<Vec<ApiV2010AccountQueue>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListQueueResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListQueueResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(queues) = &self.queues {
                format!("{queues:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "queues".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateQueueRequest {
    #[doc = "A descriptive string that you created to describe this resource. It can be up to 64 \
             characters long."]
    #[serde(rename = "FriendlyName")]
    pub friendly_name: String,
    #[doc = "The maximum number of calls allowed to be in the queue. The default is 100. The \
             maximum is 5000."]
    #[serde(rename = "MaxSize", default, skip_serializing_if = "Option::is_none")]
    pub max_size: Option<i64>,
}

impl std::fmt::Display for CreateQueueRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateQueueRequest {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            self.friendly_name.clone(),
            if let Some(max_size) = &self.max_size {
                format!("{max_size:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec!["friendly_name".to_string(), "max_size".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListRecordingResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub recordings: Option<Vec<ApiV2010AccountRecording>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListRecordingResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListRecordingResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(recordings) = &self.recordings {
                format!("{recordings:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "recordings".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListRecordingAddOnResultResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add_on_results: Option<Vec<ApiV2010AccountRecordingRecordingAddOnResult>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListRecordingAddOnResultResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListRecordingAddOnResultResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(add_on_results) = &self.add_on_results {
                format!("{add_on_results:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "add_on_results".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListRecordingAddOnResultPayloadResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub payloads:
        Option<Vec<ApiV2010AccountRecordingRecordingAddOnResultRecordingAddOnResultPayload>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListRecordingAddOnResultPayloadResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListRecordingAddOnResultPayloadResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(payloads) = &self.payloads {
                format!("{payloads:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "payloads".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListRecordingTranscriptionResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub transcriptions: Option<Vec<ApiV2010AccountRecordingRecordingTranscription>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListRecordingTranscriptionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListRecordingTranscriptionResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(transcriptions) = &self.transcriptions {
                format!("{transcriptions:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "transcriptions".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[doc = "The HTTP method we should use when calling the `sms_url`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateShortCodeRequestSmsMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method that we should use to call the `sms_fallback_url`. Can be: `GET` or \
         `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateShortCodeRequestSmsFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateShortCodeRequest {
    #[doc = "A descriptive string that you created to describe this resource. It can be up to 64 \
             characters long. By default, the `FriendlyName` is the short code."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
    #[doc = "The API version to use to start a new TwiML session. Can be: `2010-04-01` or \
             `2008-08-01`."]
    #[serde(
        rename = "ApiVersion",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub api_version: Option<String>,
    #[doc = "The URL we should call when receiving an incoming SMS message to this short code."]
    #[serde(rename = "SmsUrl", default, skip_serializing_if = "Option::is_none")]
    pub sms_url: Option<String>,
    #[doc = "The HTTP method we should use when calling the `sms_url`. Can be: `GET` or `POST`."]
    #[serde(rename = "SmsMethod", default, skip_serializing_if = "Option::is_none")]
    pub sms_method: Option<UpdateShortCodeRequestSmsMethod>,
    #[doc = "The URL that we should call if an error occurs while retrieving or executing the \
             TwiML from `sms_url`."]
    #[serde(
        rename = "SmsFallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_fallback_url: Option<String>,
    #[doc = "The HTTP method that we should use to call the `sms_fallback_url`. Can be: `GET` or \
             `POST`."]
    #[serde(
        rename = "SmsFallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sms_fallback_method: Option<UpdateShortCodeRequestSmsFallbackMethod>,
}

impl std::fmt::Display for UpdateShortCodeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateShortCodeRequest {
    const LENGTH: usize = 6;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(api_version) = &self.api_version {
                format!("{api_version:?}")
            } else {
                String::new()
            },
            if let Some(sms_url) = &self.sms_url {
                format!("{sms_url:?}")
            } else {
                String::new()
            },
            if let Some(sms_method) = &self.sms_method {
                format!("{sms_method:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_url) = &self.sms_fallback_url {
                format!("{sms_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(sms_fallback_method) = &self.sms_fallback_method {
                format!("{sms_fallback_method:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "friendly_name".to_string(),
            "api_version".to_string(),
            "sms_url".to_string(),
            "sms_method".to_string(),
            "sms_fallback_url".to_string(),
            "sms_fallback_method".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListShortCodeResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub short_codes: Option<Vec<ApiV2010AccountShortCode>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListShortCodeResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListShortCodeResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(short_codes) = &self.short_codes {
                format!("{short_codes:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "short_codes".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateSigningKeyRequest {
    #[doc = ""]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
}

impl std::fmt::Display for UpdateSigningKeyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateSigningKeyRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![if let Some(friendly_name) = &self.friendly_name {
            format!("{friendly_name:?}")
        } else {
            String::new()
        }]
    }

    fn headers() -> Vec<String> {
        vec!["friendly_name".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListSipAuthCallsCredentialListMappingResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contents: Option<
        Vec<ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping>,
    >,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListSipAuthCallsCredentialListMappingResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListSipAuthCallsCredentialListMappingResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(contents) = &self.contents {
                format!("{contents:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "contents".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateSipAuthCallsCredentialListMappingRequest {
    #[doc = "The SID of the CredentialList resource to map to the SIP domain."]
    #[serde(rename = "CredentialListSid")]
    pub credential_list_sid: String,
}

impl std::fmt::Display for CreateSipAuthCallsCredentialListMappingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateSipAuthCallsCredentialListMappingRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![self.credential_list_sid.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["credential_list_sid".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListSipAuthCallsIpAccessControlListMappingResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contents: Option<
        Vec<ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping>,
    >,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListSipAuthCallsIpAccessControlListMappingResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListSipAuthCallsIpAccessControlListMappingResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(contents) = &self.contents {
                format!("{contents:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "contents".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateSipAuthCallsIpAccessControlListMappingRequest {
    #[doc = "The SID of the IpAccessControlList resource to map to the SIP domain."]
    #[serde(rename = "IpAccessControlListSid")]
    pub ip_access_control_list_sid: String,
}

impl std::fmt::Display for CreateSipAuthCallsIpAccessControlListMappingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateSipAuthCallsIpAccessControlListMappingRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![self.ip_access_control_list_sid.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["ip_access_control_list_sid".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListSipAuthRegistrationsCredentialListMappingResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub contents : Option < Vec < ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping > > , # [serde (default , skip_serializing_if = "Option::is_none")] pub end : Option < i64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub first_page_uri : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub next_page_uri : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub page : Option < i64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub page_size : Option < i64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub previous_page_uri : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub start : Option < i64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub uri : Option < String > , }

impl std::fmt::Display for ListSipAuthRegistrationsCredentialListMappingResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListSipAuthRegistrationsCredentialListMappingResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(contents) = &self.contents {
                format!("{contents:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "contents".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateSipAuthRegistrationsCredentialListMappingRequest {
    #[doc = "The SID of the CredentialList resource to map to the SIP domain."]
    #[serde(rename = "CredentialListSid")]
    pub credential_list_sid: String,
}

impl std::fmt::Display for CreateSipAuthRegistrationsCredentialListMappingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateSipAuthRegistrationsCredentialListMappingRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![self.credential_list_sid.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["credential_list_sid".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListSipCredentialResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<Vec<ApiV2010AccountSipSipCredentialListSipCredential>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListSipCredentialResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListSipCredentialResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(credentials) = &self.credentials {
                format!("{credentials:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "credentials".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateSipCredentialRequest {
    #[doc = "The username that will be passed when authenticating SIP requests. The username \
             should be sent in response to Twilio's challenge of the initial INVITE. It can be up \
             to 32 characters long."]
    #[serde(rename = "Username")]
    pub username: String,
    #[doc = "The password that the username will use when authenticating SIP requests. The \
             password must be a minimum of 12 characters, contain at least 1 digit, and have \
             mixed case. (eg `IWasAtSignal2018`)"]
    #[serde(rename = "Password")]
    pub password: String,
}

impl std::fmt::Display for CreateSipCredentialRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateSipCredentialRequest {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![self.username.clone(), self.password.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["username".to_string(), "password".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateSipCredentialRequest {
    #[doc = "The password that the username will use when authenticating SIP requests. The \
             password must be a minimum of 12 characters, contain at least 1 digit, and have \
             mixed case. (eg `IWasAtSignal2018`)"]
    #[serde(rename = "Password", default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
}

impl std::fmt::Display for UpdateSipCredentialRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateSipCredentialRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![if let Some(password) = &self.password {
            format!("{password:?}")
        } else {
            String::new()
        }]
    }

    fn headers() -> Vec<String> {
        vec!["password".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListSipCredentialListResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credential_lists: Option<Vec<ApiV2010AccountSipSipCredentialList>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListSipCredentialListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListSipCredentialListResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(credential_lists) = &self.credential_lists {
                format!("{credential_lists:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "credential_lists".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateSipCredentialListRequest {
    #[doc = "A human readable descriptive text that describes the CredentialList, up to 64 \
             characters long."]
    #[serde(rename = "FriendlyName")]
    pub friendly_name: String,
}

impl std::fmt::Display for CreateSipCredentialListRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateSipCredentialListRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![self.friendly_name.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["friendly_name".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateSipCredentialListRequest {
    #[doc = "A human readable descriptive text for a CredentialList, up to 64 characters long."]
    #[serde(rename = "FriendlyName")]
    pub friendly_name: String,
}

impl std::fmt::Display for UpdateSipCredentialListRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateSipCredentialListRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![self.friendly_name.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["friendly_name".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListSipCredentialListMappingResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credential_list_mappings: Option<Vec<ApiV2010AccountSipSipDomainSipCredentialListMapping>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListSipCredentialListMappingResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListSipCredentialListMappingResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(credential_list_mappings) = &self.credential_list_mappings {
                format!("{credential_list_mappings:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "credential_list_mappings".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateSipCredentialListMappingRequest {
    #[doc = "A 34 character string that uniquely identifies the CredentialList resource to map to \
             the SIP domain."]
    #[serde(rename = "CredentialListSid")]
    pub credential_list_sid: String,
}

impl std::fmt::Display for CreateSipCredentialListMappingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateSipCredentialListMappingRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![self.credential_list_sid.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["credential_list_sid".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListSipDomainResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domains: Option<Vec<ApiV2010AccountSipSipDomain>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListSipDomainResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListSipDomainResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(domains) = &self.domains {
                format!("{domains:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "domains".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[doc = "The HTTP method we should use to call `voice_url`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateSipDomainRequestVoiceMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateSipDomainRequestVoiceFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `voice_status_callback_url`. Can be: `GET` or \
         `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateSipDomainRequestVoiceStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateSipDomainRequest {
    #[doc = "The unique address you reserve on Twilio to which you route your SIP traffic. Domain \
             names can contain letters, digits, and \"-\" and must end with `sip.twilio.com`."]
    #[serde(rename = "DomainName")]
    pub domain_name: String,
    #[doc = "A descriptive string that you created to describe the resource. It can be up to 64 \
             characters long."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
    #[doc = "The URL we should when the domain receives a call."]
    #[serde(rename = "VoiceUrl", default, skip_serializing_if = "Option::is_none")]
    pub voice_url: Option<String>,
    #[doc = "The HTTP method we should use to call `voice_url`. Can be: `GET` or `POST`."]
    #[serde(
        rename = "VoiceMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_method: Option<CreateSipDomainRequestVoiceMethod>,
    #[doc = "The URL that we should call when an error occurs while retrieving or executing the \
             TwiML from `voice_url`."]
    #[serde(
        rename = "VoiceFallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_fallback_url: Option<String>,
    #[doc = "The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(
        rename = "VoiceFallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_fallback_method: Option<CreateSipDomainRequestVoiceFallbackMethod>,
    #[doc = "The URL that we should call to pass status parameters (such as call ended) to your \
             application."]
    #[serde(
        rename = "VoiceStatusCallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_status_callback_url: Option<String>,
    #[doc = "The HTTP method we should use to call `voice_status_callback_url`. Can be: `GET` or \
             `POST`."]
    #[serde(
        rename = "VoiceStatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_status_callback_method: Option<CreateSipDomainRequestVoiceStatusCallbackMethod>,
    #[doc = "Whether to allow SIP Endpoints to register with the domain to receive calls. Can be \
             `true` or `false`. `true` allows SIP Endpoints to register with the domain to \
             receive calls, `false` does not."]
    #[serde(
        rename = "SipRegistration",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sip_registration: Option<bool>,
    #[doc = "Whether emergency calling is enabled for the domain. If enabled, allows emergency \
             calls on the domain from phone numbers with validated addresses."]
    #[serde(
        rename = "EmergencyCallingEnabled",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub emergency_calling_enabled: Option<bool>,
    #[doc = "Whether secure SIP is enabled for the domain. If enabled, TLS will be enforced and \
             SRTP will be negotiated on all incoming calls to this sip domain."]
    #[serde(rename = "Secure", default, skip_serializing_if = "Option::is_none")]
    pub secure: Option<bool>,
    #[doc = "The SID of the BYOC Trunk(Bring Your Own Carrier) resource that the Sip Domain will \
             be associated with."]
    #[serde(
        rename = "ByocTrunkSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub byoc_trunk_sid: Option<String>,
    #[doc = "Whether an emergency caller sid is configured for the domain. If present, this phone \
             number will be used as the callback for the emergency call."]
    #[serde(
        rename = "EmergencyCallerSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub emergency_caller_sid: Option<String>,
}

impl std::fmt::Display for CreateSipDomainRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateSipDomainRequest {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            self.domain_name.clone(),
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(voice_url) = &self.voice_url {
                format!("{voice_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_method) = &self.voice_method {
                format!("{voice_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_url) = &self.voice_fallback_url {
                format!("{voice_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_method) = &self.voice_fallback_method {
                format!("{voice_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_status_callback_url) = &self.voice_status_callback_url {
                format!("{voice_status_callback_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_status_callback_method) = &self.voice_status_callback_method {
                format!("{voice_status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(sip_registration) = &self.sip_registration {
                format!("{sip_registration:?}")
            } else {
                String::new()
            },
            if let Some(emergency_calling_enabled) = &self.emergency_calling_enabled {
                format!("{emergency_calling_enabled:?}")
            } else {
                String::new()
            },
            if let Some(secure) = &self.secure {
                format!("{secure:?}")
            } else {
                String::new()
            },
            if let Some(byoc_trunk_sid) = &self.byoc_trunk_sid {
                format!("{byoc_trunk_sid:?}")
            } else {
                String::new()
            },
            if let Some(emergency_caller_sid) = &self.emergency_caller_sid {
                format!("{emergency_caller_sid:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "domain_name".to_string(),
            "friendly_name".to_string(),
            "voice_url".to_string(),
            "voice_method".to_string(),
            "voice_fallback_url".to_string(),
            "voice_fallback_method".to_string(),
            "voice_status_callback_url".to_string(),
            "voice_status_callback_method".to_string(),
            "sip_registration".to_string(),
            "emergency_calling_enabled".to_string(),
            "secure".to_string(),
            "byoc_trunk_sid".to_string(),
            "emergency_caller_sid".to_string(),
        ]
    }
}

#[doc = "The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateSipDomainRequestVoiceFallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `voice_url`"]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateSipDomainRequestVoiceMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[doc = "The HTTP method we should use to call `voice_status_callback_url`. Can be: `GET` or \
         `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateSipDomainRequestVoiceStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateSipDomainRequest {
    #[doc = "A descriptive string that you created to describe the resource. It can be up to 64 \
             characters long."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
    #[doc = "The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`."]
    #[serde(
        rename = "VoiceFallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_fallback_method: Option<UpdateSipDomainRequestVoiceFallbackMethod>,
    #[doc = "The URL that we should call when an error occurs while retrieving or executing the \
             TwiML requested by `voice_url`."]
    #[serde(
        rename = "VoiceFallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_fallback_url: Option<String>,
    #[doc = "The HTTP method we should use to call `voice_url`"]
    #[serde(
        rename = "VoiceMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_method: Option<UpdateSipDomainRequestVoiceMethod>,
    #[doc = "The HTTP method we should use to call `voice_status_callback_url`. Can be: `GET` or \
             `POST`."]
    #[serde(
        rename = "VoiceStatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_status_callback_method: Option<UpdateSipDomainRequestVoiceStatusCallbackMethod>,
    #[doc = "The URL that we should call to pass status parameters (such as call ended) to your \
             application."]
    #[serde(
        rename = "VoiceStatusCallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub voice_status_callback_url: Option<String>,
    #[doc = "The URL we should call when the domain receives a call."]
    #[serde(rename = "VoiceUrl", default, skip_serializing_if = "Option::is_none")]
    pub voice_url: Option<String>,
    #[doc = "Whether to allow SIP Endpoints to register with the domain to receive calls. Can be \
             `true` or `false`. `true` allows SIP Endpoints to register with the domain to \
             receive calls, `false` does not."]
    #[serde(
        rename = "SipRegistration",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub sip_registration: Option<bool>,
    #[doc = "The unique address you reserve on Twilio to which you route your SIP traffic. Domain \
             names can contain letters, digits, and \"-\" and must end with `sip.twilio.com`."]
    #[serde(
        rename = "DomainName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub domain_name: Option<String>,
    #[doc = "Whether emergency calling is enabled for the domain. If enabled, allows emergency \
             calls on the domain from phone numbers with validated addresses."]
    #[serde(
        rename = "EmergencyCallingEnabled",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub emergency_calling_enabled: Option<bool>,
    #[doc = "Whether secure SIP is enabled for the domain. If enabled, TLS will be enforced and \
             SRTP will be negotiated on all incoming calls to this sip domain."]
    #[serde(rename = "Secure", default, skip_serializing_if = "Option::is_none")]
    pub secure: Option<bool>,
    #[doc = "The SID of the BYOC Trunk(Bring Your Own Carrier) resource that the Sip Domain will \
             be associated with."]
    #[serde(
        rename = "ByocTrunkSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub byoc_trunk_sid: Option<String>,
    #[doc = "Whether an emergency caller sid is configured for the domain. If present, this phone \
             number will be used as the callback for the emergency call."]
    #[serde(
        rename = "EmergencyCallerSid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub emergency_caller_sid: Option<String>,
}

impl std::fmt::Display for UpdateSipDomainRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateSipDomainRequest {
    const LENGTH: usize = 13;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_method) = &self.voice_fallback_method {
                format!("{voice_fallback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_fallback_url) = &self.voice_fallback_url {
                format!("{voice_fallback_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_method) = &self.voice_method {
                format!("{voice_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_status_callback_method) = &self.voice_status_callback_method {
                format!("{voice_status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(voice_status_callback_url) = &self.voice_status_callback_url {
                format!("{voice_status_callback_url:?}")
            } else {
                String::new()
            },
            if let Some(voice_url) = &self.voice_url {
                format!("{voice_url:?}")
            } else {
                String::new()
            },
            if let Some(sip_registration) = &self.sip_registration {
                format!("{sip_registration:?}")
            } else {
                String::new()
            },
            if let Some(domain_name) = &self.domain_name {
                format!("{domain_name:?}")
            } else {
                String::new()
            },
            if let Some(emergency_calling_enabled) = &self.emergency_calling_enabled {
                format!("{emergency_calling_enabled:?}")
            } else {
                String::new()
            },
            if let Some(secure) = &self.secure {
                format!("{secure:?}")
            } else {
                String::new()
            },
            if let Some(byoc_trunk_sid) = &self.byoc_trunk_sid {
                format!("{byoc_trunk_sid:?}")
            } else {
                String::new()
            },
            if let Some(emergency_caller_sid) = &self.emergency_caller_sid {
                format!("{emergency_caller_sid:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "friendly_name".to_string(),
            "voice_fallback_method".to_string(),
            "voice_fallback_url".to_string(),
            "voice_method".to_string(),
            "voice_status_callback_method".to_string(),
            "voice_status_callback_url".to_string(),
            "voice_url".to_string(),
            "sip_registration".to_string(),
            "domain_name".to_string(),
            "emergency_calling_enabled".to_string(),
            "secure".to_string(),
            "byoc_trunk_sid".to_string(),
            "emergency_caller_sid".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListSipIpAccessControlListResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip_access_control_lists: Option<Vec<ApiV2010AccountSipSipIpAccessControlList>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListSipIpAccessControlListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListSipIpAccessControlListResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(ip_access_control_lists) = &self.ip_access_control_lists {
                format!("{ip_access_control_lists:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "ip_access_control_lists".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateSipIpAccessControlListRequest {
    #[doc = "A human readable descriptive text that describes the IpAccessControlList, up to 255 \
             characters long."]
    #[serde(rename = "FriendlyName")]
    pub friendly_name: String,
}

impl std::fmt::Display for CreateSipIpAccessControlListRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateSipIpAccessControlListRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![self.friendly_name.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["friendly_name".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateSipIpAccessControlListRequest {
    #[doc = "A human readable descriptive text, up to 255 characters long."]
    #[serde(rename = "FriendlyName")]
    pub friendly_name: String,
}

impl std::fmt::Display for UpdateSipIpAccessControlListRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateSipIpAccessControlListRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![self.friendly_name.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["friendly_name".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListSipIpAccessControlListMappingResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip_access_control_list_mappings:
        Option<Vec<ApiV2010AccountSipSipDomainSipIpAccessControlListMapping>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListSipIpAccessControlListMappingResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListSipIpAccessControlListMappingResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(ip_access_control_list_mappings) = &self.ip_access_control_list_mappings {
                format!("{ip_access_control_list_mappings:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "ip_access_control_list_mappings".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateSipIpAccessControlListMappingRequest {
    #[doc = "The unique id of the IP access control list to map to the SIP domain."]
    #[serde(rename = "IpAccessControlListSid")]
    pub ip_access_control_list_sid: String,
}

impl std::fmt::Display for CreateSipIpAccessControlListMappingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateSipIpAccessControlListMappingRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![self.ip_access_control_list_sid.clone()]
    }

    fn headers() -> Vec<String> {
        vec!["ip_access_control_list_sid".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListSipIpAddressResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip_addresses: Option<Vec<ApiV2010AccountSipSipIpAccessControlListSipIpAddress>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListSipIpAddressResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListSipIpAddressResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(ip_addresses) = &self.ip_addresses {
                format!("{ip_addresses:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "ip_addresses".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateSipIpAddressRequest {
    #[doc = "A human readable descriptive text for this resource, up to 255 characters long."]
    #[serde(rename = "FriendlyName")]
    pub friendly_name: String,
    #[doc = "An IP address in dotted decimal notation from which you want to accept traffic. Any \
             SIP requests from this IP address will be allowed by Twilio. IPv4 only supported \
             today."]
    #[serde(rename = "IpAddress")]
    pub ip_address: String,
    #[doc = "An integer representing the length of the CIDR prefix to use with this IP address \
             when accepting traffic. By default the entire IP address is used."]
    #[serde(
        rename = "CidrPrefixLength",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cidr_prefix_length: Option<i64>,
}

impl std::fmt::Display for CreateSipIpAddressRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateSipIpAddressRequest {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            self.friendly_name.clone(),
            self.ip_address.clone(),
            if let Some(cidr_prefix_length) = &self.cidr_prefix_length {
                format!("{cidr_prefix_length:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "friendly_name".to_string(),
            "ip_address".to_string(),
            "cidr_prefix_length".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateSipIpAddressRequest {
    #[doc = "An IP address in dotted decimal notation from which you want to accept traffic. Any \
             SIP requests from this IP address will be allowed by Twilio. IPv4 only supported \
             today."]
    #[serde(rename = "IpAddress", default, skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<String>,
    #[doc = "A human readable descriptive text for this resource, up to 255 characters long."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
    #[doc = "An integer representing the length of the CIDR prefix to use with this IP address \
             when accepting traffic. By default the entire IP address is used."]
    #[serde(
        rename = "CidrPrefixLength",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cidr_prefix_length: Option<i64>,
}

impl std::fmt::Display for UpdateSipIpAddressRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateSipIpAddressRequest {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(ip_address) = &self.ip_address {
                format!("{ip_address:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(cidr_prefix_length) = &self.cidr_prefix_length {
                format!("{cidr_prefix_length:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "ip_address".to_string(),
            "friendly_name".to_string(),
            "cidr_prefix_length".to_string(),
        ]
    }
}

#[doc = "The http method for the status_callback (one of GET, POST)."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateSiprecRequestStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateSiprecRequest {
    #[doc = "The user-specified name of this Siprec, if one was given when the Siprec was \
             created. This may be used to stop the Siprec."]
    #[serde(rename = "Name", default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Unique name used when configuring the connector via Marketplace Add-on."]
    #[serde(
        rename = "ConnectorName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub connector_name: Option<String>,
    #[serde(rename = "Track", default, skip_serializing_if = "Option::is_none")]
    pub track: Option<SiprecEnumTrack>,
    #[doc = "Absolute URL of the status callback."]
    #[serde(
        rename = "StatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback: Option<String>,
    #[doc = "The http method for the status_callback (one of GET, POST)."]
    #[serde(
        rename = "StatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback_method: Option<CreateSiprecRequestStatusCallbackMethod>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter1.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_1_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter1.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_1_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter2.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_2_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter2.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_2_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter3.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_3_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter3.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_3_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter4.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_4_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter4.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_4_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter5.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_5_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter5.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_5_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter6.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_6_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter6.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_6_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter7.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_7_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter7.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_7_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter8.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_8_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter8.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_8_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter9.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_9_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter9.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_9_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter10.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_10_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter10.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_10_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter11.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_11_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter11.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_11_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter12.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_12_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter12.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_12_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter13.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_13_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter13.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_13_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter14.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_14_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter14.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_14_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter15.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_15_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter15.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_15_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter16.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_16_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter16.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_16_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter17.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_17_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter17.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_17_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter18.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_18_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter18.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_18_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter19.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_19_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter19.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_19_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter20.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_20_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter20.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_20_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter21.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_21_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter21.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_21_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter22.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_22_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter22.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_22_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter23.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_23_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter23.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_23_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter24.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_24_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter24.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_24_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter25.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_25_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter25.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_25_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter26.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_26_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter26.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_26_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter27.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_27_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter27.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_27_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter28.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_28_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter28.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_28_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter29.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_29_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter29.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_29_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter30.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_30_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter30.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_30_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter31.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_31_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter31.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_31_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter32.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_32_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter32.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_32_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter33.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_33_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter33.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_33_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter34.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_34_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter34.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_34_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter35.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_35_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter35.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_35_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter36.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_36_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter36.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_36_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter37.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_37_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter37.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_37_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter38.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_38_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter38.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_38_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter39.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_39_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter39.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_39_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter40.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_40_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter40.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_40_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter41.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_41_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter41.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_41_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter42.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_42_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter42.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_42_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter43.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_43_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter43.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_43_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter44.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_44_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter44.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_44_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter45.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_45_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter45.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_45_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter46.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_46_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter46.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_46_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter47.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_47_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter47.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_47_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter48.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_48_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter48.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_48_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter49.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_49_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter49.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_49_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter50.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_50_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter50.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_50_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter51.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_51_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter51.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_51_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter52.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_52_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter52.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_52_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter53.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_53_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter53.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_53_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter54.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_54_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter54.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_54_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter55.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_55_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter55.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_55_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter56.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_56_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter56.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_56_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter57.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_57_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter57.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_57_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter58.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_58_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter58.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_58_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter59.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_59_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter59.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_59_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter60.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_60_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter60.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_60_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter61.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_61_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter61.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_61_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter62.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_62_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter62.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_62_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter63.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_63_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter63.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_63_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter64.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_64_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter64.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_64_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter65.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_65_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter65.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_65_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter66.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_66_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter66.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_66_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter67.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_67_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter67.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_67_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter68.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_68_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter68.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_68_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter69.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_69_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter69.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_69_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter70.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_70_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter70.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_70_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter71.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_71_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter71.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_71_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter72.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_72_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter72.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_72_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter73.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_73_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter73.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_73_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter74.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_74_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter74.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_74_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter75.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_75_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter75.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_75_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter76.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_76_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter76.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_76_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter77.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_77_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter77.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_77_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter78.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_78_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter78.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_78_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter79.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_79_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter79.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_79_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter80.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_80_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter80.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_80_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter81.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_81_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter81.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_81_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter82.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_82_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter82.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_82_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter83.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_83_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter83.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_83_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter84.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_84_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter84.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_84_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter85.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_85_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter85.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_85_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter86.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_86_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter86.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_86_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter87.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_87_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter87.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_87_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter88.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_88_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter88.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_88_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter89.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_89_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter89.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_89_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter90.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_90_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter90.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_90_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter91.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_91_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter91.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_91_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter92.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_92_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter92.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_92_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter93.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_93_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter93.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_93_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter94.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_94_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter94.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_94_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter95.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_95_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter95.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_95_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter96.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_96_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter96.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_96_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter97.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_97_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter97.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_97_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter98.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_98_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter98.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_98_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter99.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_99_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter99.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_99_value: Option<String>,
}

impl std::fmt::Display for CreateSiprecRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateSiprecRequest {
    const LENGTH: usize = 203;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(name) = &self.name {
                format!("{name:?}")
            } else {
                String::new()
            },
            if let Some(connector_name) = &self.connector_name {
                format!("{connector_name:?}")
            } else {
                String::new()
            },
            if let Some(track) = &self.track {
                format!("{track:?}")
            } else {
                String::new()
            },
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(parameter_1_name) = &self.parameter_1_name {
                format!("{parameter_1_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_1_value) = &self.parameter_1_value {
                format!("{parameter_1_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_2_name) = &self.parameter_2_name {
                format!("{parameter_2_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_2_value) = &self.parameter_2_value {
                format!("{parameter_2_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_3_name) = &self.parameter_3_name {
                format!("{parameter_3_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_3_value) = &self.parameter_3_value {
                format!("{parameter_3_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_4_name) = &self.parameter_4_name {
                format!("{parameter_4_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_4_value) = &self.parameter_4_value {
                format!("{parameter_4_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_5_name) = &self.parameter_5_name {
                format!("{parameter_5_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_5_value) = &self.parameter_5_value {
                format!("{parameter_5_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_6_name) = &self.parameter_6_name {
                format!("{parameter_6_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_6_value) = &self.parameter_6_value {
                format!("{parameter_6_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_7_name) = &self.parameter_7_name {
                format!("{parameter_7_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_7_value) = &self.parameter_7_value {
                format!("{parameter_7_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_8_name) = &self.parameter_8_name {
                format!("{parameter_8_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_8_value) = &self.parameter_8_value {
                format!("{parameter_8_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_9_name) = &self.parameter_9_name {
                format!("{parameter_9_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_9_value) = &self.parameter_9_value {
                format!("{parameter_9_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_10_name) = &self.parameter_10_name {
                format!("{parameter_10_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_10_value) = &self.parameter_10_value {
                format!("{parameter_10_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_11_name) = &self.parameter_11_name {
                format!("{parameter_11_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_11_value) = &self.parameter_11_value {
                format!("{parameter_11_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_12_name) = &self.parameter_12_name {
                format!("{parameter_12_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_12_value) = &self.parameter_12_value {
                format!("{parameter_12_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_13_name) = &self.parameter_13_name {
                format!("{parameter_13_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_13_value) = &self.parameter_13_value {
                format!("{parameter_13_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_14_name) = &self.parameter_14_name {
                format!("{parameter_14_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_14_value) = &self.parameter_14_value {
                format!("{parameter_14_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_15_name) = &self.parameter_15_name {
                format!("{parameter_15_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_15_value) = &self.parameter_15_value {
                format!("{parameter_15_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_16_name) = &self.parameter_16_name {
                format!("{parameter_16_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_16_value) = &self.parameter_16_value {
                format!("{parameter_16_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_17_name) = &self.parameter_17_name {
                format!("{parameter_17_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_17_value) = &self.parameter_17_value {
                format!("{parameter_17_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_18_name) = &self.parameter_18_name {
                format!("{parameter_18_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_18_value) = &self.parameter_18_value {
                format!("{parameter_18_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_19_name) = &self.parameter_19_name {
                format!("{parameter_19_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_19_value) = &self.parameter_19_value {
                format!("{parameter_19_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_20_name) = &self.parameter_20_name {
                format!("{parameter_20_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_20_value) = &self.parameter_20_value {
                format!("{parameter_20_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_21_name) = &self.parameter_21_name {
                format!("{parameter_21_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_21_value) = &self.parameter_21_value {
                format!("{parameter_21_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_22_name) = &self.parameter_22_name {
                format!("{parameter_22_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_22_value) = &self.parameter_22_value {
                format!("{parameter_22_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_23_name) = &self.parameter_23_name {
                format!("{parameter_23_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_23_value) = &self.parameter_23_value {
                format!("{parameter_23_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_24_name) = &self.parameter_24_name {
                format!("{parameter_24_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_24_value) = &self.parameter_24_value {
                format!("{parameter_24_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_25_name) = &self.parameter_25_name {
                format!("{parameter_25_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_25_value) = &self.parameter_25_value {
                format!("{parameter_25_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_26_name) = &self.parameter_26_name {
                format!("{parameter_26_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_26_value) = &self.parameter_26_value {
                format!("{parameter_26_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_27_name) = &self.parameter_27_name {
                format!("{parameter_27_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_27_value) = &self.parameter_27_value {
                format!("{parameter_27_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_28_name) = &self.parameter_28_name {
                format!("{parameter_28_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_28_value) = &self.parameter_28_value {
                format!("{parameter_28_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_29_name) = &self.parameter_29_name {
                format!("{parameter_29_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_29_value) = &self.parameter_29_value {
                format!("{parameter_29_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_30_name) = &self.parameter_30_name {
                format!("{parameter_30_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_30_value) = &self.parameter_30_value {
                format!("{parameter_30_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_31_name) = &self.parameter_31_name {
                format!("{parameter_31_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_31_value) = &self.parameter_31_value {
                format!("{parameter_31_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_32_name) = &self.parameter_32_name {
                format!("{parameter_32_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_32_value) = &self.parameter_32_value {
                format!("{parameter_32_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_33_name) = &self.parameter_33_name {
                format!("{parameter_33_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_33_value) = &self.parameter_33_value {
                format!("{parameter_33_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_34_name) = &self.parameter_34_name {
                format!("{parameter_34_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_34_value) = &self.parameter_34_value {
                format!("{parameter_34_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_35_name) = &self.parameter_35_name {
                format!("{parameter_35_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_35_value) = &self.parameter_35_value {
                format!("{parameter_35_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_36_name) = &self.parameter_36_name {
                format!("{parameter_36_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_36_value) = &self.parameter_36_value {
                format!("{parameter_36_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_37_name) = &self.parameter_37_name {
                format!("{parameter_37_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_37_value) = &self.parameter_37_value {
                format!("{parameter_37_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_38_name) = &self.parameter_38_name {
                format!("{parameter_38_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_38_value) = &self.parameter_38_value {
                format!("{parameter_38_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_39_name) = &self.parameter_39_name {
                format!("{parameter_39_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_39_value) = &self.parameter_39_value {
                format!("{parameter_39_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_40_name) = &self.parameter_40_name {
                format!("{parameter_40_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_40_value) = &self.parameter_40_value {
                format!("{parameter_40_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_41_name) = &self.parameter_41_name {
                format!("{parameter_41_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_41_value) = &self.parameter_41_value {
                format!("{parameter_41_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_42_name) = &self.parameter_42_name {
                format!("{parameter_42_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_42_value) = &self.parameter_42_value {
                format!("{parameter_42_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_43_name) = &self.parameter_43_name {
                format!("{parameter_43_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_43_value) = &self.parameter_43_value {
                format!("{parameter_43_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_44_name) = &self.parameter_44_name {
                format!("{parameter_44_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_44_value) = &self.parameter_44_value {
                format!("{parameter_44_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_45_name) = &self.parameter_45_name {
                format!("{parameter_45_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_45_value) = &self.parameter_45_value {
                format!("{parameter_45_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_46_name) = &self.parameter_46_name {
                format!("{parameter_46_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_46_value) = &self.parameter_46_value {
                format!("{parameter_46_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_47_name) = &self.parameter_47_name {
                format!("{parameter_47_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_47_value) = &self.parameter_47_value {
                format!("{parameter_47_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_48_name) = &self.parameter_48_name {
                format!("{parameter_48_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_48_value) = &self.parameter_48_value {
                format!("{parameter_48_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_49_name) = &self.parameter_49_name {
                format!("{parameter_49_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_49_value) = &self.parameter_49_value {
                format!("{parameter_49_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_50_name) = &self.parameter_50_name {
                format!("{parameter_50_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_50_value) = &self.parameter_50_value {
                format!("{parameter_50_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_51_name) = &self.parameter_51_name {
                format!("{parameter_51_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_51_value) = &self.parameter_51_value {
                format!("{parameter_51_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_52_name) = &self.parameter_52_name {
                format!("{parameter_52_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_52_value) = &self.parameter_52_value {
                format!("{parameter_52_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_53_name) = &self.parameter_53_name {
                format!("{parameter_53_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_53_value) = &self.parameter_53_value {
                format!("{parameter_53_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_54_name) = &self.parameter_54_name {
                format!("{parameter_54_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_54_value) = &self.parameter_54_value {
                format!("{parameter_54_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_55_name) = &self.parameter_55_name {
                format!("{parameter_55_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_55_value) = &self.parameter_55_value {
                format!("{parameter_55_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_56_name) = &self.parameter_56_name {
                format!("{parameter_56_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_56_value) = &self.parameter_56_value {
                format!("{parameter_56_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_57_name) = &self.parameter_57_name {
                format!("{parameter_57_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_57_value) = &self.parameter_57_value {
                format!("{parameter_57_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_58_name) = &self.parameter_58_name {
                format!("{parameter_58_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_58_value) = &self.parameter_58_value {
                format!("{parameter_58_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_59_name) = &self.parameter_59_name {
                format!("{parameter_59_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_59_value) = &self.parameter_59_value {
                format!("{parameter_59_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_60_name) = &self.parameter_60_name {
                format!("{parameter_60_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_60_value) = &self.parameter_60_value {
                format!("{parameter_60_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_61_name) = &self.parameter_61_name {
                format!("{parameter_61_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_61_value) = &self.parameter_61_value {
                format!("{parameter_61_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_62_name) = &self.parameter_62_name {
                format!("{parameter_62_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_62_value) = &self.parameter_62_value {
                format!("{parameter_62_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_63_name) = &self.parameter_63_name {
                format!("{parameter_63_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_63_value) = &self.parameter_63_value {
                format!("{parameter_63_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_64_name) = &self.parameter_64_name {
                format!("{parameter_64_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_64_value) = &self.parameter_64_value {
                format!("{parameter_64_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_65_name) = &self.parameter_65_name {
                format!("{parameter_65_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_65_value) = &self.parameter_65_value {
                format!("{parameter_65_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_66_name) = &self.parameter_66_name {
                format!("{parameter_66_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_66_value) = &self.parameter_66_value {
                format!("{parameter_66_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_67_name) = &self.parameter_67_name {
                format!("{parameter_67_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_67_value) = &self.parameter_67_value {
                format!("{parameter_67_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_68_name) = &self.parameter_68_name {
                format!("{parameter_68_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_68_value) = &self.parameter_68_value {
                format!("{parameter_68_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_69_name) = &self.parameter_69_name {
                format!("{parameter_69_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_69_value) = &self.parameter_69_value {
                format!("{parameter_69_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_70_name) = &self.parameter_70_name {
                format!("{parameter_70_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_70_value) = &self.parameter_70_value {
                format!("{parameter_70_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_71_name) = &self.parameter_71_name {
                format!("{parameter_71_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_71_value) = &self.parameter_71_value {
                format!("{parameter_71_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_72_name) = &self.parameter_72_name {
                format!("{parameter_72_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_72_value) = &self.parameter_72_value {
                format!("{parameter_72_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_73_name) = &self.parameter_73_name {
                format!("{parameter_73_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_73_value) = &self.parameter_73_value {
                format!("{parameter_73_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_74_name) = &self.parameter_74_name {
                format!("{parameter_74_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_74_value) = &self.parameter_74_value {
                format!("{parameter_74_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_75_name) = &self.parameter_75_name {
                format!("{parameter_75_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_75_value) = &self.parameter_75_value {
                format!("{parameter_75_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_76_name) = &self.parameter_76_name {
                format!("{parameter_76_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_76_value) = &self.parameter_76_value {
                format!("{parameter_76_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_77_name) = &self.parameter_77_name {
                format!("{parameter_77_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_77_value) = &self.parameter_77_value {
                format!("{parameter_77_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_78_name) = &self.parameter_78_name {
                format!("{parameter_78_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_78_value) = &self.parameter_78_value {
                format!("{parameter_78_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_79_name) = &self.parameter_79_name {
                format!("{parameter_79_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_79_value) = &self.parameter_79_value {
                format!("{parameter_79_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_80_name) = &self.parameter_80_name {
                format!("{parameter_80_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_80_value) = &self.parameter_80_value {
                format!("{parameter_80_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_81_name) = &self.parameter_81_name {
                format!("{parameter_81_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_81_value) = &self.parameter_81_value {
                format!("{parameter_81_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_82_name) = &self.parameter_82_name {
                format!("{parameter_82_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_82_value) = &self.parameter_82_value {
                format!("{parameter_82_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_83_name) = &self.parameter_83_name {
                format!("{parameter_83_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_83_value) = &self.parameter_83_value {
                format!("{parameter_83_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_84_name) = &self.parameter_84_name {
                format!("{parameter_84_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_84_value) = &self.parameter_84_value {
                format!("{parameter_84_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_85_name) = &self.parameter_85_name {
                format!("{parameter_85_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_85_value) = &self.parameter_85_value {
                format!("{parameter_85_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_86_name) = &self.parameter_86_name {
                format!("{parameter_86_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_86_value) = &self.parameter_86_value {
                format!("{parameter_86_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_87_name) = &self.parameter_87_name {
                format!("{parameter_87_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_87_value) = &self.parameter_87_value {
                format!("{parameter_87_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_88_name) = &self.parameter_88_name {
                format!("{parameter_88_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_88_value) = &self.parameter_88_value {
                format!("{parameter_88_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_89_name) = &self.parameter_89_name {
                format!("{parameter_89_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_89_value) = &self.parameter_89_value {
                format!("{parameter_89_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_90_name) = &self.parameter_90_name {
                format!("{parameter_90_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_90_value) = &self.parameter_90_value {
                format!("{parameter_90_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_91_name) = &self.parameter_91_name {
                format!("{parameter_91_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_91_value) = &self.parameter_91_value {
                format!("{parameter_91_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_92_name) = &self.parameter_92_name {
                format!("{parameter_92_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_92_value) = &self.parameter_92_value {
                format!("{parameter_92_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_93_name) = &self.parameter_93_name {
                format!("{parameter_93_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_93_value) = &self.parameter_93_value {
                format!("{parameter_93_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_94_name) = &self.parameter_94_name {
                format!("{parameter_94_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_94_value) = &self.parameter_94_value {
                format!("{parameter_94_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_95_name) = &self.parameter_95_name {
                format!("{parameter_95_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_95_value) = &self.parameter_95_value {
                format!("{parameter_95_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_96_name) = &self.parameter_96_name {
                format!("{parameter_96_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_96_value) = &self.parameter_96_value {
                format!("{parameter_96_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_97_name) = &self.parameter_97_name {
                format!("{parameter_97_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_97_value) = &self.parameter_97_value {
                format!("{parameter_97_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_98_name) = &self.parameter_98_name {
                format!("{parameter_98_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_98_value) = &self.parameter_98_value {
                format!("{parameter_98_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_99_name) = &self.parameter_99_name {
                format!("{parameter_99_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_99_value) = &self.parameter_99_value {
                format!("{parameter_99_value:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "name".to_string(),
            "connector_name".to_string(),
            "track".to_string(),
            "status_callback".to_string(),
            "status_callback_method".to_string(),
            "parameter_1_name".to_string(),
            "parameter_1_value".to_string(),
            "parameter_2_name".to_string(),
            "parameter_2_value".to_string(),
            "parameter_3_name".to_string(),
            "parameter_3_value".to_string(),
            "parameter_4_name".to_string(),
            "parameter_4_value".to_string(),
            "parameter_5_name".to_string(),
            "parameter_5_value".to_string(),
            "parameter_6_name".to_string(),
            "parameter_6_value".to_string(),
            "parameter_7_name".to_string(),
            "parameter_7_value".to_string(),
            "parameter_8_name".to_string(),
            "parameter_8_value".to_string(),
            "parameter_9_name".to_string(),
            "parameter_9_value".to_string(),
            "parameter_10_name".to_string(),
            "parameter_10_value".to_string(),
            "parameter_11_name".to_string(),
            "parameter_11_value".to_string(),
            "parameter_12_name".to_string(),
            "parameter_12_value".to_string(),
            "parameter_13_name".to_string(),
            "parameter_13_value".to_string(),
            "parameter_14_name".to_string(),
            "parameter_14_value".to_string(),
            "parameter_15_name".to_string(),
            "parameter_15_value".to_string(),
            "parameter_16_name".to_string(),
            "parameter_16_value".to_string(),
            "parameter_17_name".to_string(),
            "parameter_17_value".to_string(),
            "parameter_18_name".to_string(),
            "parameter_18_value".to_string(),
            "parameter_19_name".to_string(),
            "parameter_19_value".to_string(),
            "parameter_20_name".to_string(),
            "parameter_20_value".to_string(),
            "parameter_21_name".to_string(),
            "parameter_21_value".to_string(),
            "parameter_22_name".to_string(),
            "parameter_22_value".to_string(),
            "parameter_23_name".to_string(),
            "parameter_23_value".to_string(),
            "parameter_24_name".to_string(),
            "parameter_24_value".to_string(),
            "parameter_25_name".to_string(),
            "parameter_25_value".to_string(),
            "parameter_26_name".to_string(),
            "parameter_26_value".to_string(),
            "parameter_27_name".to_string(),
            "parameter_27_value".to_string(),
            "parameter_28_name".to_string(),
            "parameter_28_value".to_string(),
            "parameter_29_name".to_string(),
            "parameter_29_value".to_string(),
            "parameter_30_name".to_string(),
            "parameter_30_value".to_string(),
            "parameter_31_name".to_string(),
            "parameter_31_value".to_string(),
            "parameter_32_name".to_string(),
            "parameter_32_value".to_string(),
            "parameter_33_name".to_string(),
            "parameter_33_value".to_string(),
            "parameter_34_name".to_string(),
            "parameter_34_value".to_string(),
            "parameter_35_name".to_string(),
            "parameter_35_value".to_string(),
            "parameter_36_name".to_string(),
            "parameter_36_value".to_string(),
            "parameter_37_name".to_string(),
            "parameter_37_value".to_string(),
            "parameter_38_name".to_string(),
            "parameter_38_value".to_string(),
            "parameter_39_name".to_string(),
            "parameter_39_value".to_string(),
            "parameter_40_name".to_string(),
            "parameter_40_value".to_string(),
            "parameter_41_name".to_string(),
            "parameter_41_value".to_string(),
            "parameter_42_name".to_string(),
            "parameter_42_value".to_string(),
            "parameter_43_name".to_string(),
            "parameter_43_value".to_string(),
            "parameter_44_name".to_string(),
            "parameter_44_value".to_string(),
            "parameter_45_name".to_string(),
            "parameter_45_value".to_string(),
            "parameter_46_name".to_string(),
            "parameter_46_value".to_string(),
            "parameter_47_name".to_string(),
            "parameter_47_value".to_string(),
            "parameter_48_name".to_string(),
            "parameter_48_value".to_string(),
            "parameter_49_name".to_string(),
            "parameter_49_value".to_string(),
            "parameter_50_name".to_string(),
            "parameter_50_value".to_string(),
            "parameter_51_name".to_string(),
            "parameter_51_value".to_string(),
            "parameter_52_name".to_string(),
            "parameter_52_value".to_string(),
            "parameter_53_name".to_string(),
            "parameter_53_value".to_string(),
            "parameter_54_name".to_string(),
            "parameter_54_value".to_string(),
            "parameter_55_name".to_string(),
            "parameter_55_value".to_string(),
            "parameter_56_name".to_string(),
            "parameter_56_value".to_string(),
            "parameter_57_name".to_string(),
            "parameter_57_value".to_string(),
            "parameter_58_name".to_string(),
            "parameter_58_value".to_string(),
            "parameter_59_name".to_string(),
            "parameter_59_value".to_string(),
            "parameter_60_name".to_string(),
            "parameter_60_value".to_string(),
            "parameter_61_name".to_string(),
            "parameter_61_value".to_string(),
            "parameter_62_name".to_string(),
            "parameter_62_value".to_string(),
            "parameter_63_name".to_string(),
            "parameter_63_value".to_string(),
            "parameter_64_name".to_string(),
            "parameter_64_value".to_string(),
            "parameter_65_name".to_string(),
            "parameter_65_value".to_string(),
            "parameter_66_name".to_string(),
            "parameter_66_value".to_string(),
            "parameter_67_name".to_string(),
            "parameter_67_value".to_string(),
            "parameter_68_name".to_string(),
            "parameter_68_value".to_string(),
            "parameter_69_name".to_string(),
            "parameter_69_value".to_string(),
            "parameter_70_name".to_string(),
            "parameter_70_value".to_string(),
            "parameter_71_name".to_string(),
            "parameter_71_value".to_string(),
            "parameter_72_name".to_string(),
            "parameter_72_value".to_string(),
            "parameter_73_name".to_string(),
            "parameter_73_value".to_string(),
            "parameter_74_name".to_string(),
            "parameter_74_value".to_string(),
            "parameter_75_name".to_string(),
            "parameter_75_value".to_string(),
            "parameter_76_name".to_string(),
            "parameter_76_value".to_string(),
            "parameter_77_name".to_string(),
            "parameter_77_value".to_string(),
            "parameter_78_name".to_string(),
            "parameter_78_value".to_string(),
            "parameter_79_name".to_string(),
            "parameter_79_value".to_string(),
            "parameter_80_name".to_string(),
            "parameter_80_value".to_string(),
            "parameter_81_name".to_string(),
            "parameter_81_value".to_string(),
            "parameter_82_name".to_string(),
            "parameter_82_value".to_string(),
            "parameter_83_name".to_string(),
            "parameter_83_value".to_string(),
            "parameter_84_name".to_string(),
            "parameter_84_value".to_string(),
            "parameter_85_name".to_string(),
            "parameter_85_value".to_string(),
            "parameter_86_name".to_string(),
            "parameter_86_value".to_string(),
            "parameter_87_name".to_string(),
            "parameter_87_value".to_string(),
            "parameter_88_name".to_string(),
            "parameter_88_value".to_string(),
            "parameter_89_name".to_string(),
            "parameter_89_value".to_string(),
            "parameter_90_name".to_string(),
            "parameter_90_value".to_string(),
            "parameter_91_name".to_string(),
            "parameter_91_value".to_string(),
            "parameter_92_name".to_string(),
            "parameter_92_value".to_string(),
            "parameter_93_name".to_string(),
            "parameter_93_value".to_string(),
            "parameter_94_name".to_string(),
            "parameter_94_value".to_string(),
            "parameter_95_name".to_string(),
            "parameter_95_value".to_string(),
            "parameter_96_name".to_string(),
            "parameter_96_value".to_string(),
            "parameter_97_name".to_string(),
            "parameter_97_value".to_string(),
            "parameter_98_name".to_string(),
            "parameter_98_value".to_string(),
            "parameter_99_name".to_string(),
            "parameter_99_value".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateSiprecRequest {
    #[serde(rename = "Status")]
    pub status: SiprecEnumUpdateStatus,
}

impl std::fmt::Display for UpdateSiprecRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateSiprecRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.status)]
    }

    fn headers() -> Vec<String> {
        vec!["status".to_string()]
    }
}

#[doc = "The http method for the status_callback (one of GET, POST)."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateStreamRequestStatusCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateStreamRequest {
    #[doc = "Relative or absolute url where WebSocket connection will be established."]
    #[serde(rename = "Url")]
    pub url: String,
    #[doc = "The user-specified name of this Stream, if one was given when the Stream was \
             created. This may be used to stop the Stream."]
    #[serde(rename = "Name", default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "Track", default, skip_serializing_if = "Option::is_none")]
    pub track: Option<StreamEnumTrack>,
    #[doc = "Absolute URL of the status callback."]
    #[serde(
        rename = "StatusCallback",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback: Option<String>,
    #[doc = "The http method for the status_callback (one of GET, POST)."]
    #[serde(
        rename = "StatusCallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub status_callback_method: Option<CreateStreamRequestStatusCallbackMethod>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter1.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_1_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter1.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_1_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter2.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_2_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter2.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_2_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter3.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_3_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter3.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_3_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter4.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_4_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter4.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_4_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter5.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_5_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter5.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_5_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter6.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_6_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter6.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_6_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter7.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_7_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter7.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_7_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter8.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_8_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter8.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_8_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter9.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_9_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter9.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_9_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter10.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_10_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter10.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_10_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter11.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_11_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter11.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_11_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter12.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_12_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter12.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_12_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter13.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_13_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter13.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_13_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter14.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_14_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter14.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_14_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter15.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_15_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter15.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_15_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter16.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_16_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter16.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_16_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter17.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_17_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter17.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_17_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter18.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_18_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter18.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_18_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter19.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_19_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter19.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_19_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter20.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_20_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter20.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_20_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter21.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_21_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter21.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_21_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter22.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_22_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter22.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_22_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter23.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_23_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter23.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_23_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter24.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_24_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter24.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_24_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter25.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_25_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter25.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_25_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter26.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_26_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter26.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_26_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter27.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_27_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter27.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_27_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter28.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_28_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter28.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_28_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter29.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_29_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter29.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_29_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter30.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_30_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter30.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_30_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter31.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_31_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter31.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_31_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter32.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_32_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter32.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_32_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter33.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_33_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter33.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_33_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter34.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_34_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter34.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_34_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter35.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_35_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter35.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_35_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter36.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_36_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter36.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_36_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter37.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_37_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter37.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_37_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter38.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_38_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter38.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_38_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter39.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_39_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter39.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_39_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter40.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_40_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter40.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_40_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter41.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_41_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter41.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_41_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter42.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_42_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter42.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_42_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter43.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_43_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter43.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_43_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter44.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_44_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter44.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_44_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter45.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_45_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter45.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_45_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter46.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_46_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter46.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_46_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter47.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_47_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter47.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_47_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter48.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_48_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter48.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_48_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter49.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_49_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter49.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_49_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter50.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_50_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter50.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_50_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter51.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_51_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter51.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_51_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter52.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_52_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter52.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_52_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter53.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_53_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter53.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_53_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter54.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_54_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter54.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_54_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter55.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_55_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter55.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_55_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter56.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_56_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter56.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_56_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter57.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_57_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter57.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_57_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter58.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_58_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter58.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_58_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter59.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_59_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter59.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_59_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter60.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_60_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter60.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_60_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter61.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_61_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter61.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_61_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter62.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_62_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter62.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_62_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter63.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_63_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter63.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_63_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter64.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_64_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter64.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_64_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter65.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_65_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter65.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_65_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter66.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_66_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter66.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_66_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter67.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_67_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter67.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_67_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter68.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_68_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter68.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_68_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter69.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_69_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter69.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_69_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter70.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_70_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter70.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_70_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter71.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_71_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter71.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_71_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter72.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_72_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter72.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_72_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter73.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_73_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter73.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_73_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter74.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_74_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter74.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_74_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter75.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_75_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter75.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_75_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter76.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_76_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter76.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_76_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter77.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_77_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter77.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_77_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter78.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_78_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter78.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_78_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter79.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_79_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter79.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_79_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter80.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_80_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter80.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_80_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter81.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_81_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter81.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_81_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter82.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_82_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter82.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_82_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter83.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_83_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter83.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_83_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter84.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_84_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter84.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_84_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter85.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_85_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter85.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_85_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter86.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_86_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter86.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_86_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter87.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_87_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter87.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_87_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter88.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_88_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter88.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_88_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter89.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_89_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter89.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_89_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter90.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_90_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter90.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_90_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter91.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_91_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter91.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_91_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter92.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_92_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter92.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_92_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter93.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_93_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter93.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_93_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter94.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_94_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter94.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_94_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter95.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_95_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter95.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_95_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter96.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_96_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter96.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_96_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter97.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_97_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter97.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_97_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter98.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_98_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter98.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_98_value: Option<String>,
    #[doc = "Parameter name"]
    #[serde(
        rename = "Parameter99.Name",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_99_name: Option<String>,
    #[doc = "Parameter value"]
    #[serde(
        rename = "Parameter99.Value",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub parameter_99_value: Option<String>,
}

impl std::fmt::Display for CreateStreamRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateStreamRequest {
    const LENGTH: usize = 203;
    fn fields(&self) -> Vec<String> {
        vec![
            self.url.clone(),
            if let Some(name) = &self.name {
                format!("{name:?}")
            } else {
                String::new()
            },
            if let Some(track) = &self.track {
                format!("{track:?}")
            } else {
                String::new()
            },
            if let Some(status_callback) = &self.status_callback {
                format!("{status_callback:?}")
            } else {
                String::new()
            },
            if let Some(status_callback_method) = &self.status_callback_method {
                format!("{status_callback_method:?}")
            } else {
                String::new()
            },
            if let Some(parameter_1_name) = &self.parameter_1_name {
                format!("{parameter_1_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_1_value) = &self.parameter_1_value {
                format!("{parameter_1_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_2_name) = &self.parameter_2_name {
                format!("{parameter_2_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_2_value) = &self.parameter_2_value {
                format!("{parameter_2_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_3_name) = &self.parameter_3_name {
                format!("{parameter_3_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_3_value) = &self.parameter_3_value {
                format!("{parameter_3_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_4_name) = &self.parameter_4_name {
                format!("{parameter_4_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_4_value) = &self.parameter_4_value {
                format!("{parameter_4_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_5_name) = &self.parameter_5_name {
                format!("{parameter_5_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_5_value) = &self.parameter_5_value {
                format!("{parameter_5_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_6_name) = &self.parameter_6_name {
                format!("{parameter_6_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_6_value) = &self.parameter_6_value {
                format!("{parameter_6_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_7_name) = &self.parameter_7_name {
                format!("{parameter_7_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_7_value) = &self.parameter_7_value {
                format!("{parameter_7_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_8_name) = &self.parameter_8_name {
                format!("{parameter_8_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_8_value) = &self.parameter_8_value {
                format!("{parameter_8_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_9_name) = &self.parameter_9_name {
                format!("{parameter_9_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_9_value) = &self.parameter_9_value {
                format!("{parameter_9_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_10_name) = &self.parameter_10_name {
                format!("{parameter_10_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_10_value) = &self.parameter_10_value {
                format!("{parameter_10_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_11_name) = &self.parameter_11_name {
                format!("{parameter_11_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_11_value) = &self.parameter_11_value {
                format!("{parameter_11_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_12_name) = &self.parameter_12_name {
                format!("{parameter_12_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_12_value) = &self.parameter_12_value {
                format!("{parameter_12_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_13_name) = &self.parameter_13_name {
                format!("{parameter_13_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_13_value) = &self.parameter_13_value {
                format!("{parameter_13_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_14_name) = &self.parameter_14_name {
                format!("{parameter_14_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_14_value) = &self.parameter_14_value {
                format!("{parameter_14_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_15_name) = &self.parameter_15_name {
                format!("{parameter_15_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_15_value) = &self.parameter_15_value {
                format!("{parameter_15_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_16_name) = &self.parameter_16_name {
                format!("{parameter_16_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_16_value) = &self.parameter_16_value {
                format!("{parameter_16_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_17_name) = &self.parameter_17_name {
                format!("{parameter_17_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_17_value) = &self.parameter_17_value {
                format!("{parameter_17_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_18_name) = &self.parameter_18_name {
                format!("{parameter_18_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_18_value) = &self.parameter_18_value {
                format!("{parameter_18_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_19_name) = &self.parameter_19_name {
                format!("{parameter_19_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_19_value) = &self.parameter_19_value {
                format!("{parameter_19_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_20_name) = &self.parameter_20_name {
                format!("{parameter_20_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_20_value) = &self.parameter_20_value {
                format!("{parameter_20_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_21_name) = &self.parameter_21_name {
                format!("{parameter_21_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_21_value) = &self.parameter_21_value {
                format!("{parameter_21_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_22_name) = &self.parameter_22_name {
                format!("{parameter_22_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_22_value) = &self.parameter_22_value {
                format!("{parameter_22_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_23_name) = &self.parameter_23_name {
                format!("{parameter_23_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_23_value) = &self.parameter_23_value {
                format!("{parameter_23_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_24_name) = &self.parameter_24_name {
                format!("{parameter_24_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_24_value) = &self.parameter_24_value {
                format!("{parameter_24_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_25_name) = &self.parameter_25_name {
                format!("{parameter_25_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_25_value) = &self.parameter_25_value {
                format!("{parameter_25_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_26_name) = &self.parameter_26_name {
                format!("{parameter_26_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_26_value) = &self.parameter_26_value {
                format!("{parameter_26_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_27_name) = &self.parameter_27_name {
                format!("{parameter_27_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_27_value) = &self.parameter_27_value {
                format!("{parameter_27_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_28_name) = &self.parameter_28_name {
                format!("{parameter_28_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_28_value) = &self.parameter_28_value {
                format!("{parameter_28_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_29_name) = &self.parameter_29_name {
                format!("{parameter_29_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_29_value) = &self.parameter_29_value {
                format!("{parameter_29_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_30_name) = &self.parameter_30_name {
                format!("{parameter_30_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_30_value) = &self.parameter_30_value {
                format!("{parameter_30_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_31_name) = &self.parameter_31_name {
                format!("{parameter_31_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_31_value) = &self.parameter_31_value {
                format!("{parameter_31_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_32_name) = &self.parameter_32_name {
                format!("{parameter_32_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_32_value) = &self.parameter_32_value {
                format!("{parameter_32_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_33_name) = &self.parameter_33_name {
                format!("{parameter_33_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_33_value) = &self.parameter_33_value {
                format!("{parameter_33_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_34_name) = &self.parameter_34_name {
                format!("{parameter_34_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_34_value) = &self.parameter_34_value {
                format!("{parameter_34_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_35_name) = &self.parameter_35_name {
                format!("{parameter_35_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_35_value) = &self.parameter_35_value {
                format!("{parameter_35_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_36_name) = &self.parameter_36_name {
                format!("{parameter_36_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_36_value) = &self.parameter_36_value {
                format!("{parameter_36_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_37_name) = &self.parameter_37_name {
                format!("{parameter_37_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_37_value) = &self.parameter_37_value {
                format!("{parameter_37_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_38_name) = &self.parameter_38_name {
                format!("{parameter_38_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_38_value) = &self.parameter_38_value {
                format!("{parameter_38_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_39_name) = &self.parameter_39_name {
                format!("{parameter_39_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_39_value) = &self.parameter_39_value {
                format!("{parameter_39_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_40_name) = &self.parameter_40_name {
                format!("{parameter_40_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_40_value) = &self.parameter_40_value {
                format!("{parameter_40_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_41_name) = &self.parameter_41_name {
                format!("{parameter_41_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_41_value) = &self.parameter_41_value {
                format!("{parameter_41_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_42_name) = &self.parameter_42_name {
                format!("{parameter_42_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_42_value) = &self.parameter_42_value {
                format!("{parameter_42_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_43_name) = &self.parameter_43_name {
                format!("{parameter_43_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_43_value) = &self.parameter_43_value {
                format!("{parameter_43_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_44_name) = &self.parameter_44_name {
                format!("{parameter_44_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_44_value) = &self.parameter_44_value {
                format!("{parameter_44_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_45_name) = &self.parameter_45_name {
                format!("{parameter_45_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_45_value) = &self.parameter_45_value {
                format!("{parameter_45_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_46_name) = &self.parameter_46_name {
                format!("{parameter_46_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_46_value) = &self.parameter_46_value {
                format!("{parameter_46_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_47_name) = &self.parameter_47_name {
                format!("{parameter_47_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_47_value) = &self.parameter_47_value {
                format!("{parameter_47_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_48_name) = &self.parameter_48_name {
                format!("{parameter_48_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_48_value) = &self.parameter_48_value {
                format!("{parameter_48_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_49_name) = &self.parameter_49_name {
                format!("{parameter_49_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_49_value) = &self.parameter_49_value {
                format!("{parameter_49_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_50_name) = &self.parameter_50_name {
                format!("{parameter_50_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_50_value) = &self.parameter_50_value {
                format!("{parameter_50_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_51_name) = &self.parameter_51_name {
                format!("{parameter_51_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_51_value) = &self.parameter_51_value {
                format!("{parameter_51_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_52_name) = &self.parameter_52_name {
                format!("{parameter_52_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_52_value) = &self.parameter_52_value {
                format!("{parameter_52_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_53_name) = &self.parameter_53_name {
                format!("{parameter_53_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_53_value) = &self.parameter_53_value {
                format!("{parameter_53_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_54_name) = &self.parameter_54_name {
                format!("{parameter_54_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_54_value) = &self.parameter_54_value {
                format!("{parameter_54_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_55_name) = &self.parameter_55_name {
                format!("{parameter_55_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_55_value) = &self.parameter_55_value {
                format!("{parameter_55_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_56_name) = &self.parameter_56_name {
                format!("{parameter_56_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_56_value) = &self.parameter_56_value {
                format!("{parameter_56_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_57_name) = &self.parameter_57_name {
                format!("{parameter_57_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_57_value) = &self.parameter_57_value {
                format!("{parameter_57_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_58_name) = &self.parameter_58_name {
                format!("{parameter_58_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_58_value) = &self.parameter_58_value {
                format!("{parameter_58_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_59_name) = &self.parameter_59_name {
                format!("{parameter_59_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_59_value) = &self.parameter_59_value {
                format!("{parameter_59_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_60_name) = &self.parameter_60_name {
                format!("{parameter_60_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_60_value) = &self.parameter_60_value {
                format!("{parameter_60_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_61_name) = &self.parameter_61_name {
                format!("{parameter_61_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_61_value) = &self.parameter_61_value {
                format!("{parameter_61_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_62_name) = &self.parameter_62_name {
                format!("{parameter_62_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_62_value) = &self.parameter_62_value {
                format!("{parameter_62_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_63_name) = &self.parameter_63_name {
                format!("{parameter_63_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_63_value) = &self.parameter_63_value {
                format!("{parameter_63_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_64_name) = &self.parameter_64_name {
                format!("{parameter_64_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_64_value) = &self.parameter_64_value {
                format!("{parameter_64_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_65_name) = &self.parameter_65_name {
                format!("{parameter_65_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_65_value) = &self.parameter_65_value {
                format!("{parameter_65_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_66_name) = &self.parameter_66_name {
                format!("{parameter_66_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_66_value) = &self.parameter_66_value {
                format!("{parameter_66_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_67_name) = &self.parameter_67_name {
                format!("{parameter_67_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_67_value) = &self.parameter_67_value {
                format!("{parameter_67_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_68_name) = &self.parameter_68_name {
                format!("{parameter_68_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_68_value) = &self.parameter_68_value {
                format!("{parameter_68_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_69_name) = &self.parameter_69_name {
                format!("{parameter_69_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_69_value) = &self.parameter_69_value {
                format!("{parameter_69_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_70_name) = &self.parameter_70_name {
                format!("{parameter_70_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_70_value) = &self.parameter_70_value {
                format!("{parameter_70_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_71_name) = &self.parameter_71_name {
                format!("{parameter_71_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_71_value) = &self.parameter_71_value {
                format!("{parameter_71_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_72_name) = &self.parameter_72_name {
                format!("{parameter_72_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_72_value) = &self.parameter_72_value {
                format!("{parameter_72_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_73_name) = &self.parameter_73_name {
                format!("{parameter_73_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_73_value) = &self.parameter_73_value {
                format!("{parameter_73_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_74_name) = &self.parameter_74_name {
                format!("{parameter_74_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_74_value) = &self.parameter_74_value {
                format!("{parameter_74_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_75_name) = &self.parameter_75_name {
                format!("{parameter_75_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_75_value) = &self.parameter_75_value {
                format!("{parameter_75_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_76_name) = &self.parameter_76_name {
                format!("{parameter_76_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_76_value) = &self.parameter_76_value {
                format!("{parameter_76_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_77_name) = &self.parameter_77_name {
                format!("{parameter_77_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_77_value) = &self.parameter_77_value {
                format!("{parameter_77_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_78_name) = &self.parameter_78_name {
                format!("{parameter_78_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_78_value) = &self.parameter_78_value {
                format!("{parameter_78_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_79_name) = &self.parameter_79_name {
                format!("{parameter_79_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_79_value) = &self.parameter_79_value {
                format!("{parameter_79_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_80_name) = &self.parameter_80_name {
                format!("{parameter_80_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_80_value) = &self.parameter_80_value {
                format!("{parameter_80_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_81_name) = &self.parameter_81_name {
                format!("{parameter_81_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_81_value) = &self.parameter_81_value {
                format!("{parameter_81_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_82_name) = &self.parameter_82_name {
                format!("{parameter_82_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_82_value) = &self.parameter_82_value {
                format!("{parameter_82_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_83_name) = &self.parameter_83_name {
                format!("{parameter_83_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_83_value) = &self.parameter_83_value {
                format!("{parameter_83_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_84_name) = &self.parameter_84_name {
                format!("{parameter_84_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_84_value) = &self.parameter_84_value {
                format!("{parameter_84_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_85_name) = &self.parameter_85_name {
                format!("{parameter_85_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_85_value) = &self.parameter_85_value {
                format!("{parameter_85_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_86_name) = &self.parameter_86_name {
                format!("{parameter_86_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_86_value) = &self.parameter_86_value {
                format!("{parameter_86_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_87_name) = &self.parameter_87_name {
                format!("{parameter_87_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_87_value) = &self.parameter_87_value {
                format!("{parameter_87_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_88_name) = &self.parameter_88_name {
                format!("{parameter_88_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_88_value) = &self.parameter_88_value {
                format!("{parameter_88_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_89_name) = &self.parameter_89_name {
                format!("{parameter_89_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_89_value) = &self.parameter_89_value {
                format!("{parameter_89_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_90_name) = &self.parameter_90_name {
                format!("{parameter_90_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_90_value) = &self.parameter_90_value {
                format!("{parameter_90_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_91_name) = &self.parameter_91_name {
                format!("{parameter_91_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_91_value) = &self.parameter_91_value {
                format!("{parameter_91_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_92_name) = &self.parameter_92_name {
                format!("{parameter_92_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_92_value) = &self.parameter_92_value {
                format!("{parameter_92_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_93_name) = &self.parameter_93_name {
                format!("{parameter_93_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_93_value) = &self.parameter_93_value {
                format!("{parameter_93_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_94_name) = &self.parameter_94_name {
                format!("{parameter_94_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_94_value) = &self.parameter_94_value {
                format!("{parameter_94_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_95_name) = &self.parameter_95_name {
                format!("{parameter_95_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_95_value) = &self.parameter_95_value {
                format!("{parameter_95_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_96_name) = &self.parameter_96_name {
                format!("{parameter_96_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_96_value) = &self.parameter_96_value {
                format!("{parameter_96_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_97_name) = &self.parameter_97_name {
                format!("{parameter_97_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_97_value) = &self.parameter_97_value {
                format!("{parameter_97_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_98_name) = &self.parameter_98_name {
                format!("{parameter_98_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_98_value) = &self.parameter_98_value {
                format!("{parameter_98_value:?}")
            } else {
                String::new()
            },
            if let Some(parameter_99_name) = &self.parameter_99_name {
                format!("{parameter_99_name:?}")
            } else {
                String::new()
            },
            if let Some(parameter_99_value) = &self.parameter_99_value {
                format!("{parameter_99_value:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "url".to_string(),
            "name".to_string(),
            "track".to_string(),
            "status_callback".to_string(),
            "status_callback_method".to_string(),
            "parameter_1_name".to_string(),
            "parameter_1_value".to_string(),
            "parameter_2_name".to_string(),
            "parameter_2_value".to_string(),
            "parameter_3_name".to_string(),
            "parameter_3_value".to_string(),
            "parameter_4_name".to_string(),
            "parameter_4_value".to_string(),
            "parameter_5_name".to_string(),
            "parameter_5_value".to_string(),
            "parameter_6_name".to_string(),
            "parameter_6_value".to_string(),
            "parameter_7_name".to_string(),
            "parameter_7_value".to_string(),
            "parameter_8_name".to_string(),
            "parameter_8_value".to_string(),
            "parameter_9_name".to_string(),
            "parameter_9_value".to_string(),
            "parameter_10_name".to_string(),
            "parameter_10_value".to_string(),
            "parameter_11_name".to_string(),
            "parameter_11_value".to_string(),
            "parameter_12_name".to_string(),
            "parameter_12_value".to_string(),
            "parameter_13_name".to_string(),
            "parameter_13_value".to_string(),
            "parameter_14_name".to_string(),
            "parameter_14_value".to_string(),
            "parameter_15_name".to_string(),
            "parameter_15_value".to_string(),
            "parameter_16_name".to_string(),
            "parameter_16_value".to_string(),
            "parameter_17_name".to_string(),
            "parameter_17_value".to_string(),
            "parameter_18_name".to_string(),
            "parameter_18_value".to_string(),
            "parameter_19_name".to_string(),
            "parameter_19_value".to_string(),
            "parameter_20_name".to_string(),
            "parameter_20_value".to_string(),
            "parameter_21_name".to_string(),
            "parameter_21_value".to_string(),
            "parameter_22_name".to_string(),
            "parameter_22_value".to_string(),
            "parameter_23_name".to_string(),
            "parameter_23_value".to_string(),
            "parameter_24_name".to_string(),
            "parameter_24_value".to_string(),
            "parameter_25_name".to_string(),
            "parameter_25_value".to_string(),
            "parameter_26_name".to_string(),
            "parameter_26_value".to_string(),
            "parameter_27_name".to_string(),
            "parameter_27_value".to_string(),
            "parameter_28_name".to_string(),
            "parameter_28_value".to_string(),
            "parameter_29_name".to_string(),
            "parameter_29_value".to_string(),
            "parameter_30_name".to_string(),
            "parameter_30_value".to_string(),
            "parameter_31_name".to_string(),
            "parameter_31_value".to_string(),
            "parameter_32_name".to_string(),
            "parameter_32_value".to_string(),
            "parameter_33_name".to_string(),
            "parameter_33_value".to_string(),
            "parameter_34_name".to_string(),
            "parameter_34_value".to_string(),
            "parameter_35_name".to_string(),
            "parameter_35_value".to_string(),
            "parameter_36_name".to_string(),
            "parameter_36_value".to_string(),
            "parameter_37_name".to_string(),
            "parameter_37_value".to_string(),
            "parameter_38_name".to_string(),
            "parameter_38_value".to_string(),
            "parameter_39_name".to_string(),
            "parameter_39_value".to_string(),
            "parameter_40_name".to_string(),
            "parameter_40_value".to_string(),
            "parameter_41_name".to_string(),
            "parameter_41_value".to_string(),
            "parameter_42_name".to_string(),
            "parameter_42_value".to_string(),
            "parameter_43_name".to_string(),
            "parameter_43_value".to_string(),
            "parameter_44_name".to_string(),
            "parameter_44_value".to_string(),
            "parameter_45_name".to_string(),
            "parameter_45_value".to_string(),
            "parameter_46_name".to_string(),
            "parameter_46_value".to_string(),
            "parameter_47_name".to_string(),
            "parameter_47_value".to_string(),
            "parameter_48_name".to_string(),
            "parameter_48_value".to_string(),
            "parameter_49_name".to_string(),
            "parameter_49_value".to_string(),
            "parameter_50_name".to_string(),
            "parameter_50_value".to_string(),
            "parameter_51_name".to_string(),
            "parameter_51_value".to_string(),
            "parameter_52_name".to_string(),
            "parameter_52_value".to_string(),
            "parameter_53_name".to_string(),
            "parameter_53_value".to_string(),
            "parameter_54_name".to_string(),
            "parameter_54_value".to_string(),
            "parameter_55_name".to_string(),
            "parameter_55_value".to_string(),
            "parameter_56_name".to_string(),
            "parameter_56_value".to_string(),
            "parameter_57_name".to_string(),
            "parameter_57_value".to_string(),
            "parameter_58_name".to_string(),
            "parameter_58_value".to_string(),
            "parameter_59_name".to_string(),
            "parameter_59_value".to_string(),
            "parameter_60_name".to_string(),
            "parameter_60_value".to_string(),
            "parameter_61_name".to_string(),
            "parameter_61_value".to_string(),
            "parameter_62_name".to_string(),
            "parameter_62_value".to_string(),
            "parameter_63_name".to_string(),
            "parameter_63_value".to_string(),
            "parameter_64_name".to_string(),
            "parameter_64_value".to_string(),
            "parameter_65_name".to_string(),
            "parameter_65_value".to_string(),
            "parameter_66_name".to_string(),
            "parameter_66_value".to_string(),
            "parameter_67_name".to_string(),
            "parameter_67_value".to_string(),
            "parameter_68_name".to_string(),
            "parameter_68_value".to_string(),
            "parameter_69_name".to_string(),
            "parameter_69_value".to_string(),
            "parameter_70_name".to_string(),
            "parameter_70_value".to_string(),
            "parameter_71_name".to_string(),
            "parameter_71_value".to_string(),
            "parameter_72_name".to_string(),
            "parameter_72_value".to_string(),
            "parameter_73_name".to_string(),
            "parameter_73_value".to_string(),
            "parameter_74_name".to_string(),
            "parameter_74_value".to_string(),
            "parameter_75_name".to_string(),
            "parameter_75_value".to_string(),
            "parameter_76_name".to_string(),
            "parameter_76_value".to_string(),
            "parameter_77_name".to_string(),
            "parameter_77_value".to_string(),
            "parameter_78_name".to_string(),
            "parameter_78_value".to_string(),
            "parameter_79_name".to_string(),
            "parameter_79_value".to_string(),
            "parameter_80_name".to_string(),
            "parameter_80_value".to_string(),
            "parameter_81_name".to_string(),
            "parameter_81_value".to_string(),
            "parameter_82_name".to_string(),
            "parameter_82_value".to_string(),
            "parameter_83_name".to_string(),
            "parameter_83_value".to_string(),
            "parameter_84_name".to_string(),
            "parameter_84_value".to_string(),
            "parameter_85_name".to_string(),
            "parameter_85_value".to_string(),
            "parameter_86_name".to_string(),
            "parameter_86_value".to_string(),
            "parameter_87_name".to_string(),
            "parameter_87_value".to_string(),
            "parameter_88_name".to_string(),
            "parameter_88_value".to_string(),
            "parameter_89_name".to_string(),
            "parameter_89_value".to_string(),
            "parameter_90_name".to_string(),
            "parameter_90_value".to_string(),
            "parameter_91_name".to_string(),
            "parameter_91_value".to_string(),
            "parameter_92_name".to_string(),
            "parameter_92_value".to_string(),
            "parameter_93_name".to_string(),
            "parameter_93_value".to_string(),
            "parameter_94_name".to_string(),
            "parameter_94_value".to_string(),
            "parameter_95_name".to_string(),
            "parameter_95_value".to_string(),
            "parameter_96_name".to_string(),
            "parameter_96_value".to_string(),
            "parameter_97_name".to_string(),
            "parameter_97_value".to_string(),
            "parameter_98_name".to_string(),
            "parameter_98_value".to_string(),
            "parameter_99_name".to_string(),
            "parameter_99_value".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateStreamRequest {
    #[serde(rename = "Status")]
    pub status: StreamEnumUpdateStatus,
}

impl std::fmt::Display for UpdateStreamRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateStreamRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![format!("{:?}", self.status)]
    }

    fn headers() -> Vec<String> {
        vec!["status".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateTokenRequest {
    #[doc = "The duration in seconds for which the generated credentials are valid. The default \
             value is 86400 (24 hours)."]
    #[serde(rename = "Ttl", default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

impl std::fmt::Display for CreateTokenRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateTokenRequest {
    const LENGTH: usize = 1;
    fn fields(&self) -> Vec<String> {
        vec![if let Some(ttl) = &self.ttl {
            format!("{ttl:?}")
        } else {
            String::new()
        }]
    }

    fn headers() -> Vec<String> {
        vec!["ttl".to_string()]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListTranscriptionResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub transcriptions: Option<Vec<ApiV2010AccountTranscription>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListTranscriptionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListTranscriptionResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(transcriptions) = &self.transcriptions {
                format!("{transcriptions:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "transcriptions".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListUsageRecordResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_records: Option<Vec<ApiV2010AccountUsageUsageRecord>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListUsageRecordResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListUsageRecordResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(usage_records) = &self.usage_records {
                format!("{usage_records:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "usage_records".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListUsageRecordAllTimeResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_records: Option<Vec<ApiV2010AccountUsageUsageRecordUsageRecordAllTime>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListUsageRecordAllTimeResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListUsageRecordAllTimeResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(usage_records) = &self.usage_records {
                format!("{usage_records:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "usage_records".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListUsageRecordDailyResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_records: Option<Vec<ApiV2010AccountUsageUsageRecordUsageRecordDaily>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListUsageRecordDailyResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListUsageRecordDailyResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(usage_records) = &self.usage_records {
                format!("{usage_records:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "usage_records".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListUsageRecordLastMonthResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_records: Option<Vec<ApiV2010AccountUsageUsageRecordUsageRecordLastMonth>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListUsageRecordLastMonthResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListUsageRecordLastMonthResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(usage_records) = &self.usage_records {
                format!("{usage_records:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "usage_records".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListUsageRecordMonthlyResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_records: Option<Vec<ApiV2010AccountUsageUsageRecordUsageRecordMonthly>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListUsageRecordMonthlyResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListUsageRecordMonthlyResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(usage_records) = &self.usage_records {
                format!("{usage_records:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "usage_records".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListUsageRecordThisMonthResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_records: Option<Vec<ApiV2010AccountUsageUsageRecordUsageRecordThisMonth>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListUsageRecordThisMonthResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListUsageRecordThisMonthResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(usage_records) = &self.usage_records {
                format!("{usage_records:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "usage_records".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListUsageRecordTodayResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_records: Option<Vec<ApiV2010AccountUsageUsageRecordUsageRecordToday>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListUsageRecordTodayResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListUsageRecordTodayResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(usage_records) = &self.usage_records {
                format!("{usage_records:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "usage_records".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListUsageRecordYearlyResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_records: Option<Vec<ApiV2010AccountUsageUsageRecordUsageRecordYearly>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListUsageRecordYearlyResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListUsageRecordYearlyResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(usage_records) = &self.usage_records {
                format!("{usage_records:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "usage_records".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListUsageRecordYesterdayResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_records: Option<Vec<ApiV2010AccountUsageUsageRecordUsageRecordYesterday>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListUsageRecordYesterdayResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListUsageRecordYesterdayResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(usage_records) = &self.usage_records {
                format!("{usage_records:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "usage_records".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[doc = "The HTTP method we should use to call `callback_url`. Can be: `GET` or `POST` and the \
         default is `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum UpdateUsageTriggerRequestCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct UpdateUsageTriggerRequest {
    #[doc = "The HTTP method we should use to call `callback_url`. Can be: `GET` or `POST` and \
             the default is `POST`."]
    #[serde(
        rename = "CallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub callback_method: Option<UpdateUsageTriggerRequestCallbackMethod>,
    #[doc = "The URL we should call using `callback_method` when the trigger fires."]
    #[serde(
        rename = "CallbackUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub callback_url: Option<String>,
    #[doc = "A descriptive string that you create to describe the resource. It can be up to 64 \
             characters long."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
}

impl std::fmt::Display for UpdateUsageTriggerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for UpdateUsageTriggerRequest {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(callback_method) = &self.callback_method {
                format!("{callback_method:?}")
            } else {
                String::new()
            },
            if let Some(callback_url) = &self.callback_url {
                format!("{callback_url:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "callback_method".to_string(),
            "callback_url".to_string(),
            "friendly_name".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct ListUsageTriggerResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage_triggers: Option<Vec<ApiV2010AccountUsageUsageTrigger>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub first_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_page_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

impl std::fmt::Display for ListUsageTriggerResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for ListUsageTriggerResponse {
    const LENGTH: usize = 9;
    fn fields(&self) -> Vec<String> {
        vec![
            if let Some(usage_triggers) = &self.usage_triggers {
                format!("{usage_triggers:?}")
            } else {
                String::new()
            },
            if let Some(end) = &self.end {
                format!("{end:?}")
            } else {
                String::new()
            },
            if let Some(first_page_uri) = &self.first_page_uri {
                format!("{first_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(next_page_uri) = &self.next_page_uri {
                format!("{next_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(page) = &self.page {
                format!("{page:?}")
            } else {
                String::new()
            },
            if let Some(page_size) = &self.page_size {
                format!("{page_size:?}")
            } else {
                String::new()
            },
            if let Some(previous_page_uri) = &self.previous_page_uri {
                format!("{previous_page_uri:?}")
            } else {
                String::new()
            },
            if let Some(start) = &self.start {
                format!("{start:?}")
            } else {
                String::new()
            },
            if let Some(uri) = &self.uri {
                format!("{uri:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "usage_triggers".to_string(),
            "end".to_string(),
            "first_page_uri".to_string(),
            "next_page_uri".to_string(),
            "page".to_string(),
            "page_size".to_string(),
            "previous_page_uri".to_string(),
            "start".to_string(),
            "uri".to_string(),
        ]
    }
}

#[doc = "The HTTP method we should use to call `callback_url`. Can be: `GET` or `POST` and the \
         default is `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateUsageTriggerRequestCallbackMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateUsageTriggerRequest {
    #[doc = "The URL we should call using `callback_method` when the trigger fires."]
    #[serde(rename = "CallbackUrl")]
    pub callback_url: String,
    #[doc = "The usage value at which the trigger should fire.  For convenience, you can use an \
             offset value such as `+30` to specify a trigger_value that is 30 units more than the \
             current usage value. Be sure to urlencode a `+` as `%2B`."]
    #[serde(rename = "TriggerValue")]
    pub trigger_value: String,
    #[serde(rename = "UsageCategory")]
    pub usage_category: UsageTriggerEnumUsageCategory,
    #[doc = "The HTTP method we should use to call `callback_url`. Can be: `GET` or `POST` and \
             the default is `POST`."]
    #[serde(
        rename = "CallbackMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub callback_method: Option<CreateUsageTriggerRequestCallbackMethod>,
    #[doc = "A descriptive string that you create to describe the resource. It can be up to 64 \
             characters long."]
    #[serde(
        rename = "FriendlyName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub friendly_name: Option<String>,
    #[serde(rename = "Recurring", default, skip_serializing_if = "Option::is_none")]
    pub recurring: Option<UsageTriggerEnumRecurring>,
    #[serde(rename = "TriggerBy", default, skip_serializing_if = "Option::is_none")]
    pub trigger_by: Option<UsageTriggerEnumTriggerField>,
}

impl std::fmt::Display for CreateUsageTriggerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateUsageTriggerRequest {
    const LENGTH: usize = 7;
    fn fields(&self) -> Vec<String> {
        vec![
            self.callback_url.clone(),
            self.trigger_value.clone(),
            format!("{:?}", self.usage_category),
            if let Some(callback_method) = &self.callback_method {
                format!("{callback_method:?}")
            } else {
                String::new()
            },
            if let Some(friendly_name) = &self.friendly_name {
                format!("{friendly_name:?}")
            } else {
                String::new()
            },
            if let Some(recurring) = &self.recurring {
                format!("{recurring:?}")
            } else {
                String::new()
            },
            if let Some(trigger_by) = &self.trigger_by {
                format!("{trigger_by:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "callback_url".to_string(),
            "trigger_value".to_string(),
            "usage_category".to_string(),
            "callback_method".to_string(),
            "friendly_name".to_string(),
            "recurring".to_string(),
            "trigger_by".to_string(),
        ]
    }
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateUserDefinedMessageRequest {
    #[doc = "The User Defined Message in the form of URL-encoded JSON string."]
    #[serde(rename = "Content")]
    pub content: String,
    #[doc = "A unique string value to identify API call. This should be a unique string value per \
             API call and can be a randomly generated."]
    #[serde(
        rename = "IdempotencyKey",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub idempotency_key: Option<String>,
}

impl std::fmt::Display for CreateUserDefinedMessageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateUserDefinedMessageRequest {
    const LENGTH: usize = 2;
    fn fields(&self) -> Vec<String> {
        vec![
            self.content.clone(),
            if let Some(idempotency_key) = &self.idempotency_key {
                format!("{idempotency_key:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec!["content".to_string(), "idempotency_key".to_string()]
    }
}

#[doc = "The HTTP method Twilio will use when requesting the above `Url`. Either `GET` or `POST`. \
         Default is `POST`."]
#[derive(
    serde :: Serialize,
    serde :: Deserialize,
    PartialEq,
    Hash,
    Debug,
    Clone,
    schemars :: JsonSchema,
    tabled :: Tabled,
    clap :: ValueEnum,
    parse_display :: FromStr,
    parse_display :: Display,
)]
pub enum CreateUserDefinedMessageSubscriptionRequestMethod {
    #[serde(rename = "HEAD")]
    #[display("HEAD")]
    Head,
    #[serde(rename = "GET")]
    #[display("GET")]
    Get,
    #[serde(rename = "POST")]
    #[display("POST")]
    Post,
    #[serde(rename = "PATCH")]
    #[display("PATCH")]
    Patch,
    #[serde(rename = "PUT")]
    #[display("PUT")]
    Put,
    #[serde(rename = "DELETE")]
    #[display("DELETE")]
    Delete,
}

#[derive(
    serde :: Serialize, serde :: Deserialize, PartialEq, Debug, Clone, schemars :: JsonSchema,
)]
pub struct CreateUserDefinedMessageSubscriptionRequest {
    #[doc = "The URL we should call using the `method` to send user defined events to your \
             application. URLs must contain a valid hostname (underscores are not permitted)."]
    #[serde(rename = "Callback")]
    pub callback: String,
    #[doc = "A unique string value to identify API call. This should be a unique string value per \
             API call and can be a randomly generated."]
    #[serde(
        rename = "IdempotencyKey",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub idempotency_key: Option<String>,
    #[doc = "The HTTP method Twilio will use when requesting the above `Url`. Either `GET` or \
             `POST`. Default is `POST`."]
    #[serde(rename = "Method", default, skip_serializing_if = "Option::is_none")]
    pub method: Option<CreateUserDefinedMessageSubscriptionRequestMethod>,
}

impl std::fmt::Display for CreateUserDefinedMessageSubscriptionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).map_err(|_| std::fmt::Error)?
        )
    }
}

impl tabled::Tabled for CreateUserDefinedMessageSubscriptionRequest {
    const LENGTH: usize = 3;
    fn fields(&self) -> Vec<String> {
        vec![
            self.callback.clone(),
            if let Some(idempotency_key) = &self.idempotency_key {
                format!("{idempotency_key:?}")
            } else {
                String::new()
            },
            if let Some(method) = &self.method {
                format!("{method:?}")
            } else {
                String::new()
            },
        ]
    }

    fn headers() -> Vec<String> {
        vec![
            "callback".to_string(),
            "idempotency_key".to_string(),
            "method".to_string(),
        ]
    }
}
